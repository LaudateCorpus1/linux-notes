From: <Saved by UnMHT Ver.8.3.0>
Subject: i386 and x86-64 Options - Using the GNU Compiler Collection (GCC)
Date: Fri, 23 Dec 2016 23:31:42 -0500
MIME-Version: 1.0
X-UnMHT-Save-State: Current-State
Content-Type: multipart/related;
	boundary="----=_Part_0528870A_8F38FF28.1592F19466B";
	type="text/html"

------=_Part_0528870A_8F38FF28.1592F19466B
Content-Location: http://gcc.gnu.org/onlinedocs/gcc-4.8.0/gcc/i386-and-x86_002d64-Options.html
Content-Transfer-Encoding: quoted-printable
Content-Type: text/html;
	charset="UTF-8"

<html lang=3D"en"><head><meta http-equiv=3D"Content-Type" content=3D"text/h=
tml; charset=3DUTF-8"><link href=3D"data:image/x-icon;base64,AAABAAEAEBAQAA=
AAAABoAwAAFgAAACgAAAAQAAAAIAAAAAEAGAAAAAAAAAMAABILAAASCwAAAAAAAAAAAADc3Nzc3=
Nzc3Nz/wv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv//wv//wv/c3Nzc3Nzc3Nzc3Nzc3Nz/wv/Fwv/F=
wv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv//wv/c3Nzc3Nzc3Nz/wv/Fwv/Fwv8AAAAAAADFwv/=
Fwv8AAAAAAADFwv/Fwv8AAAAAAAD/wv/c3Nzc3Nz/wv/Fwv8AAADFwv8AAADFwv8AAADFwv/Fwv=
/Fwv8AAADFwv/Fwv/Fwv/c3Nzc3Nz/wv/Fwv8AAADFwv/Fwv/Fwv8AAADFwv/Fwv/Fwv8AAADFw=
v/Fwv/Fwv//wv//wv//wv/Fwv/Fwv8AAAAAAADFwv/Fwv8AAAAAAADFwv/Fwv8AAAAAAADFwv//=
wv//wv//wv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv/Fwv//wv//wv//wv/=
Fwv/Fwv/Fwv/Fwv/Fwv8AgYMAgYMAQEH/AP//AP/Fwv/Fwv/Fwv//wv//wv//wv/Fwv/Fwv/Fwv=
8AQEEAgYMAgYMAgYMAgYP/AP8AAAAAQEHFwv/Fwv//wv/c3Nz/wv/Fwv/Fwv//wv8AAAAAQEEAg=
YMAgYMAgYMAAAAAgYMAgYMAgYP/wv/c3Nzc3Nz/wv/Fwv/Fwv//wv8AAAAAQEEAgYMAgYMAgYMA=
gYMAgYMAgYMAgYP/wv/c3Nzc3Nz/wv//wv/Fwv//wv//wv8AAAAAQEEAgYMAgYMAgYMAgYMAQEE=
AQEH/wv/c3Nzc3Nzc3Nz/wv/Fwv/Fwv//wv//AP8AQEEAgYMAAAAAgYMAAAD/wv//wv/c3Nzc3N=
zc3Nzc3Nzc3Nz/wv/Fwv/Fwv//wv+DgYODgYMAgYMAgYODgYODgYPc3Nzc3Nzc3Nzc3Nzc3Nzc3=
Nzc3Nz/wv/Fwv+koaSDgYP/AP//AP//AP//wv+DgYOkoaTc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nz/=
wv/Fwv+DgYOkoaTFwv/Fwv+koaSDgYPc3Nzc3Nzc3NzgB///wAP//4AB//+AAf//gAD//wAA//8=
AAP//AAD//wAA//+AAf//gAH//4AB///AA///4Af///AD///4B///" rel=3D"shortcut icon=
" type=3D"image/x-icon">
<title>i386 and x86-64 Options - Using the GNU Compiler Collection (GCC)</t=
itle>
<meta http-equiv=3D"Content-Type" content=3D"text/html">
<meta content=3D"Using the GNU Compiler Collection (GCC)" name=3D"descripti=
on">
<meta content=3D"makeinfo 4.13" name=3D"generator">
<link href=3D"index.html#Top" rel=3D"start" title=3D"Top">
<link href=3D"Submodel-Options.html#Submodel-Options" rel=3D"up" title=3D"S=
ubmodel Options">
<link href=3D"HPPA-Options.html#HPPA-Options" rel=3D"prev" title=3D"HPPA Op=
tions">
<link href=3D"i386-and-x86_002d64-Windows-Options.html#i386-and-x86_002d64-=
Windows-Options" rel=3D"next" title=3D"i386 and x86-64 Windows Options">
<link href=3D"http://www.gnu.org/software/texinfo/" rel=3D"generator-home" =
title=3D"Texinfo Homepage">
<!--
Copyright (C) 1988-2013 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Funding Free Software'', the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv=3D"Content-Style-Type" content=3D"text/css">
<style type=3D"text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; }=20
  span.sansserif { font-family:sans-serif; font-weight:normal; }=20
--></style>
<base href=3D"http://gcc.gnu.org/onlinedocs/gcc-4.8.0/gcc/"></head>
<body>
<div class=3D"node">
<a name=3D"i386-and-x86-64-Options"></a>
<a name=3D"i386-and-x86_002d64-Options"></a>
<p>
Next:&#xa0;<a accesskey=3D"n" href=3D"i386-and-x86_002d64-Windows-Options.h=
tml#i386-and-x86_002d64-Windows-Options" rel=3D"next">i386 and x86-64 Windo=
ws Options</a>,
Previous:&#xa0;<a accesskey=3D"p" href=3D"HPPA-Options.html#HPPA-Options" r=
el=3D"previous">HPPA Options</a>,
Up:&#xa0;<a accesskey=3D"u" href=3D"Submodel-Options.html#Submodel-Options"=
 rel=3D"up">Submodel Options</a>
</p><hr>
</div>

<h4 class=3D"subsection">3.17.16 Intel 386 and AMD x86-64 Options</h4>

<p><a name=3D"index-i386-Options-1435"></a><a name=3D"index-x86_002d64-Opti=
ons-1436"></a><a name=3D"index-Intel-386-Options-1437"></a><a name=3D"index=
-AMD-x86_002d64-Options-1438"></a>
These =E2=80=98<samp><span class=3D"samp">-m</span></samp>=E2=80=99 options=
 are defined for the i386 and x86-64 family of
computers:

     </p><dl>
<dt><code>-march=3D</code><var>cpu-type</var></dt><dd><a name=3D"index-marc=
h-1439"></a>Generate instructions for the machine type <var>cpu-type</var>.=
  In contrast to
<samp><span class=3D"option">-mtune=3D</span><var>cpu-type</var></samp>, wh=
ich merely tunes the generated code
for the specified <var>cpu-type</var>, <samp><span class=3D"option">-march=
=3D</span><var>cpu-type</var></samp> allows GCC
to generate code that may not run at all on processors other than the one
indicated.  Specifying <samp><span class=3D"option">-march=3D</span><var>cp=
u-type</var></samp> implies
<samp><span class=3D"option">-mtune=3D</span><var>cpu-type</var></samp>.

     <p>The choices for <var>cpu-type</var> are:

          </p><dl>
<dt>=E2=80=98<samp><span class=3D"samp">native</span></samp>=E2=80=99</dt><=
dd>This selects the CPU to generate code for at compilation time by determi=
ning
the processor type of the compiling machine.  Using <samp><span class=3D"op=
tion">-march=3Dnative</span></samp>
enables all instruction subsets supported by the local machine (hence
the result might not run on different machines).  Using <samp><span class=
=3D"option">-mtune=3Dnative</span></samp>
produces code optimized for the local machine under the constraints
of the selected instruction set.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">i386</span></sam=
p>=E2=80=99</dt><dd>Original Intel i386 CPU.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">i486</span></sam=
p>=E2=80=99</dt><dd>Intel i486 CPU.  (No scheduling is implemented for this=
 chip.)

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">i586</span></sam=
p>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">pentium</span></sam=
p>=E2=80=99</dt><dd>Intel Pentium CPU with no MMX support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">pentium-mmx</spa=
n></samp>=E2=80=99</dt><dd>Intel Pentium MMX CPU, based on Pentium core wit=
h MMX instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">pentiumpro</span=
></samp>=E2=80=99</dt><dd>Intel Pentium Pro CPU.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">i686</span></sam=
p>=E2=80=99</dt><dd>When used with <samp><span class=3D"option">-march</spa=
n></samp>, the Pentium Pro
instruction set is used, so the code runs on all i686 family chips.=20
When used with <samp><span class=3D"option">-mtune</span></samp>, it has th=
e same meaning as =E2=80=98<samp><span class=3D"samp">generic</span></samp>=
=E2=80=99.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">pentium2</span><=
/samp>=E2=80=99</dt><dd>Intel Pentium II CPU, based on Pentium Pro core wit=
h MMX instruction set
support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">pentium3</span><=
/samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">pentium3m</span=
></samp>=E2=80=99</dt><dd>Intel Pentium III CPU, based on Pentium Pro core =
with MMX and SSE instruction
set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">pentium-m</span>=
</samp>=E2=80=99</dt><dd>Intel Pentium M; low-power version of Intel Pentiu=
m III CPU
with MMX, SSE and SSE2 instruction set support.  Used by Centrino notebooks.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">pentium4</span><=
/samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">pentium4m</span=
></samp>=E2=80=99</dt><dd>Intel Pentium 4 CPU with MMX, SSE and SSE2 instru=
ction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">prescott</span><=
/samp>=E2=80=99</dt><dd>Improved version of Intel Pentium 4 CPU with MMX, S=
SE, SSE2 and SSE3 instruction
set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">nocona</span></s=
amp>=E2=80=99</dt><dd>Improved version of Intel Pentium 4 CPU with 64-bit e=
xtensions, MMX, SSE,
SSE2 and SSE3 instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">core2</span></sa=
mp>=E2=80=99</dt><dd>Intel Core 2 CPU with 64-bit extensions, MMX, SSE, SSE=
2, SSE3 and SSSE3
instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">corei7</span></s=
amp>=E2=80=99</dt><dd>Intel Core i7 CPU with 64-bit extensions, MMX, SSE, S=
SE2, SSE3, SSSE3, SSE4.1
and SSE4.2 instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">corei7-avx</span=
></samp>=E2=80=99</dt><dd>Intel Core i7 CPU with 64-bit extensions, MMX, SS=
E, SSE2, SSE3, SSSE3,
SSE4.1, SSE4.2, AVX, AES and PCLMUL instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">core-avx-i</span=
></samp>=E2=80=99</dt><dd>Intel Core CPU with 64-bit extensions, MMX, SSE, =
SSE2, SSE3, SSSE3,
SSE4.1, SSE4.2, AVX, AES, PCLMUL, FSGSBASE, RDRND and F16C instruction
set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">atom</span></sam=
p>=E2=80=99</dt><dd>Intel Atom CPU with 64-bit extensions, MMX, SSE, SSE2, =
SSE3 and SSSE3
instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">k6</span></samp>=
=E2=80=99</dt><dd>AMD K6 CPU with MMX instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">k6-2</span></sam=
p>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">k6-3</span></samp>=
=E2=80=99</dt><dd>Improved versions of AMD K6 CPU with MMX and 3DNow! instr=
uction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">athlon</span></s=
amp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">athlon-tbird</spa=
n></samp>=E2=80=99</dt><dd>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow!=
 and SSE prefetch instructions
support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">athlon-4</span><=
/samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">athlon-xp</span=
></samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">athlon-mp</sp=
an></samp>=E2=80=99</dt><dd>Improved AMD Athlon CPU with MMX, 3DNow!, enhan=
ced 3DNow! and full SSE
instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">k8</span></samp>=
=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">opteron</span></samp>=
=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">athlon64</span></samp=
>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">athlon-fx</span></sa=
mp>=E2=80=99</dt><dd>Processors based on the AMD K8 core with x86-64 instru=
ction set support,
including the AMD Opteron, Athlon 64, and Athlon 64 FX processors.=20
(This supersets MMX, SSE, SSE2, 3DNow!, enhanced 3DNow! and 64-bit
instruction set extensions.)

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">k8-sse3</span></=
samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">opteron-sse3</sp=
an></samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">athlon64-ss=
e3</span></samp>=E2=80=99</dt><dd>Improved versions of AMD K8 cores with SS=
E3 instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">amdfam10</span><=
/samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">barcelona</span=
></samp>=E2=80=99</dt><dd>CPUs based on AMD Family 10h cores with x86-64 in=
struction set support.  (This
supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-=
bit
instruction set extensions.)

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">bdver1</span></s=
amp>=E2=80=99</dt><dd>CPUs based on AMD Family 15h cores with x86-64 instru=
ction set support.  (This
supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SS=
E4A,
SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)=20
<br></dd><dt>=E2=80=98<samp><span class=3D"samp">bdver2</span></samp>=E2=80=
=99</dt><dd>AMD Family 15h core based CPUs with x86-64 instruction set supp=
ort.  (This
supersets BMI, TBM, F16C, FMA, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE,
SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set
extensions.)=20
<br></dd><dt>=E2=80=98<samp><span class=3D"samp">bdver3</span></samp>=E2=80=
=99</dt><dd>AMD Family 15h core based CPUs with x86-64 instruction set supp=
ort.  (This
supersets BMI, TBM, F16C, FMA, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE,
SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set
extensions.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">btver1</span></s=
amp>=E2=80=99</dt><dd>CPUs based on AMD Family 14h cores with x86-64 instru=
ction set support.  (This
supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit
instruction set extensions.)

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">btver2</span></s=
amp>=E2=80=99</dt><dd>CPUs based on AMD Family 16h cores with x86-64 instru=
ction set support. This
includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM,
SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">winchip-c6</span=
></samp>=E2=80=99</dt><dd>IDT WinChip C6 CPU, dealt in same way as i486 wit=
h additional MMX instruction
set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">winchip2</span><=
/samp>=E2=80=99</dt><dd>IDT WinChip 2 CPU, dealt in same way as i486 with a=
dditional MMX and 3DNow!=20
instruction set support.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">c3</span></samp>=
=E2=80=99</dt><dd>VIA C3 CPU with MMX and 3DNow! instruction set support.  =
(No scheduling is
implemented for this chip.)

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">c3-2</span></sam=
p>=E2=80=99</dt><dd>VIA C3-2 (Nehemiah/C5XL) CPU with MMX and SSE instructi=
on set support.=20
(No scheduling is
implemented for this chip.)

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">geode</span></sa=
mp>=E2=80=99</dt><dd>AMD Geode embedded processor with MMX and 3DNow! instr=
uction set support.=20
</dd></dl>

     <br></dd><dt><code>-mtune=3D</code><var>cpu-type</var></dt><dd><a name=
=3D"index-mtune-1440"></a>Tune to <var>cpu-type</var> everything applicable=
 about the generated code, except
for the ABI and the set of available instructions.=20
While picking a specific <var>cpu-type</var> schedules things appropriately
for that particular chip, the compiler does not generate any code that
cannot run on the default machine type unless you use a
<samp><span class=3D"option">-march=3D</span><var>cpu-type</var></samp> opt=
ion.=20
For example, if GCC is configured for i686-pc-linux-gnu
then <samp><span class=3D"option">-mtune=3Dpentium4</span></samp> generates=
 code that is tuned for Pentium 4
but still runs on i686 machines.

     <p>The choices for <var>cpu-type</var> are the same as for <samp><span=
 class=3D"option">-march</span></samp>.=20
In addition, <samp><span class=3D"option">-mtune</span></samp> supports an =
extra choice for <var>cpu-type</var>:

          </p><dl>
<dt>=E2=80=98<samp><span class=3D"samp">generic</span></samp>=E2=80=99</dt>=
<dd>Produce code optimized for the most common IA32/AMD64/EM64T processors.=
=20
If you know the CPU on which your code will run, then you should use
the corresponding <samp><span class=3D"option">-mtune</span></samp> or <sam=
p><span class=3D"option">-march</span></samp> option instead of
<samp><span class=3D"option">-mtune=3Dgeneric</span></samp>.  But, if you d=
o not know exactly what CPU users
of your application will have, then you should use this option.

          <p>As new processors are deployed in the marketplace, the behavio=
r of this
option will change.  Therefore, if you upgrade to a newer version of
GCC, code generation controlled by this option will change to reflect
the processors
that are most common at the time that version of GCC is released.

          </p><p>There is no <samp><span class=3D"option">-march=3Dgeneric<=
/span></samp> option because <samp><span class=3D"option">-march</span></sa=
mp>
indicates the instruction set the compiler can use, and there is no
generic instruction set applicable to all processors.  In contrast,
<samp><span class=3D"option">-mtune</span></samp> indicates the processor (=
or, in this case, collection of
processors) for which the code is optimized.=20
</p></dd></dl>

     <br></dd><dt><code>-mcpu=3D</code><var>cpu-type</var></dt><dd><a name=
=3D"index-mcpu-1441"></a>A deprecated synonym for <samp><span class=3D"opti=
on">-mtune</span></samp>.

     <br></dd><dt><code>-mfpmath=3D</code><var>unit</var></dt><dd><a name=
=3D"index-mfpmath-1442"></a>Generate floating-point arithmetic for selected=
 unit <var>unit</var>.  The choices
for <var>unit</var> are:

          <dl>
<dt>=E2=80=98<samp><span class=3D"samp">387</span></samp>=E2=80=99</dt><dd>=
Use the standard 387 floating-point coprocessor present on the majority of =
chips and
emulated otherwise.  Code compiled with this option runs almost everywhere.=
=20
The temporary results are computed in 80-bit precision instead of the preci=
sion
specified by the type, resulting in slightly different results compared to =
most
of other chips.  See <samp><span class=3D"option">-ffloat-store</span></sam=
p> for more detailed description.

          <p>This is the default choice for i386 compiler.

          <br></p></dd><dt>=E2=80=98<samp><span class=3D"samp">sse</span></=
samp>=E2=80=99</dt><dd>Use scalar floating-point instructions present in th=
e SSE instruction set.=20
This instruction set is supported by Pentium III and newer chips,
and in the AMD line
by Athlon-4, Athlon XP and Athlon MP chips.  The earlier version of the SSE
instruction set supports only single-precision arithmetic, thus the double =
and
extended-precision arithmetic are still done using 387.  A later version, p=
resent
only in Pentium 4 and AMD x86-64 chips, supports double-precision
arithmetic too.

          <p>For the i386 compiler, you must use <samp><span class=3D"optio=
n">-march=3D</span><var>cpu-type</var></samp>, <samp><span class=3D"option"=
>-msse</span></samp>
or <samp><span class=3D"option">-msse2</span></samp> switches to enable SSE=
 extensions and make this option
effective.  For the x86-64 compiler, these extensions are enabled by defaul=
t.

          </p><p>The resulting code should be considerably faster in the ma=
jority of cases and avoid
the numerical instability problems of 387 code, but may break some existing
code that expects temporaries to be 80 bits.

          </p><p>This is the default choice for the x86-64 compiler.

          <br></p></dd><dt>=E2=80=98<samp><span class=3D"samp">sse,387</spa=
n></samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">sse+387</spa=
n></samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">both</span><=
/samp>=E2=80=99</dt><dd>Attempt to utilize both instruction sets at once.  =
This effectively doubles the
amount of available registers, and on chips with separate execution units f=
or
387 and SSE the execution resources too.  Use this option with care, as it =
is
still experimental, because the GCC register allocator does not model separ=
ate
functional units well, resulting in unstable performance.=20
</dd></dl>

     <br></dd><dt><code>-masm=3D</code><var>dialect</var></dt><dd><a name=
=3D"index-masm_003d_0040var_007bdialect_007d-1443"></a>Output assembly inst=
ructions using selected <var>dialect</var>.  Supported
choices are =E2=80=98<samp><span class=3D"samp">intel</span></samp>=E2=80=
=99 or =E2=80=98<samp><span class=3D"samp">att</span></samp>=E2=80=99 (the =
default).  Darwin does
not support =E2=80=98<samp><span class=3D"samp">intel</span></samp>=E2=80=
=99.

     <br></dd><dt><code>-mieee-fp</code></dt><dt><code>-mno-ieee-fp</code><=
/dt><dd><a name=3D"index-mieee_002dfp-1444"></a><a name=3D"index-mno_002die=
ee_002dfp-1445"></a>Control whether or not the compiler uses IEEE floating-=
point
comparisons.  These correctly handle the case where the result of a
comparison is unordered.

     <br></dd><dt><code>-msoft-float</code></dt><dd><a name=3D"index-msoft_=
002dfloat-1446"></a>Generate output containing library calls for floating p=
oint.

     <p><strong>Warning:</strong> the requisite libraries are not part of G=
CC.=20
Normally the facilities of the machine&#x27;s usual C compiler are used, but
this can&#x27;t be done directly in cross-compilation.  You must make your
own arrangements to provide suitable library functions for
cross-compilation.

     </p><p>On machines where a function returns floating-point results in =
the 80387
register stack, some floating-point opcodes may be emitted even if
<samp><span class=3D"option">-msoft-float</span></samp> is used.

     <br></p></dd><dt><code>-mno-fp-ret-in-387</code></dt><dd><a name=3D"in=
dex-mno_002dfp_002dret_002din_002d387-1447"></a>Do not use the FPU register=
s for return values of functions.

     <p>The usual calling convention has functions return values of types
<code>float</code> and <code>double</code> in an FPU register, even if there
is no FPU.  The idea is that the operating system should emulate
an FPU.

     </p><p>The option <samp><span class=3D"option">-mno-fp-ret-in-387</spa=
n></samp> causes such values to be returned
in ordinary CPU registers instead.

     <br></p></dd><dt><code>-mno-fancy-math-387</code></dt><dd><a name=3D"i=
ndex-mno_002dfancy_002dmath_002d387-1448"></a>Some 387 emulators do not sup=
port the <code>sin</code>, <code>cos</code> and
<code>sqrt</code> instructions for the 387.  Specify this option to avoid
generating those instructions.  This option is the default on FreeBSD,
OpenBSD and NetBSD.  This option is overridden when <samp><span class=3D"op=
tion">-march</span></samp>
indicates that the target CPU always has an FPU and so the
instruction does not need emulation.  These
instructions are not generated unless you also use the
<samp><span class=3D"option">-funsafe-math-optimizations</span></samp> swit=
ch.

     <br></dd><dt><code>-malign-double</code></dt><dt><code>-mno-align-doub=
le</code></dt><dd><a name=3D"index-malign_002ddouble-1449"></a><a name=3D"i=
ndex-mno_002dalign_002ddouble-1450"></a>Control whether GCC aligns <code>do=
uble</code>, <code>long double</code>, and
<code>long long</code> variables on a two-word boundary or a one-word
boundary.  Aligning <code>double</code> variables on a two-word boundary
produces code that runs somewhat faster on a Pentium at the
expense of more memory.

     <p>On x86-64, <samp><span class=3D"option">-malign-double</span></samp=
> is enabled by default.

     </p><p><strong>Warning:</strong> if you use the <samp><span class=3D"o=
ption">-malign-double</span></samp> switch,
structures containing the above types are aligned differently than
the published application binary interface specifications for the 386
and are not binary compatible with structures in code compiled
without that switch.

     <br></p></dd><dt><code>-m96bit-long-double</code></dt><dt><code>-m128b=
it-long-double</code></dt><dd><a name=3D"index-m96bit_002dlong_002ddouble-1=
451"></a><a name=3D"index-m128bit_002dlong_002ddouble-1452"></a>These switc=
hes control the size of <code>long double</code> type.  The i386
application binary interface specifies the size to be 96 bits,
so <samp><span class=3D"option">-m96bit-long-double</span></samp> is the de=
fault in 32-bit mode.

     <p>Modern architectures (Pentium and newer) prefer <code>long double</=
code>
to be aligned to an 8- or 16-byte boundary.  In arrays or structures
conforming to the ABI, this is not possible.  So specifying
<samp><span class=3D"option">-m128bit-long-double</span></samp> aligns <cod=
e>long double</code>
to a 16-byte boundary by padding the <code>long double</code> with an addit=
ional
32-bit zero.

     </p><p>In the x86-64 compiler, <samp><span class=3D"option">-m128bit-l=
ong-double</span></samp> is the default choice as
its ABI specifies that <code>long double</code> is aligned on 16-byte bound=
ary.

     </p><p>Notice that neither of these options enable any extra precision=
 over the x87
standard of 80 bits for a <code>long double</code>.

     </p><p><strong>Warning:</strong> if you override the default value for=
 your target ABI, this
changes the size of
structures and arrays containing <code>long double</code> variables,
as well as modifying the function calling convention for functions taking
<code>long double</code>.  Hence they are not binary-compatible
with code compiled without that switch.

     <br></p></dd><dt><code>-mlong-double-64</code></dt><dt><code>-mlong-do=
uble-80</code></dt><dd><a name=3D"index-mlong_002ddouble_002d64-1453"></a><=
a name=3D"index-mlong_002ddouble_002d80-1454"></a>These switches control th=
e size of <code>long double</code> type. A size
of 64 bits makes the <code>long double</code> type equivalent to the <code>=
double</code>
type. This is the default for Bionic C library.

     <p><strong>Warning:</strong> if you override the default value for you=
r target ABI, this
changes the size of
structures and arrays containing <code>long double</code> variables,
as well as modifying the function calling convention for functions taking
<code>long double</code>.  Hence they are not binary-compatible
with code compiled without that switch.

     <br></p></dd><dt><code>-mlarge-data-threshold=3D</code><var>threshold<=
/var></dt><dd><a name=3D"index-mlarge_002ddata_002dthreshold-1455"></a>When=
 <samp><span class=3D"option">-mcmodel=3Dmedium</span></samp> is specified,=
 data objects larger than
<var>threshold</var> are placed in the large data section.  This value must=
 be the
same across all objects linked into the binary, and defaults to 65535.

     <br></dd><dt><code>-mrtd</code></dt><dd><a name=3D"index-mrtd-1456"></=
a>Use a different function-calling convention, in which functions that
take a fixed number of arguments return with the <code>ret </code><var>num<=
/var>
instruction, which pops their arguments while returning.  This saves one
instruction in the caller since there is no need to pop the arguments
there.

     <p>You can specify that an individual function is called with this cal=
ling
sequence with the function attribute =E2=80=98<samp><span class=3D"samp">st=
dcall</span></samp>=E2=80=99.  You can also
override the <samp><span class=3D"option">-mrtd</span></samp> option by usi=
ng the function attribute
=E2=80=98<samp><span class=3D"samp">cdecl</span></samp>=E2=80=99.  See <a h=
ref=3D"Function-Attributes.html#Function-Attributes">Function Attributes</a=
>.

     </p><p><strong>Warning:</strong> this calling convention is incompatib=
le with the one
normally used on Unix, so you cannot use it if you need to call
libraries compiled with the Unix compiler.

     </p><p>Also, you must provide function prototypes for all functions th=
at
take variable numbers of arguments (including <code>printf</code>);
otherwise incorrect code is generated for calls to those
functions.

     </p><p>In addition, seriously incorrect code results if you call a
function with too many arguments.  (Normally, extra arguments are
harmlessly ignored.)

     <br></p></dd><dt><code>-mregparm=3D</code><var>num</var></dt><dd><a na=
me=3D"index-mregparm-1457"></a>Control how many registers are used to pass =
integer arguments.  By
default, no registers are used to pass arguments, and at most 3
registers can be used.  You can control this behavior for a specific
function by using the function attribute =E2=80=98<samp><span class=3D"samp=
">regparm</span></samp>=E2=80=99.=20
See <a href=3D"Function-Attributes.html#Function-Attributes">Function Attri=
butes</a>.

     <p><strong>Warning:</strong> if you use this switch, and
<var>num</var> is nonzero, then you must build all modules with the same
value, including any libraries.  This includes the system libraries and
startup modules.

     <br></p></dd><dt><code>-msseregparm</code></dt><dd><a name=3D"index-ms=
seregparm-1458"></a>Use SSE register passing conventions for float and doub=
le arguments
and return values.  You can control this behavior for a specific
function by using the function attribute =E2=80=98<samp><span class=3D"samp=
">sseregparm</span></samp>=E2=80=99.=20
See <a href=3D"Function-Attributes.html#Function-Attributes">Function Attri=
butes</a>.

     <p><strong>Warning:</strong> if you use this switch then you must buil=
d all
modules with the same value, including any libraries.  This includes
the system libraries and startup modules.

     <br></p></dd><dt><code>-mvect8-ret-in-mem</code></dt><dd><a name=3D"in=
dex-mvect8_002dret_002din_002dmem-1459"></a>Return 8-byte vectors in memory=
 instead of MMX registers.  This is the
default on Solaris&#xa0;8 and 9 and VxWorks to match the ABI of the Sun
Studio compilers until version 12.  Later compiler versions (starting
with Studio 12 Update&#xa0;1) follow the ABI used by other x86 targets, whi=
ch
is the default on Solaris&#xa0;10 and later.  <em>Only</em> use this option=
 if
you need to remain compatible with existing code produced by those
previous compiler versions or older versions of GCC.

     <br></dd><dt><code>-mpc32</code></dt><dt><code>-mpc64</code></dt><dt><=
code>-mpc80</code></dt><dd><a name=3D"index-mpc32-1460"></a><a name=3D"inde=
x-mpc64-1461"></a><a name=3D"index-mpc80-1462"></a>
Set 80387 floating-point precision to 32, 64 or 80 bits.  When <samp><span =
class=3D"option">-mpc32</span></samp>
is specified, the significands of results of floating-point operations are
rounded to 24 bits (single precision); <samp><span class=3D"option">-mpc64<=
/span></samp> rounds the
significands of results of floating-point operations to 53 bits (double
precision) and <samp><span class=3D"option">-mpc80</span></samp> rounds the=
 significands of results of
floating-point operations to 64 bits (extended double precision), which is
the default.  When this option is used, floating-point operations in higher
precisions are not available to the programmer without setting the FPU
control word explicitly.

     <p>Setting the rounding of floating-point operations to less than the =
default
80 bits can speed some programs by 2% or more.  Note that some mathematical
libraries assume that extended-precision (80-bit) floating-point operations
are enabled by default; routines in such libraries could suffer significant
loss of accuracy, typically through so-called =E2=80=9Ccatastrophic cancell=
ation=E2=80=9D,
when this option is used to set the precision to less than extended precisi=
on.

     <br></p></dd><dt><code>-mstackrealign</code></dt><dd><a name=3D"index-=
mstackrealign-1463"></a>Realign the stack at entry.  On the Intel x86, the =
<samp><span class=3D"option">-mstackrealign</span></samp>
option generates an alternate prologue and epilogue that realigns the
run-time stack if necessary.  This supports mixing legacy codes that keep
4-byte stack alignment with modern codes that keep 16-byte stack alignment =
for
SSE compatibility.  See also the attribute <code>force_align_arg_pointer</c=
ode>,
applicable to individual functions.

     <br></dd><dt><code>-mpreferred-stack-boundary=3D</code><var>num</var><=
/dt><dd><a name=3D"index-mpreferred_002dstack_002dboundary-1464"></a>Attemp=
t to keep the stack boundary aligned to a 2 raised to <var>num</var>
byte boundary.  If <samp><span class=3D"option">-mpreferred-stack-boundary<=
/span></samp> is not specified,
the default is 4 (16 bytes or 128 bits).

     <p><strong>Warning:</strong> When generating code for the x86-64 archi=
tecture with
SSE extensions disabled, <samp><span class=3D"option">-mpreferred-stack-bou=
ndary=3D3</span></samp> can be
used to keep the stack boundary aligned to 8 byte boundary.  Since
x86-64 ABI require 16 byte stack alignment, this is ABI incompatible and
intended to be used in controlled environment where stack space is
important limitation.  This option will lead to wrong code when functions
compiled with 16 byte stack alignment (such as functions from a standard
library) are called with misaligned stack.  In this case, SSE
instructions may lead to misaligned memory access traps.  In addition,
variable arguments will be handled incorrectly for 16 byte aligned
objects (including x87 long double and __int128), leading to wrong
results.  You must build all modules with
<samp><span class=3D"option">-mpreferred-stack-boundary=3D3</span></samp>, =
including any libraries.  This
includes the system libraries and startup modules.

     <br></p></dd><dt><code>-mincoming-stack-boundary=3D</code><var>num</va=
r></dt><dd><a name=3D"index-mincoming_002dstack_002dboundary-1465"></a>Assu=
me the incoming stack is aligned to a 2 raised to <var>num</var> byte
boundary.  If <samp><span class=3D"option">-mincoming-stack-boundary</span>=
</samp> is not specified,
the one specified by <samp><span class=3D"option">-mpreferred-stack-boundar=
y</span></samp> is used.

     <p>On Pentium and Pentium Pro, <code>double</code> and <code>long doub=
le</code> values
should be aligned to an 8-byte boundary (see <samp><span class=3D"option">-=
malign-double</span></samp>) or
suffer significant run time performance penalties.  On Pentium III, the
Streaming SIMD Extension (SSE) data type <code>__m128</code> may not work
properly if it is not 16-byte aligned.

     </p><p>To ensure proper alignment of this values on the stack, the sta=
ck boundary
must be as aligned as that required by any value stored on the stack.=20
Further, every function must be generated such that it keeps the stack
aligned.  Thus calling a function compiled with a higher preferred
stack boundary from a function compiled with a lower preferred stack
boundary most likely misaligns the stack.  It is recommended that
libraries that use callbacks always use the default setting.

     </p><p>This extra alignment does consume extra stack space, and genera=
lly
increases code size.  Code that is sensitive to stack space usage, such
as embedded systems and operating system kernels, may want to reduce the
preferred alignment to <samp><span class=3D"option">-mpreferred-stack-bound=
ary=3D2</span></samp>.

     <br></p></dd><dt><code>-mmmx</code></dt><dt><code>-mno-mmx</code></dt>=
<dt><code>-msse</code></dt><dt><code>-mno-sse</code></dt><dt><code>-msse2</=
code></dt><dt><code>-mno-sse2</code></dt><dt><code>-msse3</code></dt><dt><c=
ode>-mno-sse3</code></dt><dt><code>-mssse3</code></dt><dt><code>-mno-ssse3<=
/code></dt><dt><code>-msse4.1</code></dt><dt><code>-mno-sse4.1</code></dt><=
dt><code>-msse4.2</code></dt><dt><code>-mno-sse4.2</code></dt><dt><code>-ms=
se4</code></dt><dt><code>-mno-sse4</code></dt><dt><code>-mavx</code></dt><d=
t><code>-mno-avx</code></dt><dt><code>-mavx2</code></dt><dt><code>-mno-avx2=
</code></dt><dt><code>-maes</code></dt><dt><code>-mno-aes</code></dt><dt><c=
ode>-mpclmul</code></dt><dt><code>-mno-pclmul</code></dt><dt><code>-mfsgsba=
se</code></dt><dt><code>-mno-fsgsbase</code></dt><dt><code>-mrdrnd</code></=
dt><dt><code>-mno-rdrnd</code></dt><dt><code>-mf16c</code></dt><dt><code>-m=
no-f16c</code></dt><dt><code>-mfma</code></dt><dt><code>-mno-fma</code></dt=
><dt><code>-msse4a</code></dt><dt><code>-mno-sse4a</code></dt><dt><code>-mf=
ma4</code></dt><dt><code>-mno-fma4</code></dt><dt><code>-mxop</code></dt><d=
t><code>-mno-xop</code></dt><dt><code>-mlwp</code></dt><dt><code>-mno-lwp</=
code></dt><dt><code>-m3dnow</code></dt><dt><code>-mno-3dnow</code></dt><dt>=
<code>-mpopcnt</code></dt><dt><code>-mno-popcnt</code></dt><dt><code>-mabm<=
/code></dt><dt><code>-mno-abm</code></dt><dt><code>-mbmi</code></dt><dt><co=
de>-mbmi2</code></dt><dt><code>-mno-bmi</code></dt><dt><code>-mno-bmi2</cod=
e></dt><dt><code>-mlzcnt</code></dt><dt><code>-mno-lzcnt</code></dt><dt><co=
de>-mrtm</code></dt><dt><code>-mtbm</code></dt><dt><code>-mno-tbm</code></d=
t><dd><a name=3D"index-mmmx-1466"></a><a name=3D"index-mno_002dmmx-1467"></=
a><a name=3D"index-msse-1468"></a><a name=3D"index-mno_002dsse-1469"></a><a=
 name=3D"index-m3dnow-1470"></a><a name=3D"index-mno_002d3dnow-1471"></a>Th=
ese switches enable or disable the use of instructions in the MMX, SSE,
SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, F16C,
FMA, SSE4A, FMA4, XOP, LWP, ABM, BMI, BMI2, LZCNT, RTM or 3DNow!=20
extended instruction sets.=20
These extensions are also available as built-in functions: see
<a href=3D"X86-Built_002din-Functions.html#X86-Built_002din-Functions">X86 =
Built-in Functions</a>, for details of the functions enabled and
disabled by these switches.

     <p>To generate SSE/SSE2 instructions automatically from floating-point
code (as opposed to 387 instructions), see <samp><span class=3D"option">-mf=
pmath=3Dsse</span></samp>.

     </p><p>GCC depresses SSEx instructions when <samp><span class=3D"optio=
n">-mavx</span></samp> is used. Instead, it
generates new AVX instructions or AVX equivalence for all SSEx instructions
when needed.

     </p><p>These options enable GCC to use these extended instructions in
generated code, even without <samp><span class=3D"option">-mfpmath=3Dsse</s=
pan></samp>.  Applications that
perform run-time CPU detection must compile separate files for each
supported architecture, using the appropriate flags.  In particular,
the file containing the CPU detection code should be compiled without
these options.

     <br></p></dd><dt><code>-mcld</code></dt><dd><a name=3D"index-mcld-1472=
"></a>This option instructs GCC to emit a <code>cld</code> instruction in t=
he prologue
of functions that use string instructions.  String instructions depend on
the DF flag to select between autoincrement or autodecrement mode.  While t=
he
ABI specifies the DF flag to be cleared on function entry, some operating
systems violate this specification by not clearing the DF flag in their
exception dispatchers.  The exception handler can be invoked with the DF fl=
ag
set, which leads to wrong direction mode when string instructions are used.=
=20
This option can be enabled by default on 32-bit x86 targets by configuring
GCC with the <samp><span class=3D"option">--enable-cld</span></samp> config=
ure option.  Generation of <code>cld</code>
instructions can be suppressed with the <samp><span class=3D"option">-mno-c=
ld</span></samp> compiler option
in this case.

     <br></dd><dt><code>-mvzeroupper</code></dt><dd><a name=3D"index-mvzero=
upper-1473"></a>This option instructs GCC to emit a <code>vzeroupper</code>=
 instruction
before a transfer of control flow out of the function to minimize
the AVX to SSE transition penalty as well as remove unnecessary <code>zerou=
pper</code>
intrinsics.

     <br></dd><dt><code>-mprefer-avx128</code></dt><dd><a name=3D"index-mpr=
efer_002davx128-1474"></a>This option instructs GCC to use 128-bit AVX inst=
ructions instead of
256-bit AVX instructions in the auto-vectorizer.

     <br></dd><dt><code>-mcx16</code></dt><dd><a name=3D"index-mcx16-1475">=
</a>This option enables GCC to generate <code>CMPXCHG16B</code> instruction=
s.=20
<code>CMPXCHG16B</code> allows for atomic operations on 128-bit double quad=
word
(or oword) data types.=20
This is useful for high-resolution counters that can be updated
by multiple processors (or cores).  This instruction is generated as part of
atomic built-in functions: see <a href=3D"_005f_005fsync-Builtins.html#g_t_=
005f_005fsync-Builtins">__sync Builtins</a> or
<a href=3D"_005f_005fatomic-Builtins.html#g_t_005f_005fatomic-Builtins">__a=
tomic Builtins</a> for details.

     <br></dd><dt><code>-msahf</code></dt><dd><a name=3D"index-msahf-1476">=
</a>This option enables generation of <code>SAHF</code> instructions in 64-=
bit code.=20
Early Intel Pentium 4 CPUs with Intel 64 support,
prior to the introduction of Pentium 4 G1 step in December 2005,
lacked the <code>LAHF</code> and <code>SAHF</code> instructions
which were supported by AMD64.=20
These are load and store instructions, respectively, for certain status fla=
gs.=20
In 64-bit mode, the <code>SAHF</code> instruction is used to optimize <code=
>fmod</code>,
<code>drem</code>, and <code>remainder</code> built-in functions;
see <a href=3D"Other-Builtins.html#Other-Builtins">Other Builtins</a> for d=
etails.

     <br></dd><dt><code>-mmovbe</code></dt><dd><a name=3D"index-mmovbe-1477=
"></a>This option enables use of the <code>movbe</code> instruction to impl=
ement
<code>__builtin_bswap32</code> and <code>__builtin_bswap64</code>.

     <br></dd><dt><code>-mcrc32</code></dt><dd><a name=3D"index-mcrc32-1478=
"></a>This option enables built-in functions <code>__builtin_ia32_crc32qi</=
code>,
<code>__builtin_ia32_crc32hi</code>, <code>__builtin_ia32_crc32si</code> and
<code>__builtin_ia32_crc32di</code> to generate the <code>crc32</code> mach=
ine instruction.

     <br></dd><dt><code>-mrecip</code></dt><dd><a name=3D"index-mrecip-1479=
"></a>This option enables use of <code>RCPSS</code> and <code>RSQRTSS</code=
> instructions
(and their vectorized variants <code>RCPPS</code> and <code>RSQRTPS</code>)
with an additional Newton-Raphson step
to increase precision instead of <code>DIVSS</code> and <code>SQRTSS</code>
(and their vectorized
variants) for single-precision floating-point arguments.  These instructions
are generated only when <samp><span class=3D"option">-funsafe-math-optimiza=
tions</span></samp> is enabled
together with <samp><span class=3D"option">-finite-math-only</span></samp> =
and <samp><span class=3D"option">-fno-trapping-math</span></samp>.=20
Note that while the throughput of the sequence is higher than the throughput
of the non-reciprocal instruction, the precision of the sequence can be
decreased by up to 2 ulp (i.e. the inverse of 1.0 equals 0.99999994).

     <p>Note that GCC implements <code>1.0f/sqrtf(</code><var>x</var><code>=
)</code> in terms of <code>RSQRTSS</code>
(or <code>RSQRTPS</code>) already with <samp><span class=3D"option">-ffast-=
math</span></samp> (or the above option
combination), and doesn&#x27;t need <samp><span class=3D"option">-mrecip</s=
pan></samp>.

     </p><p>Also note that GCC emits the above sequence with additional New=
ton-Raphson step
for vectorized single-float division and vectorized <code>sqrtf(</code><var=
>x</var><code>)</code>
already with <samp><span class=3D"option">-ffast-math</span></samp> (or the=
 above option combination), and
doesn&#x27;t need <samp><span class=3D"option">-mrecip</span></samp>.

     <br></p></dd><dt><code>-mrecip=3D</code><var>opt</var></dt><dd><a name=
=3D"index-mrecip_003dopt-1480"></a>This option controls which reciprocal es=
timate instructions
may be used.  <var>opt</var> is a comma-separated list of options, which may
be preceded by a =E2=80=98<samp><span class=3D"samp">!</span></samp>=E2=80=
=99 to invert the option:

          <dl>
<dt>=E2=80=98<samp><span class=3D"samp">all</span></samp>=E2=80=99</dt><dd>=
Enable all estimate instructions.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">default</span></=
samp>=E2=80=99</dt><dd>Enable the default instructions, equivalent to <samp=
><span class=3D"option">-mrecip</span></samp>.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">none</span></sam=
p>=E2=80=99</dt><dd>Disable all estimate instructions, equivalent to <samp>=
<span class=3D"option">-mno-recip</span></samp>.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">div</span></samp=
>=E2=80=99</dt><dd>Enable the approximation for scalar division.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">vec-div</span></=
samp>=E2=80=99</dt><dd>Enable the approximation for vectorized division.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">sqrt</span></sam=
p>=E2=80=99</dt><dd>Enable the approximation for scalar square root.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">vec-sqrt</span><=
/samp>=E2=80=99</dt><dd>Enable the approximation for vectorized square root=
.=20
</dd></dl>

     <p>So, for example, <samp><span class=3D"option">-mrecip=3Dall,!sqrt</=
span></samp> enables
all of the reciprocal approximations, except for square root.

     <br></p></dd><dt><code>-mveclibabi=3D</code><var>type</var></dt><dd><a=
 name=3D"index-mveclibabi-1481"></a>Specifies the ABI type to use for vecto=
rizing intrinsics using an
external library.  Supported values for <var>type</var> are =E2=80=98<samp>=
<span class=3D"samp">svml</span></samp>=E2=80=99
for the Intel short
vector math library and =E2=80=98<samp><span class=3D"samp">acml</span></sa=
mp>=E2=80=99 for the AMD math core library.=20
To use this option, both <samp><span class=3D"option">-ftree-vectorize</spa=
n></samp> and
<samp><span class=3D"option">-funsafe-math-optimizations</span></samp> have=
 to be enabled, and an SVML or ACML
ABI-compatible library must be specified at link time.

     <p>GCC currently emits calls to <code>vmldExp2</code>,
<code>vmldLn2</code>, <code>vmldLog102</code>, <code>vmldLog102</code>, <co=
de>vmldPow2</code>,
<code>vmldTanh2</code>, <code>vmldTan2</code>, <code>vmldAtan2</code>, <cod=
e>vmldAtanh2</code>,
<code>vmldCbrt2</code>, <code>vmldSinh2</code>, <code>vmldSin2</code>, <cod=
e>vmldAsinh2</code>,
<code>vmldAsin2</code>, <code>vmldCosh2</code>, <code>vmldCos2</code>, <cod=
e>vmldAcosh2</code>,
<code>vmldAcos2</code>, <code>vmlsExp4</code>, <code>vmlsLn4</code>, <code>=
vmlsLog104</code>,
<code>vmlsLog104</code>, <code>vmlsPow4</code>, <code>vmlsTanh4</code>, <co=
de>vmlsTan4</code>,
<code>vmlsAtan4</code>, <code>vmlsAtanh4</code>, <code>vmlsCbrt4</code>, <c=
ode>vmlsSinh4</code>,
<code>vmlsSin4</code>, <code>vmlsAsinh4</code>, <code>vmlsAsin4</code>, <co=
de>vmlsCosh4</code>,
<code>vmlsCos4</code>, <code>vmlsAcosh4</code> and <code>vmlsAcos4</code> f=
or corresponding
function type when <samp><span class=3D"option">-mveclibabi=3Dsvml</span></=
samp> is used, and <code>__vrd2_sin</code>,
<code>__vrd2_cos</code>, <code>__vrd2_exp</code>, <code>__vrd2_log</code>, =
<code>__vrd2_log2</code>,
<code>__vrd2_log10</code>, <code>__vrs4_sinf</code>, <code>__vrs4_cosf</cod=
e>,
<code>__vrs4_expf</code>, <code>__vrs4_logf</code>, <code>__vrs4_log2f</cod=
e>,
<code>__vrs4_log10f</code> and <code>__vrs4_powf</code> for the correspondi=
ng function type
when <samp><span class=3D"option">-mveclibabi=3Dacml</span></samp> is used.

     <br></p></dd><dt><code>-mabi=3D</code><var>name</var></dt><dd><a name=
=3D"index-mabi-1482"></a>Generate code for the specified calling convention=
.  Permissible values
are =E2=80=98<samp><span class=3D"samp">sysv</span></samp>=E2=80=99 for the=
 ABI used on GNU/Linux and other systems, and
=E2=80=98<samp><span class=3D"samp">ms</span></samp>=E2=80=99 for the Micro=
soft ABI.  The default is to use the Microsoft
ABI when targeting Microsoft Windows and the SysV ABI on all other systems.=
=20
You can control this behavior for a specific function by
using the function attribute =E2=80=98<samp><span class=3D"samp">ms_abi</sp=
an></samp>=E2=80=99/=E2=80=98<samp><span class=3D"samp">sysv_abi</span></sa=
mp>=E2=80=99.=20
See <a href=3D"Function-Attributes.html#Function-Attributes">Function Attri=
butes</a>.

     <br></dd><dt><code>-mtls-dialect=3D</code><var>type</var></dt><dd><a n=
ame=3D"index-mtls_002ddialect-1483"></a>Generate code to access thread-loca=
l storage using the =E2=80=98<samp><span class=3D"samp">gnu</span></samp>=
=E2=80=99 or
=E2=80=98<samp><span class=3D"samp">gnu2</span></samp>=E2=80=99 conventions=
.  =E2=80=98<samp><span class=3D"samp">gnu</span></samp>=E2=80=99 is the co=
nservative default;
=E2=80=98<samp><span class=3D"samp">gnu2</span></samp>=E2=80=99 is more eff=
icient, but it may add compile- and run-time
requirements that cannot be satisfied on all systems.

     <br></dd><dt><code>-mpush-args</code></dt><dt><code>-mno-push-args</co=
de></dt><dd><a name=3D"index-mpush_002dargs-1484"></a><a name=3D"index-mno_=
002dpush_002dargs-1485"></a>Use PUSH operations to store outgoing parameter=
s.  This method is shorter
and usually equally fast as method using SUB/MOV operations and is enabled
by default.  In some cases disabling it may improve performance because of
improved scheduling and reduced dependencies.

     <br></dd><dt><code>-maccumulate-outgoing-args</code></dt><dd><a name=
=3D"index-maccumulate_002doutgoing_002dargs-1486"></a>If enabled, the maxim=
um amount of space required for outgoing arguments is
computed in the function prologue.  This is faster on most modern CPUs
because of reduced dependencies, improved scheduling and reduced stack usage
when the preferred stack boundary is not equal to 2.  The drawback is a not=
able
increase in code size.  This switch implies <samp><span class=3D"option">-m=
no-push-args</span></samp>.

     <br></dd><dt><code>-mthreads</code></dt><dd><a name=3D"index-mthreads-=
1487"></a>Support thread-safe exception handling on MinGW.  Programs that r=
ely
on thread-safe exception handling must compile and link all code with the
<samp><span class=3D"option">-mthreads</span></samp> option.  When compilin=
g, <samp><span class=3D"option">-mthreads</span></samp> defines
<code>-D_MT</code>; when linking, it links in a special thread helper libra=
ry
<samp><span class=3D"option">-lmingwthrd</span></samp> which cleans up per-=
thread exception-handling data.

     <br></dd><dt><code>-mno-align-stringops</code></dt><dd><a name=3D"inde=
x-mno_002dalign_002dstringops-1488"></a>Do not align the destination of inl=
ined string operations.  This switch reduces
code size and improves performance in case the destination is already align=
ed,
but GCC doesn&#x27;t know about it.

     <br></dd><dt><code>-minline-all-stringops</code></dt><dd><a name=3D"in=
dex-minline_002dall_002dstringops-1489"></a>By default GCC inlines string o=
perations only when the destination is
known to be aligned to least a 4-byte boundary.=20
This enables more inlining and increases code
size, but may improve performance of code that depends on fast
<code>memcpy</code>, <code>strlen</code>,
and <code>memset</code> for short lengths.

     <br></dd><dt><code>-minline-stringops-dynamically</code></dt><dd><a na=
me=3D"index-minline_002dstringops_002ddynamically-1490"></a>For string oper=
ations of unknown size, use run-time checks with
inline code for small blocks and a library call for large blocks.

     <br></dd><dt><code>-mstringop-strategy=3D</code><var>alg</var></dt><dd=
><a name=3D"index-mstringop_002dstrategy_003d_0040var_007balg_007d-1491"></=
a>Override the internal decision heuristic for the particular algorithm to =
use
for inlining string operations.  The allowed values for <var>alg</var> are:

          <dl>
<dt>=E2=80=98<samp><span class=3D"samp">rep_byte</span></samp>=E2=80=99</dt=
><dt>=E2=80=98<samp><span class=3D"samp">rep_4byte</span></samp>=E2=80=99</=
dt><dt>=E2=80=98<samp><span class=3D"samp">rep_8byte</span></samp>=E2=80=99=
</dt><dd>Expand using i386 <code>rep</code> prefix of the specified size.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">byte_loop</span>=
</samp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">loop</span></s=
amp>=E2=80=99</dt><dt>=E2=80=98<samp><span class=3D"samp">unrolled_loop</sp=
an></samp>=E2=80=99</dt><dd>Expand into an inline loop.

          <br></dd><dt>=E2=80=98<samp><span class=3D"samp">libcall</span></=
samp>=E2=80=99</dt><dd>Always use a library call.=20
</dd></dl>

     <br></dd><dt><code>-momit-leaf-frame-pointer</code></dt><dd><a name=3D=
"index-momit_002dleaf_002dframe_002dpointer-1492"></a>Don&#x27;t keep the f=
rame pointer in a register for leaf functions.  This
avoids the instructions to save, set up, and restore frame pointers and
makes an extra register available in leaf functions.  The option
<samp><span class=3D"option">-fomit-leaf-frame-pointer</span></samp> remove=
s the frame pointer for leaf functions,
which might make debugging harder.

     <br></dd><dt><code>-mtls-direct-seg-refs</code></dt><dt><code>-mno-tls=
-direct-seg-refs</code></dt><dd><a name=3D"index-mtls_002ddirect_002dseg_00=
2drefs-1493"></a>Controls whether TLS variables may be accessed with offset=
s from the
TLS segment register (<code>%gs</code> for 32-bit, <code>%fs</code> for 64-=
bit),
or whether the thread base pointer must be added.  Whether or not this
is valid depends on the operating system, and whether it maps the
segment to cover the entire TLS area.

     <p>For systems that use the GNU C Library, the default is on.

     <br></p></dd><dt><code>-msse2avx</code></dt><dt><code>-mno-sse2avx</co=
de></dt><dd><a name=3D"index-msse2avx-1494"></a>Specify that the assembler =
should encode SSE instructions with VEX
prefix.  The option <samp><span class=3D"option">-mavx</span></samp> turns =
this on by default.

     <br></dd><dt><code>-mfentry</code></dt><dt><code>-mno-fentry</code></d=
t><dd><a name=3D"index-mfentry-1495"></a>If profiling is active (<samp><spa=
n class=3D"option">-pg</span></samp>), put the profiling
counter call before the prologue.=20
Note: On x86 architectures the attribute <code>ms_hook_prologue</code>
isn&#x27;t possible at the moment for <samp><span class=3D"option">-mfentry=
</span></samp> and <samp><span class=3D"option">-pg</span></samp>.

     <br></dd><dt><code>-m8bit-idiv</code></dt><dt><code>-mno-8bit-idiv</co=
de></dt><dd><a name=3D"index-g_t8bit_002didiv-1496"></a>On some processors,=
 like Intel Atom, 8-bit unsigned integer divide is
much faster than 32-bit/64-bit integer divide.  This option generates a
run-time check.  If both dividend and divisor are within range of 0
to 255, 8-bit unsigned integer divide is used instead of
32-bit/64-bit integer divide.

     <br></dd><dt><code>-mavx256-split-unaligned-load</code></dt><dt><code>=
-mavx256-split-unaligned-store</code></dt><dd><a name=3D"index-avx256_002ds=
plit_002dunaligned_002dload-1497"></a><a name=3D"index-avx256_002dsplit_002=
dunaligned_002dstore-1498"></a>Split 32-byte AVX unaligned load and store.

 </dd></dl>

 <p>These =E2=80=98<samp><span class=3D"samp">-m</span></samp>=E2=80=99 swi=
tches are supported in addition to the above
on x86-64 processors in 64-bit environments.

     </p><dl>
<dt><code>-m32</code></dt><dt><code>-m64</code></dt><dt><code>-mx32</code><=
/dt><dd><a name=3D"index-m32-1499"></a><a name=3D"index-m64-1500"></a><a na=
me=3D"index-mx32-1501"></a>Generate code for a 32-bit or 64-bit environment=
.=20
The <samp><span class=3D"option">-m32</span></samp> option sets <code>int</=
code>, <code>long</code>, and pointer types
to 32 bits, and
generates code that runs on any i386 system.

     <p>The <samp><span class=3D"option">-m64</span></samp> option sets <co=
de>int</code> to 32 bits and <code>long</code> and pointer
types to 64 bits, and generates code for the x86-64 architecture.=20
For Darwin only the <samp><span class=3D"option">-m64</span></samp> option =
also turns off the <samp><span class=3D"option">-fno-pic</span></samp>
and <samp><span class=3D"option">-mdynamic-no-pic</span></samp> options.

     </p><p>The <samp><span class=3D"option">-mx32</span></samp> option set=
s <code>int</code>, <code>long</code>, and pointer types
to 32 bits, and
generates code for the x86-64 architecture.

     <br></p></dd><dt><code>-mno-red-zone</code></dt><dd><a name=3D"index-m=
no_002dred_002dzone-1502"></a>Do not use a so-called =E2=80=9Cred zone=E2=
=80=9D for x86-64 code.  The red zone is mandated
by the x86-64 ABI; it is a 128-byte area beyond the location of the
stack pointer that is not modified by signal or interrupt handlers
and therefore can be used for temporary data without adjusting the stack
pointer.  The flag <samp><span class=3D"option">-mno-red-zone</span></samp>=
 disables this red zone.

     <br></dd><dt><code>-mcmodel=3Dsmall</code></dt><dd><a name=3D"index-mc=
model_003dsmall-1503"></a>Generate code for the small code model: the progr=
am and its symbols must
be linked in the lower 2 GB of the address space.  Pointers are 64 bits.=20
Programs can be statically or dynamically linked.  This is the default
code model.

     <br></dd><dt><code>-mcmodel=3Dkernel</code></dt><dd><a name=3D"index-m=
cmodel_003dkernel-1504"></a>Generate code for the kernel code model.  The k=
ernel runs in the
negative 2 GB of the address space.=20
This model has to be used for Linux kernel code.

     <br></dd><dt><code>-mcmodel=3Dmedium</code></dt><dd><a name=3D"index-m=
cmodel_003dmedium-1505"></a>Generate code for the medium model: the program=
 is linked in the lower 2
GB of the address space.  Small symbols are also placed there.  Symbols
with sizes larger than <samp><span class=3D"option">-mlarge-data-threshold<=
/span></samp> are put into
large data or BSS sections and can be located above 2GB.  Programs can
be statically or dynamically linked.

     <br></dd><dt><code>-mcmodel=3Dlarge</code></dt><dd><a name=3D"index-mc=
model_003dlarge-1506"></a>Generate code for the large model.  This model ma=
kes no assumptions
about addresses and sizes of sections.

     <br></dd><dt><code>-maddress-mode=3Dlong</code></dt><dd><a name=3D"ind=
ex-maddress_002dmode_003dlong-1507"></a>Generate code for long address mode=
.  This is only supported for 64-bit
and x32 environments.  It is the default address mode for 64-bit
environments.

     <br></dd><dt><code>-maddress-mode=3Dshort</code></dt><dd><a name=3D"in=
dex-maddress_002dmode_003dshort-1508"></a>Generate code for short address m=
ode.  This is only supported for 32-bit
and x32 environments.  It is the default address mode for 32-bit and
x32 environments.=20
</dd></dl>

=20

</body></html>
------=_Part_0528870A_8F38FF28.1592F19466B--
