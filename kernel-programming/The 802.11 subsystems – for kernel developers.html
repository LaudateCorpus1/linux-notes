<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>The 802.11 subsystems – for kernel developers</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></head><body><div class="set" title="The 802.11 subsystems – for kernel developers" xml:lang="en" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="idp853632"></a>The 802.11 subsystems – for kernel developers</h1></div><div><h2 class="subtitle">
      Explaining wireless 802.11 networking in the Linux kernel
    </h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Berg</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:johannes@sipsolutions.net">johannes@sipsolutions.net</a>&gt;</code></p></div></div></div></div></div><div><p class="copyright">Copyright © 2007-2009 Johannes Berg</p></div><div><div class="legalnotice" title="Legal Notice"><a id="idp216688"></a><p>
        This documentation is free software; you can redistribute
        it and/or modify it under the terms of the GNU General Public
        License version 2 as published by the Free Software Foundation.
      </p><p>
        This documentation is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        See the GNU General Public License for more details.
      </p><p>
        You should have received a copy of the GNU General Public
        License along with this documentation; if not, write to the Free
        Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
        MA 02111-1307 USA
      </p><p>
        For more details see the file COPYING in the source
        distribution of Linux.
      </p></div></div><div><div class="abstract" title="Abstract"><p class="title"><strong>Abstract</strong></p><p>
        These books attempt to give a description of the
        various subsystems that play a role in 802.11 wireless
        networking in Linux. Since these books are for kernel
        developers they attempts to document the structures
        and functions used in the kernel as well as giving a
        higher-level overview.
      </p><p>
	The reader is expected to be familiar with the 802.11
	standard as published by the IEEE in 802.11-2007 (or
	possibly later versions). References to this standard
	will be given as "802.11-2007 8.1.5".
      </p></div></div></div><hr></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="book"><a href="#cfg80211-developers-guide">The cfg80211 subsystem</a></span></dt><dd><dl><dt><span class="chapter"><a href="#idp3835104">1. Device registration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-band"><span>enum ieee80211_band</span></a></span><span class="refpurpose"> — 
  supported frequency bands
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-channel-flags"><span>enum ieee80211_channel_flags</span></a></span><span class="refpurpose"> — 
  channel flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-channel"><span>struct ieee80211_channel</span></a></span><span class="refpurpose"> — 
  channel definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-rate-flags"><span>enum ieee80211_rate_flags</span></a></span><span class="refpurpose"> — 
  rate flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-rate"><span>struct ieee80211_rate</span></a></span><span class="refpurpose"> — 
  bitrate definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-sta-ht-cap"><span>struct ieee80211_sta_ht_cap</span></a></span><span class="refpurpose"> — 
  STA's HT capabilities
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-supported-band"><span>struct ieee80211_supported_band</span></a></span><span class="refpurpose"> — 
  frequency band definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-cfg80211-signal-type"><span>enum cfg80211_signal_type</span></a></span><span class="refpurpose"> — 
  signal type
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-wiphy-params-flags"><span>enum wiphy_params_flags</span></a></span><span class="refpurpose"> — 
  set_wiphy_params bitfield values
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-wiphy-flags"><span>enum wiphy_flags</span></a></span><span class="refpurpose"> — 
  wiphy capability flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-wiphy"><span>struct wiphy</span></a></span><span class="refpurpose"> — 
  wireless hardware description
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-wireless-dev"><span>struct wireless_dev</span></a></span><span class="refpurpose"> — 
  wireless device state
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-new"><span>wiphy_new</span></a></span><span class="refpurpose"> — 
  create a new wiphy for use with cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-register"><span>wiphy_register</span></a></span><span class="refpurpose"> — 
  register a wiphy with cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-unregister"><span>wiphy_unregister</span></a></span><span class="refpurpose"> — 
  deregister a wiphy from cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-free"><span>wiphy_free</span></a></span><span class="refpurpose"> — 
  free wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-name"><span>wiphy_name</span></a></span><span class="refpurpose"> — 
  get wiphy name
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-dev"><span>wiphy_dev</span></a></span><span class="refpurpose"> — 
  get wiphy dev pointer
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-priv"><span>wiphy_priv</span></a></span><span class="refpurpose"> — 
  return priv from wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-priv-to-wiphy"><span>priv_to_wiphy</span></a></span><span class="refpurpose"> — 
  return the wiphy containing the priv
 </span></dt><dt><span class="refentrytitle"><a href="#API-set-wiphy-dev"><span>set_wiphy_dev</span></a></span><span class="refpurpose"> — 
  set device pointer for wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-wdev-priv"><span>wdev_priv</span></a></span><span class="refpurpose"> — 
  return wiphy priv from wireless_dev
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp5286464">2. Actions and configuration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ops"><span>struct cfg80211_ops</span></a></span><span class="refpurpose"> — 
  backend description for wireless configuration
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-vif-params"><span>struct vif_params</span></a></span><span class="refpurpose"> — 
  describes virtual interface parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-key-params"><span>struct key_params</span></a></span><span class="refpurpose"> — 
  key information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-survey-info-flags"><span>enum survey_info_flags</span></a></span><span class="refpurpose"> — 
  survey information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-survey-info"><span>struct survey_info</span></a></span><span class="refpurpose"> — 
  channel survey response
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-beacon-data"><span>struct cfg80211_beacon_data</span></a></span><span class="refpurpose"> — 
  beacon data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ap-settings"><span>struct cfg80211_ap_settings</span></a></span><span class="refpurpose"> — 
  AP configuration
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-station-parameters"><span>struct station_parameters</span></a></span><span class="refpurpose"> — 
  station parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-station-info-flags"><span>enum station_info_flags</span></a></span><span class="refpurpose"> — 
  station information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-rate-info-flags"><span>enum rate_info_flags</span></a></span><span class="refpurpose"> — 
  bitrate info flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-rate-info"><span>struct rate_info</span></a></span><span class="refpurpose"> — 
  bitrate information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-station-info"><span>struct station_info</span></a></span><span class="refpurpose"> — 
  station information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-monitor-flags"><span>enum monitor_flags</span></a></span><span class="refpurpose"> — 
  monitor flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-mpath-info-flags"><span>enum mpath_info_flags</span></a></span><span class="refpurpose"> — 
  mesh path information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-mpath-info"><span>struct mpath_info</span></a></span><span class="refpurpose"> — 
  mesh path information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bss-parameters"><span>struct bss_parameters</span></a></span><span class="refpurpose"> — 
  BSS parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-txq-params"><span>struct ieee80211_txq_params</span></a></span><span class="refpurpose"> — 
  TX queue parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-crypto-settings"><span>struct cfg80211_crypto_settings</span></a></span><span class="refpurpose"> — 
  Crypto settings
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-auth-request"><span>struct cfg80211_auth_request</span></a></span><span class="refpurpose"> — 
  Authentication request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-assoc-request"><span>struct cfg80211_assoc_request</span></a></span><span class="refpurpose"> — 
  (Re)Association request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-deauth-request"><span>struct cfg80211_deauth_request</span></a></span><span class="refpurpose"> — 
  Deauthentication request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-disassoc-request"><span>struct cfg80211_disassoc_request</span></a></span><span class="refpurpose"> — 
  Disassociation request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ibss-params"><span>struct cfg80211_ibss_params</span></a></span><span class="refpurpose"> — 
  IBSS parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-connect-params"><span>struct cfg80211_connect_params</span></a></span><span class="refpurpose"> — 
  Connection parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-pmksa"><span>struct cfg80211_pmksa</span></a></span><span class="refpurpose"> — 
  PMK Security Association
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-mlme-mgmt"><span>cfg80211_rx_mlme_mgmt</span></a></span><span class="refpurpose"> — 
  notification of processed MLME management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-auth-timeout"><span>cfg80211_auth_timeout</span></a></span><span class="refpurpose"> — 
  notification of timed out authentication
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-assoc-resp"><span>cfg80211_rx_assoc_resp</span></a></span><span class="refpurpose"> — 
  notification of processed association response
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-assoc-timeout"><span>cfg80211_assoc_timeout</span></a></span><span class="refpurpose"> — 
  notification of timed out association
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-tx-mlme-mgmt"><span>cfg80211_tx_mlme_mgmt</span></a></span><span class="refpurpose"> — 
  notification of transmitted deauth/disassoc frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-ibss-joined"><span>cfg80211_ibss_joined</span></a></span><span class="refpurpose"> — 
  notify cfg80211 that device joined an IBSS
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-connect-result"><span>cfg80211_connect_result</span></a></span><span class="refpurpose"> — 
  notify cfg80211 of connection result
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-roamed"><span>cfg80211_roamed</span></a></span><span class="refpurpose"> — 
  notify cfg80211 of roaming
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-disconnected"><span>cfg80211_disconnected</span></a></span><span class="refpurpose"> — 
  notify cfg80211 that connection was dropped
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-ready-on-channel"><span>cfg80211_ready_on_channel</span></a></span><span class="refpurpose"> — 
  notification of remain_on_channel start
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-remain-on-channel-expired"><span>cfg80211_remain_on_channel_expired</span></a></span><span class="refpurpose"> — 
  remain_on_channel duration expired
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-new-sta"><span>cfg80211_new_sta</span></a></span><span class="refpurpose"> — 
  notify userspace about station
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-mgmt"><span>cfg80211_rx_mgmt</span></a></span><span class="refpurpose"> — 
  notification of received, unprocessed management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-mgmt-tx-status"><span>cfg80211_mgmt_tx_status</span></a></span><span class="refpurpose"> — 
  notification of TX status for management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-cqm-rssi-notify"><span>cfg80211_cqm_rssi_notify</span></a></span><span class="refpurpose"> — 
  connection quality monitoring rssi event
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-cqm-pktloss-notify"><span>cfg80211_cqm_pktloss_notify</span></a></span><span class="refpurpose"> — 
  notify userspace about packetloss to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-michael-mic-failure"><span>cfg80211_michael_mic_failure</span></a></span><span class="refpurpose"> — 
  notification of Michael MIC failure (TKIP)
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6458464">3. Scanning and BSS list handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ssid"><span>struct cfg80211_ssid</span></a></span><span class="refpurpose"> — 
  SSID description
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-scan-request"><span>struct cfg80211_scan_request</span></a></span><span class="refpurpose"> — 
  scan request description
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-scan-done"><span>cfg80211_scan_done</span></a></span><span class="refpurpose"> — 
  notify that scan finished
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-bss"><span>struct cfg80211_bss</span></a></span><span class="refpurpose"> — 
  BSS description
 </span></dt><dt><span class="refentrytitle"><a href="#idp6542112">
   /home/landley/linux/linux//include/net/cfg80211.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#idp6546128">
   /home/landley/linux/linux//include/net/cfg80211.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-unlink-bss"><span>cfg80211_unlink_bss</span></a></span><span class="refpurpose"> — 
  unlink BSS from internal data structures
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-find-ie"><span>cfg80211_find_ie</span></a></span><span class="refpurpose"> — 
  find information element in data
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-bss-get-ie"><span>ieee80211_bss_get_ie</span></a></span><span class="refpurpose"> — 
  find IE with given ID
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6603936">4. Utility functions</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-channel-to-frequency"><span>ieee80211_channel_to_frequency</span></a></span><span class="refpurpose"> — 
  convert channel number to frequency
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-frequency-to-channel"><span>ieee80211_frequency_to_channel</span></a></span><span class="refpurpose"> — 
  convert frequency to channel number
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-channel"><span>ieee80211_get_channel</span></a></span><span class="refpurpose"> — 
  get channel struct from wiphy for specified frequency
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-response-rate"><span>ieee80211_get_response_rate</span></a></span><span class="refpurpose"> — 
  get basic rate for a given rate
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-hdrlen"><span>ieee80211_hdrlen</span></a></span><span class="refpurpose"> — 
  get header length in bytes from frame control
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-hdrlen-from-skb"><span>ieee80211_get_hdrlen_from_skb</span></a></span><span class="refpurpose"> — 
  get header length from data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-radiotap-iterator"><span>struct ieee80211_radiotap_iterator</span></a></span><span class="refpurpose"> — 
  tracks walk thru present radiotap args
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6726736">5. Data path helpers</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-data-to-8023"><span>ieee80211_data_to_8023</span></a></span><span class="refpurpose"> — 
  convert an 802.11 data frame to 802.3
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-data-from-8023"><span>ieee80211_data_from_8023</span></a></span><span class="refpurpose"> — 
  convert an 802.3 frame to 802.11
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-amsdu-to-8023s"><span>ieee80211_amsdu_to_8023s</span></a></span><span class="refpurpose"> — 
  decode an IEEE 802.11n A-MSDU frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-classify8021d"><span>cfg80211_classify8021d</span></a></span><span class="refpurpose"> — 
  determine the 802.1p/1d tag for a data frame
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6816576">6. Regulatory enforcement infrastructure</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-regulatory-hint"><span>regulatory_hint</span></a></span><span class="refpurpose"> — 
  driver hint to the wireless core a regulatory domain
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-apply-custom-regulatory"><span>wiphy_apply_custom_regulatory</span></a></span><span class="refpurpose"> — 
  apply a custom driver regulatory domain
 </span></dt><dt><span class="refentrytitle"><a href="#API-freq-reg-info"><span>freq_reg_info</span></a></span><span class="refpurpose"> — 
  get regulatory information for the given frequency
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6878256">7. RFkill integration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-set-hw-state"><span>wiphy_rfkill_set_hw_state</span></a></span><span class="refpurpose"> — 
  notify cfg80211 about hw block state
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-start-polling"><span>wiphy_rfkill_start_polling</span></a></span><span class="refpurpose"> — 
  start polling rfkill
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-stop-polling"><span>wiphy_rfkill_stop_polling</span></a></span><span class="refpurpose"> — 
  stop polling rfkill
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6921040">8. Test mode</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-alloc-reply-skb"><span>cfg80211_testmode_alloc_reply_skb</span></a></span><span class="refpurpose"> — 
  allocate testmode reply
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-reply"><span>cfg80211_testmode_reply</span></a></span><span class="refpurpose"> — 
  send the reply skb
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-alloc-event-skb"><span>cfg80211_testmode_alloc_event_skb</span></a></span><span class="refpurpose"> — 
  allocate testmode event
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-event"><span>cfg80211_testmode_event</span></a></span><span class="refpurpose"> — 
  send the event
 </span></dt></dl></dd></dl></dd><dt><span class="book"><a href="#mac80211-developers-guide">The mac80211 subsystem</a></span></dt><dd><dl><dt><span class="part"><a href="#idp7010160">I. The basic mac80211 driver interface</a></span></dt><dd><dl><dt><span class="chapter"><a href="#basics">1. Basic hardware handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-hw"><span>struct ieee80211_hw</span></a></span><span class="refpurpose"> — 
  hardware information and state
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-hw-flags"><span>enum ieee80211_hw_flags</span></a></span><span class="refpurpose"> — 
  hardware flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-DEV"><span>SET_IEEE80211_DEV</span></a></span><span class="refpurpose"> — 
  set device for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-PERM-ADDR"><span>SET_IEEE80211_PERM_ADDR</span></a></span><span class="refpurpose"> — 
  set the permanent MAC address for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-ops"><span>struct ieee80211_ops</span></a></span><span class="refpurpose"> — 
  callbacks from mac80211 to the driver
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-alloc-hw"><span>ieee80211_alloc_hw</span></a></span><span class="refpurpose"> — 
  Allocate a new hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-register-hw"><span>ieee80211_register_hw</span></a></span><span class="refpurpose"> — 
  Register hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-unregister-hw"><span>ieee80211_unregister_hw</span></a></span><span class="refpurpose"> — 
  Unregister a hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-free-hw"><span>ieee80211_free_hw</span></a></span><span class="refpurpose"> — 
  free hardware descriptor
 </span></dt></dl></dd><dt><span class="chapter"><a href="#phy-handling">2. PHY configuration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-conf"><span>struct ieee80211_conf</span></a></span><span class="refpurpose"> — 
  configuration of the device
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-conf-flags"><span>enum ieee80211_conf_flags</span></a></span><span class="refpurpose"> — 
  configuration flags
 </span></dt></dl></dd><dt><span class="chapter"><a href="#iface-handling">3. Virtual interfaces</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-vif"><span>struct ieee80211_vif</span></a></span><span class="refpurpose"> — 
  per-interface data
 </span></dt></dl></dd><dt><span class="chapter"><a href="#rx-tx">4. Receive and transmit processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp7493904">what should be here</a></span></dt><dt><span class="sect1"><a href="#idp7495616">Frame format</a></span></dt><dt><span class="sect1"><a href="#idp7499040">Packet alignment</a></span></dt><dt><span class="sect1"><a href="#idp7502544">Calling into mac80211 from interrupts</a></span></dt><dt><span class="sect1"><a href="#idp7506912">functions/definitions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">5. Frame filtering</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-filter-flags"><span>enum ieee80211_filter_flags</span></a></span><span class="refpurpose"> — 
  hardware filter flags
 </span></dt></dl></dd><dt><span class="chapter"><a href="#workqueue">6. The mac80211 workqueue</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-work"><span>ieee80211_queue_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-delayed-work"><span>ieee80211_queue_delayed_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#advanced">II. Advanced driver interface</a></span></dt><dd><dl><dt><span class="chapter"><a href="#led-support">7. LED support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tx-led-name"><span>ieee80211_get_tx_led_name</span></a></span><span class="refpurpose"> — 
  get name of TX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-rx-led-name"><span>ieee80211_get_rx_led_name</span></a></span><span class="refpurpose"> — 
  get name of RX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-assoc-led-name"><span>ieee80211_get_assoc_led_name</span></a></span><span class="refpurpose"> — 
  get name of association LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-radio-led-name"><span>ieee80211_get_radio_led_name</span></a></span><span class="refpurpose"> — 
  get name of radio LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tpt-blink"><span>struct ieee80211_tpt_blink</span></a></span><span class="refpurpose"> — 
  throughput blink description
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-tpt-led-trigger-flags"><span>enum ieee80211_tpt_led_trigger_flags</span></a></span><span class="refpurpose"> — 
  throughput trigger flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-create-tpt-led-trigger"><span>ieee80211_create_tpt_led_trigger</span></a></span><span class="refpurpose"> — 
  create throughput LED trigger
 </span></dt></dl></dd><dt><span class="chapter"><a href="#hardware-crypto-offload">8. Hardware crypto acceleration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-set-key-cmd"><span>enum set_key_cmd</span></a></span><span class="refpurpose"> — 
  key command
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-key-conf"><span>struct ieee80211_key_conf</span></a></span><span class="refpurpose"> — 
  key information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-key-flags"><span>enum ieee80211_key_flags</span></a></span><span class="refpurpose"> — 
  key flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k"><span>ieee80211_get_tkip_p1k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k-iv"><span>ieee80211_get_tkip_p1k_iv</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key for IV32
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p2k"><span>ieee80211_get_tkip_p2k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 2 key
 </span></dt></dl></dd><dt><span class="chapter"><a href="#powersave">9. Powersave support</a></span></dt><dt><span class="chapter"><a href="#beacon-filter">10. Beacon filter support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-loss"><span>ieee80211_beacon_loss</span></a></span><span class="refpurpose"> — 
  inform hardware does not receive beacons
 </span></dt></dl></dd><dt><span class="chapter"><a href="#qos">11. Multiple queues and QoS support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-queue-params"><span>struct ieee80211_tx_queue_params</span></a></span><span class="refpurpose"> — 
  transmit queue configuration
 </span></dt></dl></dd><dt><span class="chapter"><a href="#AP">12. Access point mode support</a></span></dt><dd><dl><dt><span class="section"><a href="#ps-client">support for powersaving clients</a></span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-buffered-bc"><span>ieee80211_get_buffered_bc</span></a></span><span class="refpurpose"> — 
  accessing buffered broadcast and multicast frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-get"><span>ieee80211_beacon_get</span></a></span><span class="refpurpose"> — 
  beacon generation function
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-eosp"><span>ieee80211_sta_eosp</span></a></span><span class="refpurpose"> — 
  notify mac80211 about end of SP
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-frame-release-type"><span>enum ieee80211_frame_release_type</span></a></span><span class="refpurpose"> — 
  frame release reason
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition"><span>ieee80211_sta_ps_transition</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition-ni"><span>ieee80211_sta_ps_transition_ni</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta (in process context)
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-set-buffered"><span>ieee80211_sta_set_buffered</span></a></span><span class="refpurpose"> — 
  inform mac80211 about driver-buffered frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-block-awake"><span>ieee80211_sta_block_awake</span></a></span><span class="refpurpose"> — 
  block station from waking up
 </span></dt></dl></dd><dt><span class="chapter"><a href="#multi-iface">13. Supporting multiple virtual interfaces</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces"><span>ieee80211_iterate_active_interfaces</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces-atomic"><span>ieee80211_iterate_active_interfaces_atomic</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt></dl></dd><dt><span class="chapter"><a href="#station-handling">14. Station handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-sta"><span>struct ieee80211_sta</span></a></span><span class="refpurpose"> — 
  station table entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-sta-notify-cmd"><span>enum sta_notify_cmd</span></a></span><span class="refpurpose"> — 
  sta notify command
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta"><span>ieee80211_find_sta</span></a></span><span class="refpurpose"> — 
  find a station
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta-by-ifaddr"><span>ieee80211_find_sta_by_ifaddr</span></a></span><span class="refpurpose"> — 
  find a station on hardware
 </span></dt></dl></dd><dt><span class="chapter"><a href="#hardware-scan-offload">15. Hardware scan offload</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-scan-completed"><span>ieee80211_scan_completed</span></a></span><span class="refpurpose"> — 
  completed hardware scan
 </span></dt></dl></dd><dt><span class="chapter"><a href="#aggregation">16. Aggregation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp8840448">TX A-MPDU aggregation</a></span></dt><dt><span class="sect1"><a href="#idp8851200">RX A-MPDU aggregation</a></span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-ampdu-mlme-action"><span>enum ieee80211_ampdu_mlme_action</span></a></span><span class="refpurpose"> — 
  A-MPDU actions
 </span></dt></dl></dd><dt><span class="chapter"><a href="#smps">17. Spatial Multiplexing Powersave (SMPS)</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-request-smps"><span>ieee80211_request_smps</span></a></span><span class="refpurpose"> — 
  request SM PS transition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-smps-mode"><span>enum ieee80211_smps_mode</span></a></span><span class="refpurpose"> — 
  spatial multiplexing power save mode
 </span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#rate-control">III. Rate control interface</a></span></dt><dd><dl><dt><span class="chapter"><a href="#ratecontrol-api">18. Rate Control API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-session"><span>ieee80211_start_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Start a tx Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-cb-irqsafe"><span>ieee80211_start_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-session"><span>ieee80211_stop_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Stop a Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-cb-irqsafe"><span>ieee80211_stop_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to stop aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-rate-control-changed"><span>enum ieee80211_rate_control_changed</span></a></span><span class="refpurpose"> — 
  flags to indicate what changed
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-rate-control"><span>struct ieee80211_tx_rate_control</span></a></span><span class="refpurpose"> — 
  rate control information for/from RC algo
 </span></dt><dt><span class="refentrytitle"><a href="#API-rate-control-send-low"><span>rate_control_send_low</span></a></span><span class="refpurpose"> — 
  helper for drivers for management/no-ack frames
 </span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#internal">IV. Internals</a></span></dt><dd><dl><dt><span class="chapter"><a href="#key-handling">19. Key handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9065360">Key handling basics</a></span></dt><dt><span class="sect1"><a href="#idp9069264">MORE TBD</a></span></dt></dl></dd><dt><span class="chapter"><a href="#rx-processing">20. Receive processing</a></span></dt><dt><span class="chapter"><a href="#tx-processing">21. Transmit processing</a></span></dt><dt><span class="chapter"><a href="#sta-info">22. Station info handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9074928">Programming information</a></span></dt><dt><span class="sect1"><a href="#idp9223600">STA information lifetime rules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#aggregation-internals">23. Aggregation</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-sta-ampdu-mlme"><span>struct sta_ampdu_mlme</span></a></span><span class="refpurpose"> — 
  STA aggregation information.
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-tx"><span>struct tid_ampdu_tx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Tx).
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-rx"><span>struct tid_ampdu_rx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Rx).
 </span></dt></dl></dd><dt><span class="chapter"><a href="#synchronisation">24. Synchronisation</a></span></dt></dl></dd></dl></dd></dl></div><div class="book" title="The cfg80211 subsystem"><div class="titlepage"><div><div><h1 class="title"><a id="cfg80211-developers-guide"></a>The cfg80211 subsystem</h1></div><div><div class="abstract" title="Abstract"><p class="title"><strong>Abstract</strong></p><p>
   </p><p>
   cfg80211 is the configuration API for 802.11 devices in Linux. It bridges
   userspace and drivers, and offers some utility functionality associated
   with 802.11. cfg80211 must, directly or indirectly via mac80211, be used
   by all modern wireless drivers in Linux, so that they offer a consistent
   API through nl80211. For backward compatibility, cfg80211 also offers
   wireless extensions to userspace, but hides them from drivers completely.
   </p><p>
   Additionally, cfg80211 contains code to help enforce regulatory spectrum
   use restrictions.
</p></div></div></div><hr></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#idp3835104">1. Device registration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-band"><span>enum ieee80211_band</span></a></span><span class="refpurpose"> — 
  supported frequency bands
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-channel-flags"><span>enum ieee80211_channel_flags</span></a></span><span class="refpurpose"> — 
  channel flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-channel"><span>struct ieee80211_channel</span></a></span><span class="refpurpose"> — 
  channel definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-rate-flags"><span>enum ieee80211_rate_flags</span></a></span><span class="refpurpose"> — 
  rate flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-rate"><span>struct ieee80211_rate</span></a></span><span class="refpurpose"> — 
  bitrate definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-sta-ht-cap"><span>struct ieee80211_sta_ht_cap</span></a></span><span class="refpurpose"> — 
  STA's HT capabilities
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-supported-band"><span>struct ieee80211_supported_band</span></a></span><span class="refpurpose"> — 
  frequency band definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-cfg80211-signal-type"><span>enum cfg80211_signal_type</span></a></span><span class="refpurpose"> — 
  signal type
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-wiphy-params-flags"><span>enum wiphy_params_flags</span></a></span><span class="refpurpose"> — 
  set_wiphy_params bitfield values
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-wiphy-flags"><span>enum wiphy_flags</span></a></span><span class="refpurpose"> — 
  wiphy capability flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-wiphy"><span>struct wiphy</span></a></span><span class="refpurpose"> — 
  wireless hardware description
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-wireless-dev"><span>struct wireless_dev</span></a></span><span class="refpurpose"> — 
  wireless device state
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-new"><span>wiphy_new</span></a></span><span class="refpurpose"> — 
  create a new wiphy for use with cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-register"><span>wiphy_register</span></a></span><span class="refpurpose"> — 
  register a wiphy with cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-unregister"><span>wiphy_unregister</span></a></span><span class="refpurpose"> — 
  deregister a wiphy from cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-free"><span>wiphy_free</span></a></span><span class="refpurpose"> — 
  free wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-name"><span>wiphy_name</span></a></span><span class="refpurpose"> — 
  get wiphy name
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-dev"><span>wiphy_dev</span></a></span><span class="refpurpose"> — 
  get wiphy dev pointer
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-priv"><span>wiphy_priv</span></a></span><span class="refpurpose"> — 
  return priv from wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-priv-to-wiphy"><span>priv_to_wiphy</span></a></span><span class="refpurpose"> — 
  return the wiphy containing the priv
 </span></dt><dt><span class="refentrytitle"><a href="#API-set-wiphy-dev"><span>set_wiphy_dev</span></a></span><span class="refpurpose"> — 
  set device pointer for wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-wdev-priv"><span>wdev_priv</span></a></span><span class="refpurpose"> — 
  return wiphy priv from wireless_dev
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp5286464">2. Actions and configuration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ops"><span>struct cfg80211_ops</span></a></span><span class="refpurpose"> — 
  backend description for wireless configuration
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-vif-params"><span>struct vif_params</span></a></span><span class="refpurpose"> — 
  describes virtual interface parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-key-params"><span>struct key_params</span></a></span><span class="refpurpose"> — 
  key information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-survey-info-flags"><span>enum survey_info_flags</span></a></span><span class="refpurpose"> — 
  survey information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-survey-info"><span>struct survey_info</span></a></span><span class="refpurpose"> — 
  channel survey response
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-beacon-data"><span>struct cfg80211_beacon_data</span></a></span><span class="refpurpose"> — 
  beacon data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ap-settings"><span>struct cfg80211_ap_settings</span></a></span><span class="refpurpose"> — 
  AP configuration
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-station-parameters"><span>struct station_parameters</span></a></span><span class="refpurpose"> — 
  station parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-station-info-flags"><span>enum station_info_flags</span></a></span><span class="refpurpose"> — 
  station information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-rate-info-flags"><span>enum rate_info_flags</span></a></span><span class="refpurpose"> — 
  bitrate info flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-rate-info"><span>struct rate_info</span></a></span><span class="refpurpose"> — 
  bitrate information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-station-info"><span>struct station_info</span></a></span><span class="refpurpose"> — 
  station information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-monitor-flags"><span>enum monitor_flags</span></a></span><span class="refpurpose"> — 
  monitor flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-mpath-info-flags"><span>enum mpath_info_flags</span></a></span><span class="refpurpose"> — 
  mesh path information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-mpath-info"><span>struct mpath_info</span></a></span><span class="refpurpose"> — 
  mesh path information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bss-parameters"><span>struct bss_parameters</span></a></span><span class="refpurpose"> — 
  BSS parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-txq-params"><span>struct ieee80211_txq_params</span></a></span><span class="refpurpose"> — 
  TX queue parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-crypto-settings"><span>struct cfg80211_crypto_settings</span></a></span><span class="refpurpose"> — 
  Crypto settings
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-auth-request"><span>struct cfg80211_auth_request</span></a></span><span class="refpurpose"> — 
  Authentication request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-assoc-request"><span>struct cfg80211_assoc_request</span></a></span><span class="refpurpose"> — 
  (Re)Association request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-deauth-request"><span>struct cfg80211_deauth_request</span></a></span><span class="refpurpose"> — 
  Deauthentication request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-disassoc-request"><span>struct cfg80211_disassoc_request</span></a></span><span class="refpurpose"> — 
  Disassociation request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ibss-params"><span>struct cfg80211_ibss_params</span></a></span><span class="refpurpose"> — 
  IBSS parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-connect-params"><span>struct cfg80211_connect_params</span></a></span><span class="refpurpose"> — 
  Connection parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-pmksa"><span>struct cfg80211_pmksa</span></a></span><span class="refpurpose"> — 
  PMK Security Association
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-mlme-mgmt"><span>cfg80211_rx_mlme_mgmt</span></a></span><span class="refpurpose"> — 
  notification of processed MLME management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-auth-timeout"><span>cfg80211_auth_timeout</span></a></span><span class="refpurpose"> — 
  notification of timed out authentication
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-assoc-resp"><span>cfg80211_rx_assoc_resp</span></a></span><span class="refpurpose"> — 
  notification of processed association response
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-assoc-timeout"><span>cfg80211_assoc_timeout</span></a></span><span class="refpurpose"> — 
  notification of timed out association
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-tx-mlme-mgmt"><span>cfg80211_tx_mlme_mgmt</span></a></span><span class="refpurpose"> — 
  notification of transmitted deauth/disassoc frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-ibss-joined"><span>cfg80211_ibss_joined</span></a></span><span class="refpurpose"> — 
  notify cfg80211 that device joined an IBSS
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-connect-result"><span>cfg80211_connect_result</span></a></span><span class="refpurpose"> — 
  notify cfg80211 of connection result
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-roamed"><span>cfg80211_roamed</span></a></span><span class="refpurpose"> — 
  notify cfg80211 of roaming
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-disconnected"><span>cfg80211_disconnected</span></a></span><span class="refpurpose"> — 
  notify cfg80211 that connection was dropped
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-ready-on-channel"><span>cfg80211_ready_on_channel</span></a></span><span class="refpurpose"> — 
  notification of remain_on_channel start
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-remain-on-channel-expired"><span>cfg80211_remain_on_channel_expired</span></a></span><span class="refpurpose"> — 
  remain_on_channel duration expired
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-new-sta"><span>cfg80211_new_sta</span></a></span><span class="refpurpose"> — 
  notify userspace about station
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-mgmt"><span>cfg80211_rx_mgmt</span></a></span><span class="refpurpose"> — 
  notification of received, unprocessed management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-mgmt-tx-status"><span>cfg80211_mgmt_tx_status</span></a></span><span class="refpurpose"> — 
  notification of TX status for management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-cqm-rssi-notify"><span>cfg80211_cqm_rssi_notify</span></a></span><span class="refpurpose"> — 
  connection quality monitoring rssi event
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-cqm-pktloss-notify"><span>cfg80211_cqm_pktloss_notify</span></a></span><span class="refpurpose"> — 
  notify userspace about packetloss to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-michael-mic-failure"><span>cfg80211_michael_mic_failure</span></a></span><span class="refpurpose"> — 
  notification of Michael MIC failure (TKIP)
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6458464">3. Scanning and BSS list handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ssid"><span>struct cfg80211_ssid</span></a></span><span class="refpurpose"> — 
  SSID description
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-scan-request"><span>struct cfg80211_scan_request</span></a></span><span class="refpurpose"> — 
  scan request description
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-scan-done"><span>cfg80211_scan_done</span></a></span><span class="refpurpose"> — 
  notify that scan finished
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-bss"><span>struct cfg80211_bss</span></a></span><span class="refpurpose"> — 
  BSS description
 </span></dt><dt><span class="refentrytitle"><a href="#idp6542112">
   /home/landley/linux/linux//include/net/cfg80211.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#idp6546128">
   /home/landley/linux/linux//include/net/cfg80211.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-unlink-bss"><span>cfg80211_unlink_bss</span></a></span><span class="refpurpose"> — 
  unlink BSS from internal data structures
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-find-ie"><span>cfg80211_find_ie</span></a></span><span class="refpurpose"> — 
  find information element in data
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-bss-get-ie"><span>ieee80211_bss_get_ie</span></a></span><span class="refpurpose"> — 
  find IE with given ID
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6603936">4. Utility functions</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-channel-to-frequency"><span>ieee80211_channel_to_frequency</span></a></span><span class="refpurpose"> — 
  convert channel number to frequency
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-frequency-to-channel"><span>ieee80211_frequency_to_channel</span></a></span><span class="refpurpose"> — 
  convert frequency to channel number
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-channel"><span>ieee80211_get_channel</span></a></span><span class="refpurpose"> — 
  get channel struct from wiphy for specified frequency
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-response-rate"><span>ieee80211_get_response_rate</span></a></span><span class="refpurpose"> — 
  get basic rate for a given rate
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-hdrlen"><span>ieee80211_hdrlen</span></a></span><span class="refpurpose"> — 
  get header length in bytes from frame control
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-hdrlen-from-skb"><span>ieee80211_get_hdrlen_from_skb</span></a></span><span class="refpurpose"> — 
  get header length from data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-radiotap-iterator"><span>struct ieee80211_radiotap_iterator</span></a></span><span class="refpurpose"> — 
  tracks walk thru present radiotap args
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6726736">5. Data path helpers</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-data-to-8023"><span>ieee80211_data_to_8023</span></a></span><span class="refpurpose"> — 
  convert an 802.11 data frame to 802.3
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-data-from-8023"><span>ieee80211_data_from_8023</span></a></span><span class="refpurpose"> — 
  convert an 802.3 frame to 802.11
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-amsdu-to-8023s"><span>ieee80211_amsdu_to_8023s</span></a></span><span class="refpurpose"> — 
  decode an IEEE 802.11n A-MSDU frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-classify8021d"><span>cfg80211_classify8021d</span></a></span><span class="refpurpose"> — 
  determine the 802.1p/1d tag for a data frame
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6816576">6. Regulatory enforcement infrastructure</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-regulatory-hint"><span>regulatory_hint</span></a></span><span class="refpurpose"> — 
  driver hint to the wireless core a regulatory domain
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-apply-custom-regulatory"><span>wiphy_apply_custom_regulatory</span></a></span><span class="refpurpose"> — 
  apply a custom driver regulatory domain
 </span></dt><dt><span class="refentrytitle"><a href="#API-freq-reg-info"><span>freq_reg_info</span></a></span><span class="refpurpose"> — 
  get regulatory information for the given frequency
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6878256">7. RFkill integration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-set-hw-state"><span>wiphy_rfkill_set_hw_state</span></a></span><span class="refpurpose"> — 
  notify cfg80211 about hw block state
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-start-polling"><span>wiphy_rfkill_start_polling</span></a></span><span class="refpurpose"> — 
  start polling rfkill
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-stop-polling"><span>wiphy_rfkill_stop_polling</span></a></span><span class="refpurpose"> — 
  stop polling rfkill
 </span></dt></dl></dd><dt><span class="chapter"><a href="#idp6921040">8. Test mode</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-alloc-reply-skb"><span>cfg80211_testmode_alloc_reply_skb</span></a></span><span class="refpurpose"> — 
  allocate testmode reply
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-reply"><span>cfg80211_testmode_reply</span></a></span><span class="refpurpose"> — 
  send the reply skb
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-alloc-event-skb"><span>cfg80211_testmode_alloc_event_skb</span></a></span><span class="refpurpose"> — 
  allocate testmode event
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-event"><span>cfg80211_testmode_event</span></a></span><span class="refpurpose"> — 
  send the event
 </span></dt></dl></dd></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Device registration"><div class="titlepage"><div><div><h2 class="title"><a id="idp3835104"></a>Chapter&nbsp;1.&nbsp;Device registration</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-band"><span>enum ieee80211_band</span></a></span><span class="refpurpose"> — 
  supported frequency bands
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-channel-flags"><span>enum ieee80211_channel_flags</span></a></span><span class="refpurpose"> — 
  channel flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-channel"><span>struct ieee80211_channel</span></a></span><span class="refpurpose"> — 
  channel definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-rate-flags"><span>enum ieee80211_rate_flags</span></a></span><span class="refpurpose"> — 
  rate flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-rate"><span>struct ieee80211_rate</span></a></span><span class="refpurpose"> — 
  bitrate definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-sta-ht-cap"><span>struct ieee80211_sta_ht_cap</span></a></span><span class="refpurpose"> — 
  STA's HT capabilities
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-supported-band"><span>struct ieee80211_supported_band</span></a></span><span class="refpurpose"> — 
  frequency band definition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-cfg80211-signal-type"><span>enum cfg80211_signal_type</span></a></span><span class="refpurpose"> — 
  signal type
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-wiphy-params-flags"><span>enum wiphy_params_flags</span></a></span><span class="refpurpose"> — 
  set_wiphy_params bitfield values
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-wiphy-flags"><span>enum wiphy_flags</span></a></span><span class="refpurpose"> — 
  wiphy capability flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-wiphy"><span>struct wiphy</span></a></span><span class="refpurpose"> — 
  wireless hardware description
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-wireless-dev"><span>struct wireless_dev</span></a></span><span class="refpurpose"> — 
  wireless device state
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-new"><span>wiphy_new</span></a></span><span class="refpurpose"> — 
  create a new wiphy for use with cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-register"><span>wiphy_register</span></a></span><span class="refpurpose"> — 
  register a wiphy with cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-unregister"><span>wiphy_unregister</span></a></span><span class="refpurpose"> — 
  deregister a wiphy from cfg80211
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-free"><span>wiphy_free</span></a></span><span class="refpurpose"> — 
  free wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-name"><span>wiphy_name</span></a></span><span class="refpurpose"> — 
  get wiphy name
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-dev"><span>wiphy_dev</span></a></span><span class="refpurpose"> — 
  get wiphy dev pointer
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-priv"><span>wiphy_priv</span></a></span><span class="refpurpose"> — 
  return priv from wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-priv-to-wiphy"><span>priv_to_wiphy</span></a></span><span class="refpurpose"> — 
  return the wiphy containing the priv
 </span></dt><dt><span class="refentrytitle"><a href="#API-set-wiphy-dev"><span>set_wiphy_dev</span></a></span><span class="refpurpose"> — 
  set device pointer for wiphy
 </span></dt><dt><span class="refentrytitle"><a href="#API-wdev-priv"><span>wdev_priv</span></a></span><span class="refpurpose"> — 
  return wiphy priv from wireless_dev
 </span></dt></dl></div><p>
   </p><p>
   In order for a driver to use cfg80211, it must register the hardware device
   with cfg80211. This happens through a number of hardware capability structs
   described below.
   </p><p>
   The fundamental structure for each device is the 'wiphy', of which each
   instance describes a physical wireless device connected to the system. Each
   such wiphy can have zero, one, or many virtual interfaces associated with
   it, which need to be identified as such by pointing the network interface's
   <em class="parameter"><code>ieee80211_ptr</code></em> pointer to a <span class="structname">struct wireless_dev</span> which further describes
   the wireless part of the interface, normally this struct is embedded in the
   network interface's private data area. Drivers can optionally allow creating
   or destroying virtual interfaces on the fly, but without at least one or the
   ability to create some the wireless device isn't useful.
   </p><p>
   Each wiphy structure contains device capability information, and also has
   a pointer to the various operations the driver offers. The definitions and
   structures here describe these capabilities in detail.
</p><div class="refentry" title="enum ieee80211_band"><a id="API-enum-ieee80211-band"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_band — 
  supported frequency bands
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_band {
  IEEE80211_BAND_2GHZ,
  IEEE80211_BAND_5GHZ,
  IEEE80211_BAND_60GHZ,
  IEEE80211_NUM_BANDS
};  </pre></div><div class="refsect1" title="Constants"><a id="idp71520"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_BAND_2GHZ</span></dt><dd><p>
2.4GHz ISM band
      </p></dd><dt><span class="term">IEEE80211_BAND_5GHZ</span></dt><dd><p>
around 5GHz band (4.9-5.7)
      </p></dd><dt><span class="term">IEEE80211_BAND_60GHZ</span></dt><dd><p>
around 60 GHz band (58.32 - 64.80 GHz)
      </p></dd><dt><span class="term">IEEE80211_NUM_BANDS</span></dt><dd><p>
number of defined bands
      </p></dd></dl></div></div><div class="refsect1" title="Device registration"><a id="idp78080"></a><h2>Device registration</h2><p>
   </p><p>

   The bands are assigned this way because the supported
   bitrates differ in these bands.
</p></div></div><div class="refentry" title="enum ieee80211_channel_flags"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-channel-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_channel_flags — 
  channel flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_channel_flags {
  IEEE80211_CHAN_DISABLED,
  IEEE80211_CHAN_PASSIVE_SCAN,
  IEEE80211_CHAN_NO_IBSS,
  IEEE80211_CHAN_RADAR,
  IEEE80211_CHAN_NO_HT40PLUS,
  IEEE80211_CHAN_NO_HT40MINUS,
  IEEE80211_CHAN_NO_OFDM,
  IEEE80211_CHAN_NO_80MHZ,
  IEEE80211_CHAN_NO_160MHZ
};  </pre></div><div class="refsect1" title="Constants"><a id="idp87264"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_CHAN_DISABLED</span></dt><dd><p>
This channel is disabled.
      </p></dd><dt><span class="term">IEEE80211_CHAN_PASSIVE_SCAN</span></dt><dd><p>
Only passive scanning is permitted
on this channel.
      </p></dd><dt><span class="term">IEEE80211_CHAN_NO_IBSS</span></dt><dd><p>
IBSS is not allowed on this channel.
      </p></dd><dt><span class="term">IEEE80211_CHAN_RADAR</span></dt><dd><p>
Radar detection is required on this channel.
      </p></dd><dt><span class="term">IEEE80211_CHAN_NO_HT40PLUS</span></dt><dd><p>
extension channel above this channel
is not permitted.
      </p></dd><dt><span class="term">IEEE80211_CHAN_NO_HT40MINUS</span></dt><dd><p>
extension channel below this channel
is not permitted.
      </p></dd><dt><span class="term">IEEE80211_CHAN_NO_OFDM</span></dt><dd><p>
OFDM is not allowed on this channel.
      </p></dd><dt><span class="term">IEEE80211_CHAN_NO_80MHZ</span></dt><dd><p>
If the driver supports 80 MHz on the band,
this flag indicates that an 80 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.
      </p></dd><dt><span class="term">IEEE80211_CHAN_NO_160MHZ</span></dt><dd><p>
If the driver supports 160 MHz on the band,
this flag indicates that an 160 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp104944"></a><h2>Description</h2><p>
   </p><p>

   Channel flags set by the regulatory control code.
</p></div></div><div class="refentry" title="struct ieee80211_channel"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-channel"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_channel — 
  channel definition
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_channel {
  enum ieee80211_band band;
  u16 center_freq;
  u16 hw_value;
  u32 flags;
  int max_antenna_gain;
  int max_power;
  int max_reg_power;
  bool beacon_found;
  u32 orig_flags;
  int orig_mag;
  int orig_mpwr;
  enum nl80211_dfs_state dfs_state;
  unsigned long dfs_state_entered;
};  </pre></div><div class="refsect1" title="Members"><a id="idp114096"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">band</span></dt><dd><p>
band this channel belongs to.
      </p></dd><dt><span class="term">center_freq</span></dt><dd><p>
center frequency in MHz
      </p></dd><dt><span class="term">hw_value</span></dt><dd><p>
hardware-specific value for the channel
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
channel flags from <span class="structname">enum</span> ieee80211_channel_flags.
      </p></dd><dt><span class="term">max_antenna_gain</span></dt><dd><p>
maximum antenna gain in dBi
      </p></dd><dt><span class="term">max_power</span></dt><dd><p>
maximum transmission power (in dBm)
      </p></dd><dt><span class="term">max_reg_power</span></dt><dd><p>
maximum regulatory transmission power (in dBm)
      </p></dd><dt><span class="term">beacon_found</span></dt><dd><p>
helper to regulatory code to indicate when a beacon
has been found on this channel. Use <code class="function">regulatory_hint_found_beacon</code>
to enable this, this is useful only on 5 GHz band.
      </p></dd><dt><span class="term">orig_flags</span></dt><dd><p>
channel flags at registration time, used by regulatory
code to support devices with additional restrictions
      </p></dd><dt><span class="term">orig_mag</span></dt><dd><p>
internal use
      </p></dd><dt><span class="term">orig_mpwr</span></dt><dd><p>
internal use
      </p></dd><dt><span class="term">dfs_state</span></dt><dd><p>
current state of this channel. Only relevant if radar is required
on this channel.
      </p></dd><dt><span class="term">dfs_state_entered</span></dt><dd><p>
timestamp (jiffies) when the dfs state was entered.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp4861104"></a><h2>Description</h2><p>
   </p><p>

   This structure describes a single channel for use
   with cfg80211.
</p></div></div><div class="refentry" title="enum ieee80211_rate_flags"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-rate-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_rate_flags — 
  rate flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_rate_flags {
  IEEE80211_RATE_SHORT_PREAMBLE,
  IEEE80211_RATE_MANDATORY_A,
  IEEE80211_RATE_MANDATORY_B,
  IEEE80211_RATE_MANDATORY_G,
  IEEE80211_RATE_ERP_G,
  IEEE80211_RATE_SUPPORTS_5MHZ,
  IEEE80211_RATE_SUPPORTS_10MHZ
};  </pre></div><div class="refsect1" title="Constants"><a id="idp4869616"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_RATE_SHORT_PREAMBLE</span></dt><dd><p>
Hardware can send with short
preamble on this bitrate; only relevant in 2.4GHz band and
with CCK rates.
      </p></dd><dt><span class="term">IEEE80211_RATE_MANDATORY_A</span></dt><dd><p>
This bitrate is a mandatory rate
when used with 802.11a (on the 5 GHz band); filled by the
core code when registering the wiphy.
      </p></dd><dt><span class="term">IEEE80211_RATE_MANDATORY_B</span></dt><dd><p>
This bitrate is a mandatory rate
when used with 802.11b (on the 2.4 GHz band); filled by the
core code when registering the wiphy.
      </p></dd><dt><span class="term">IEEE80211_RATE_MANDATORY_G</span></dt><dd><p>
This bitrate is a mandatory rate
when used with 802.11g (on the 2.4 GHz band); filled by the
core code when registering the wiphy.
      </p></dd><dt><span class="term">IEEE80211_RATE_ERP_G</span></dt><dd><p>
This is an ERP rate in 802.11g mode.
      </p></dd><dt><span class="term">IEEE80211_RATE_SUPPORTS_5MHZ</span></dt><dd><p>
Rate can be used in 5 MHz mode
      </p></dd><dt><span class="term">IEEE80211_RATE_SUPPORTS_10MHZ</span></dt><dd><p>
Rate can be used in 10 MHz mode
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp4880336"></a><h2>Description</h2><p>
   </p><p>

   Hardware/specification flags for rates. These are structured
   in a way that allows using the same bitrate structure for
   different bands/PHY modes.
</p></div></div><div class="refentry" title="struct ieee80211_rate"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-rate"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_rate — 
  bitrate definition
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_rate {
  u32 flags;
  u16 bitrate;
  u16 hw_value;
  u16 hw_value_short;
};  </pre></div><div class="refsect1" title="Members"><a id="idp4888880"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">flags</span></dt><dd><p>
rate-specific flags
      </p></dd><dt><span class="term">bitrate</span></dt><dd><p>
bitrate in units of 100 Kbps
      </p></dd><dt><span class="term">hw_value</span></dt><dd><p>
driver/hardware value for this rate
      </p></dd><dt><span class="term">hw_value_short</span></dt><dd><p>
driver/hardware value for this rate when
short preamble is used
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp4895152"></a><h2>Description</h2><p>
   </p><p>

   This structure describes a bitrate that an 802.11 PHY can
   operate with. The two values <em class="parameter"><code>hw_value</code></em> and <em class="parameter"><code>hw_value_short</code></em>
   are only for driver use when pointers to this structure are
   passed around.
</p></div></div><div class="refentry" title="struct ieee80211_sta_ht_cap"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-sta-ht-cap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_sta_ht_cap — 
  STA's HT capabilities
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_sta_ht_cap {
  u16 cap;
  bool ht_supported;
  u8 ampdu_factor;
  u8 ampdu_density;
  struct ieee80211_mcs_info mcs;
};  </pre></div><div class="refsect1" title="Members"><a id="idp4904928"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">cap</span></dt><dd><p>
HT capabilities map as described in 802.11n spec
      </p></dd><dt><span class="term">ht_supported</span></dt><dd><p>
is HT supported by the STA
      </p></dd><dt><span class="term">ampdu_factor</span></dt><dd><p>
Maximum A-MPDU length factor
      </p></dd><dt><span class="term">ampdu_density</span></dt><dd><p>
Minimum A-MPDU spacing
      </p></dd><dt><span class="term">mcs</span></dt><dd><p>
Supported MCS rates
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp4912480"></a><h2>Description</h2><p>
   </p><p>

   This structure describes most essential parameters needed
   to describe 802.11n HT capabilities for an STA.
</p></div></div><div class="refentry" title="struct ieee80211_supported_band"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-supported-band"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_supported_band — 
  frequency band definition
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_supported_band {
  struct ieee80211_channel * channels;
  struct ieee80211_rate * bitrates;
  enum ieee80211_band band;
  int n_channels;
  int n_bitrates;
  struct ieee80211_sta_ht_cap ht_cap;
  struct ieee80211_sta_vht_cap vht_cap;
};  </pre></div><div class="refsect1" title="Members"><a id="idp4921136"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">channels</span></dt><dd><p>
Array of channels the hardware can operate in
in this band.
      </p></dd><dt><span class="term">bitrates</span></dt><dd><p>
Array of bitrates the hardware can operate with
in this band. Must be sorted to give a valid <span class="quote">“<span class="quote">supported
rates</span>”</span> IE, i.e. CCK rates first, then OFDM.
      </p></dd><dt><span class="term">band</span></dt><dd><p>
the band this structure represents
      </p></dd><dt><span class="term">n_channels</span></dt><dd><p>
Number of channels in <em class="parameter"><code>channels</code></em>
      </p></dd><dt><span class="term">n_bitrates</span></dt><dd><p>
Number of bitrates in <em class="parameter"><code>bitrates</code></em>
      </p></dd><dt><span class="term">ht_cap</span></dt><dd><p>
HT capabilities in this band
      </p></dd><dt><span class="term">vht_cap</span></dt><dd><p>
VHT capabilities in this band
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp4932992"></a><h2>Description</h2><p>
   </p><p>

   This structure describes a frequency band a wiphy
   is able to operate in.
</p></div></div><div class="refentry" title="enum cfg80211_signal_type"><div class="refentry.separator"><hr></div><a id="API-enum-cfg80211-signal-type"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum cfg80211_signal_type — 
  signal type
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum cfg80211_signal_type {
  CFG80211_SIGNAL_TYPE_NONE,
  CFG80211_SIGNAL_TYPE_MBM,
  CFG80211_SIGNAL_TYPE_UNSPEC
};  </pre></div><div class="refsect1" title="Constants"><a id="idp4941392"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">CFG80211_SIGNAL_TYPE_NONE</span></dt><dd><p>
no signal strength information available
      </p></dd><dt><span class="term">CFG80211_SIGNAL_TYPE_MBM</span></dt><dd><p>
signal strength in mBm (100*dBm)
      </p></dd><dt><span class="term">CFG80211_SIGNAL_TYPE_UNSPEC</span></dt><dd><p>
signal strength, increasing from 0 through 100
      </p></dd></dl></div></div></div><div class="refentry" title="enum wiphy_params_flags"><div class="refentry.separator"><hr></div><a id="API-enum-wiphy-params-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum wiphy_params_flags — 
  set_wiphy_params bitfield values
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum wiphy_params_flags {
  WIPHY_PARAM_RETRY_SHORT,
  WIPHY_PARAM_RETRY_LONG,
  WIPHY_PARAM_FRAG_THRESHOLD,
  WIPHY_PARAM_RTS_THRESHOLD,
  WIPHY_PARAM_COVERAGE_CLASS
};  </pre></div><div class="refsect1" title="Constants"><a id="idp4953424"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">WIPHY_PARAM_RETRY_SHORT</span></dt><dd><p>
wiphy-&gt;retry_short has changed
      </p></dd><dt><span class="term">WIPHY_PARAM_RETRY_LONG</span></dt><dd><p>
wiphy-&gt;retry_long has changed
      </p></dd><dt><span class="term">WIPHY_PARAM_FRAG_THRESHOLD</span></dt><dd><p>
wiphy-&gt;frag_threshold has changed
      </p></dd><dt><span class="term">WIPHY_PARAM_RTS_THRESHOLD</span></dt><dd><p>
wiphy-&gt;rts_threshold has changed
      </p></dd><dt><span class="term">WIPHY_PARAM_COVERAGE_CLASS</span></dt><dd><p>
coverage class changed
      </p></dd></dl></div></div></div><div class="refentry" title="enum wiphy_flags"><div class="refentry.separator"><hr></div><a id="API-enum-wiphy-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum wiphy_flags — 
  wiphy capability flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum wiphy_flags {
  WIPHY_FLAG_CUSTOM_REGULATORY,
  WIPHY_FLAG_STRICT_REGULATORY,
  WIPHY_FLAG_DISABLE_BEACON_HINTS,
  WIPHY_FLAG_NETNS_OK,
  WIPHY_FLAG_PS_ON_BY_DEFAULT,
  WIPHY_FLAG_4ADDR_AP,
  WIPHY_FLAG_4ADDR_STATION,
  WIPHY_FLAG_CONTROL_PORT_PROTOCOL,
  WIPHY_FLAG_IBSS_RSN,
  WIPHY_FLAG_MESH_AUTH,
  WIPHY_FLAG_SUPPORTS_SCHED_SCAN,
  WIPHY_FLAG_SUPPORTS_FW_ROAM,
  WIPHY_FLAG_AP_UAPSD,
  WIPHY_FLAG_SUPPORTS_TDLS,
  WIPHY_FLAG_TDLS_EXTERNAL_SETUP,
  WIPHY_FLAG_HAVE_AP_SME,
  WIPHY_FLAG_REPORTS_OBSS,
  WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD,
  WIPHY_FLAG_OFFCHAN_TX,
  WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL,
  WIPHY_FLAG_SUPPORTS_5_10_MHZ,
  WIPHY_FLAG_HAS_CHANNEL_SWITCH
};  </pre></div><div class="refsect1" title="Constants"><a id="idp4968960"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">WIPHY_FLAG_CUSTOM_REGULATORY</span></dt><dd><p>
tells us the driver for this device
has its own custom regulatory domain and cannot identify the
ISO / IEC 3166 alpha2 it belongs to. When this is enabled
we will disregard the first regulatory hint (when the
initiator is <code class="constant">REGDOM_SET_BY_CORE</code>).
      </p></dd><dt><span class="term">WIPHY_FLAG_STRICT_REGULATORY</span></dt><dd><p>
tells us the driver for this device will
ignore regulatory domain settings until it gets its own regulatory
domain via its <code class="function">regulatory_hint</code> unless the regulatory hint is
from a country IE. After its gets its own regulatory domain it will
only allow further regulatory domain settings to further enhance
compliance. For example if channel 13 and 14 are disabled by this
regulatory domain no user regulatory domain can enable these channels
at a later time. This can be used for devices which do not have
calibration information guaranteed for frequencies or settings
outside of its regulatory domain. If used in combination with
WIPHY_FLAG_CUSTOM_REGULATORY the inspected country IE power settings
will be followed.
      </p></dd><dt><span class="term">WIPHY_FLAG_DISABLE_BEACON_HINTS</span></dt><dd><p>
enable this if your driver needs to ensure
that passive scan flags and beaconing flags may not be lifted by
cfg80211 due to regulatory beacon hints. For more information on beacon
hints read the documenation for <code class="function">regulatory_hint_found_beacon</code>
      </p></dd><dt><span class="term">WIPHY_FLAG_NETNS_OK</span></dt><dd><p>
if not set, do not allow changing the netns of this
wiphy at all
      </p></dd><dt><span class="term">WIPHY_FLAG_PS_ON_BY_DEFAULT</span></dt><dd><p>
if set to true, powersave will be enabled
by default -- this flag will be set depending on the kernel's default
on <code class="function">wiphy_new</code>, but can be changed by the driver if it has a good
reason to override the default
      </p></dd><dt><span class="term">WIPHY_FLAG_4ADDR_AP</span></dt><dd><p>
supports 4addr mode even on AP (with a single station
on a VLAN interface)
      </p></dd><dt><span class="term">WIPHY_FLAG_4ADDR_STATION</span></dt><dd><p>
supports 4addr mode even as a station
      </p></dd><dt><span class="term">WIPHY_FLAG_CONTROL_PORT_PROTOCOL</span></dt><dd><p>
This device supports setting the
control port protocol ethertype. The device also honours the
control_port_no_encrypt flag.
      </p></dd><dt><span class="term">WIPHY_FLAG_IBSS_RSN</span></dt><dd><p>
The device supports IBSS RSN.
      </p></dd><dt><span class="term">WIPHY_FLAG_MESH_AUTH</span></dt><dd><p>
The device supports mesh authentication by routing
auth frames to userspace. See <em class="parameter"><code>NL80211_MESH_SETUP_USERSPACE_AUTH</code></em>.
      </p></dd><dt><span class="term">WIPHY_FLAG_SUPPORTS_SCHED_SCAN</span></dt><dd><p>
The device supports scheduled scans.
      </p></dd><dt><span class="term">WIPHY_FLAG_SUPPORTS_FW_ROAM</span></dt><dd><p>
The device supports roaming feature in the
firmware.
      </p></dd><dt><span class="term">WIPHY_FLAG_AP_UAPSD</span></dt><dd><p>
The device supports uapsd on AP.
      </p></dd><dt><span class="term">WIPHY_FLAG_SUPPORTS_TDLS</span></dt><dd><p>
The device supports TDLS (802.11z) operation.
      </p></dd><dt><span class="term">WIPHY_FLAG_TDLS_EXTERNAL_SETUP</span></dt><dd><p>
The device does not handle TDLS (802.11z)
link setup/discovery operations internally. Setup, discovery and
teardown packets should be sent through the <em class="parameter"><code>NL80211_CMD_TDLS_MGMT</code></em>
command. When this flag is not set, <em class="parameter"><code>NL80211_CMD_TDLS_OPER</code></em> should be
used for asking the driver/firmware to perform a TDLS operation.
      </p></dd><dt><span class="term">WIPHY_FLAG_HAVE_AP_SME</span></dt><dd><p>
device integrates AP SME
      </p></dd><dt><span class="term">WIPHY_FLAG_REPORTS_OBSS</span></dt><dd><p>
the device will report beacons from other BSSes
when there are virtual interfaces in AP mode by calling
<code class="function">cfg80211_report_obss_beacon</code>.
      </p></dd><dt><span class="term">WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</span></dt><dd><p>
When operating as an AP, the device
responds to probe-requests in hardware.
      </p></dd><dt><span class="term">WIPHY_FLAG_OFFCHAN_TX</span></dt><dd><p>
Device supports direct off-channel TX.
      </p></dd><dt><span class="term">WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL</span></dt><dd><p>
Device supports remain-on-channel call.
      </p></dd><dt><span class="term">WIPHY_FLAG_SUPPORTS_5_10_MHZ</span></dt><dd><p>
Device supports 5 MHz and 10 MHz channels.
      </p></dd><dt><span class="term">WIPHY_FLAG_HAS_CHANNEL_SWITCH</span></dt><dd><p>
Device supports channel switch in
beaconing mode (AP, IBSS, Mesh, ...).
      </p></dd></dl></div></div></div><div class="refentry" title="struct wiphy"><div class="refentry.separator"><hr></div><a id="API-struct-wiphy"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct wiphy — 
  wireless hardware description
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct wiphy {
  u8 perm_addr[ETH_ALEN];
  u8 addr_mask[ETH_ALEN];
  struct mac_address * addresses;
  const struct ieee80211_txrx_stypes * mgmt_stypes;
  const struct ieee80211_iface_combination * iface_combinations;
  int n_iface_combinations;
  u16 software_iftypes;
  u16 n_addresses;
  u16 interface_modes;
  u16 max_acl_mac_addrs;
  u32 flags;
  u32 features;
  u32 ap_sme_capa;
  enum cfg80211_signal_type signal_type;
  int bss_priv_size;
  u8 max_scan_ssids;
  u8 max_sched_scan_ssids;
  u8 max_match_sets;
  u16 max_scan_ie_len;
  u16 max_sched_scan_ie_len;
  int n_cipher_suites;
  const u32 * cipher_suites;
  u8 retry_short;
  u8 retry_long;
  u32 frag_threshold;
  u32 rts_threshold;
  u8 coverage_class;
  char fw_version[ETHTOOL_FWVERS_LEN];
  u32 hw_version;
#ifdef CONFIG_PM
  const struct wiphy_wowlan_support * wowlan;
  struct cfg80211_wowlan * wowlan_config;
#endif
  u16 max_remain_on_channel_duration;
  u8 max_num_pmkids;
  u32 available_antennas_tx;
  u32 available_antennas_rx;
  u32 probe_resp_offload;
  const u8 * extended_capabilities;
  const u8 * extended_capabilities_mask;
  u8 extended_capabilities_len;
  const void * privid;
  struct ieee80211_supported_band * bands[IEEE80211_NUM_BANDS];
  void (* reg_notifier) (struct wiphy *wiphy,struct regulatory_request *request);
  const struct ieee80211_regdomain __rcu * regd;
  struct device dev;
  bool registered;
  struct dentry * debugfsdir;
  const struct ieee80211_ht_cap * ht_capa_mod_mask;
  const struct ieee80211_vht_cap * vht_capa_mod_mask;
#ifdef CONFIG_NET_NS
  struct net * _net;
#endif
#ifdef CONFIG_CFG80211_WEXT
  const struct iw_handler_def * wext;
#endif
  const struct wiphy_coalesce_support * coalesce;
  char priv[0];
};  </pre></div><div class="refsect1" title="Members"><a id="idp5015712"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">perm_addr[ETH_ALEN]</span></dt><dd><p>
permanent MAC address of this device
      </p></dd><dt><span class="term">addr_mask[ETH_ALEN]</span></dt><dd><p>
If the device supports multiple MAC addresses by masking,
set this to a mask with variable bits set to 1, e.g. if the last
      </p></dd><dt><span class="term">addresses</span></dt><dd><p>
If the device has more than one address, set this pointer
to a list of addresses (6 bytes each). The first one will be used
by default for perm_addr. In this case, the mask should be set to
all-zeroes. In this case it is assumed that the device can handle
the same number of arbitrary MAC addresses.
      </p></dd><dt><span class="term">mgmt_stypes</span></dt><dd><p>
bitmasks of frame subtypes that can be subscribed to or
transmitted through nl80211, points to an array indexed by interface
type
      </p></dd><dt><span class="term">iface_combinations</span></dt><dd><p>
Valid interface combinations array, should not
list single interface types.
      </p></dd><dt><span class="term">n_iface_combinations</span></dt><dd><p>
number of entries in <em class="parameter"><code>iface_combinations</code></em> array.
      </p></dd><dt><span class="term">software_iftypes</span></dt><dd><p>
bitmask of software interface types, these are not
subject to any restrictions since they are purely managed in SW.
      </p></dd><dt><span class="term">n_addresses</span></dt><dd><p>
number of addresses in <em class="parameter"><code>addresses</code></em>.
      </p></dd><dt><span class="term">interface_modes</span></dt><dd><p>
bitmask of interfaces types valid for this wiphy,
must be set by driver
      </p></dd><dt><span class="term">max_acl_mac_addrs</span></dt><dd><p>
Maximum number of MAC addresses that the device
supports for ACL.
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
wiphy flags, see <span class="structname">enum</span> wiphy_flags
      </p></dd><dt><span class="term">features</span></dt><dd><p>
features advertised to nl80211, see <span class="structname">enum</span> nl80211_feature_flags.
      </p></dd><dt><span class="term">ap_sme_capa</span></dt><dd><p>
AP SME capabilities, flags from <span class="structname">enum</span> nl80211_ap_sme_features.
      </p></dd><dt><span class="term">signal_type</span></dt><dd><p>
signal type reported in <span class="structname">struct cfg80211_bss</span>.
      </p></dd><dt><span class="term">bss_priv_size</span></dt><dd><p>
each BSS struct has private data allocated with it,
this variable determines its size
      </p></dd><dt><span class="term">max_scan_ssids</span></dt><dd><p>
maximum number of SSIDs the device can scan for in
any given scan
      </p></dd><dt><span class="term">max_sched_scan_ssids</span></dt><dd><p>
maximum number of SSIDs the device can scan
for in any given scheduled scan
      </p></dd><dt><span class="term">max_match_sets</span></dt><dd><p>
maximum number of match sets the device can handle
when performing a scheduled scan, 0 if filtering is not
supported.
      </p></dd><dt><span class="term">max_scan_ie_len</span></dt><dd><p>
maximum length of user-controlled IEs device can
add to probe request frames transmitted during a scan, must not
include fixed IEs like supported rates
      </p></dd><dt><span class="term">max_sched_scan_ie_len</span></dt><dd><p>
same as max_scan_ie_len, but for scheduled
scans
      </p></dd><dt><span class="term">n_cipher_suites</span></dt><dd><p>
number of supported cipher suites
      </p></dd><dt><span class="term">cipher_suites</span></dt><dd><p>
supported cipher suites
      </p></dd><dt><span class="term">retry_short</span></dt><dd><p>
Retry limit for short frames (dot11ShortRetryLimit)
      </p></dd><dt><span class="term">retry_long</span></dt><dd><p>
Retry limit for long frames (dot11LongRetryLimit)
      </p></dd><dt><span class="term">frag_threshold</span></dt><dd><p>
Fragmentation threshold (dot11FragmentationThreshold);
-1 = fragmentation disabled, only odd values &gt;= 256 used
      </p></dd><dt><span class="term">rts_threshold</span></dt><dd><p>
RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled
      </p></dd><dt><span class="term">coverage_class</span></dt><dd><p>
current coverage class
      </p></dd><dt><span class="term">fw_version[ETHTOOL_FWVERS_LEN]</span></dt><dd><p>
firmware version for ethtool reporting
      </p></dd><dt><span class="term">hw_version</span></dt><dd><p>
hardware version for ethtool reporting
      </p></dd><dt><span class="term">wowlan</span></dt><dd><p>
WoWLAN support information
      </p></dd><dt><span class="term">wowlan_config</span></dt><dd><p>
current WoWLAN configuration; this should usually not be
used since access to it is necessarily racy, use the parameter passed
to the <code class="function">suspend</code> operation instead.
      </p></dd><dt><span class="term">max_remain_on_channel_duration</span></dt><dd><p>
Maximum time a remain-on-channel operation
may request, if implemented.
      </p></dd><dt><span class="term">max_num_pmkids</span></dt><dd><p>
maximum number of PMKIDs supported by device
      </p></dd><dt><span class="term">available_antennas_tx</span></dt><dd><p>
bitmap of antennas which are available to be
configured as TX antennas. Antenna configuration commands will be
rejected unless this or <em class="parameter"><code>available_antennas_rx</code></em> is set.
      </p></dd><dt><span class="term">available_antennas_rx</span></dt><dd><p>
bitmap of antennas which are available to be
configured as RX antennas. Antenna configuration commands will be
rejected unless this or <em class="parameter"><code>available_antennas_tx</code></em> is set.
      </p></dd><dt><span class="term">probe_resp_offload</span></dt><dd><p>
Bitmap of supported protocols for probe response offloading.
See <span class="structname">enum</span> nl80211_probe_resp_offload_support_attr. Only valid
when the wiphy flag <em class="parameter"><code>WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD</code></em> is set.
      </p></dd><dt><span class="term">extended_capabilities</span></dt><dd><p>
extended capabilities supported by the driver,
additional capabilities might be supported by userspace; these are
the 802.11 extended capabilities (<span class="quote">“<span class="quote">Extended Capabilities element</span>”</span>)
and are in the same format as in the information element. See
802.11-2012 8.4.2.29 for the defined fields.
      </p></dd><dt><span class="term">extended_capabilities_mask</span></dt><dd><p>
mask of the valid values
      </p></dd><dt><span class="term">extended_capabilities_len</span></dt><dd><p>
length of the extended capabilities
      </p></dd><dt><span class="term">privid</span></dt><dd><p>
a pointer that drivers can use to identify if an arbitrary
wiphy is theirs, e.g. in global notifiers
      </p></dd><dt><span class="term">bands[IEEE80211_NUM_BANDS]</span></dt><dd><p>
information about bands/channels supported by this device
      </p></dd><dt><span class="term">reg_notifier</span></dt><dd><p>
the driver's regulatory notification callback,
note that if your driver uses <code class="function">wiphy_apply_custom_regulatory</code>
the reg_notifier's request can be passed as NULL
      </p></dd><dt><span class="term">regd</span></dt><dd><p>
the driver's regulatory domain, if one was requested via
the <code class="function">regulatory_hint</code> API. This can be used by the driver
on the <code class="function">reg_notifier</code> if it chooses to ignore future
regulatory domain changes caused by other drivers.
      </p></dd><dt><span class="term">dev</span></dt><dd><p>
(virtual) struct device for this wiphy
      </p></dd><dt><span class="term">registered</span></dt><dd><p>
helps synchronize suspend/resume with wiphy unregister
      </p></dd><dt><span class="term">debugfsdir</span></dt><dd><p>
debugfs directory used for this wiphy, will be renamed
automatically on wiphy renames
      </p></dd><dt><span class="term">ht_capa_mod_mask</span></dt><dd><p>
Specify what ht_cap values can be over-ridden.
If null, then none can be over-ridden.
      </p></dd><dt><span class="term">vht_capa_mod_mask</span></dt><dd><p>
Specify what VHT capabilities can be over-ridden.
If null, then none can be over-ridden.
      </p></dd><dt><span class="term">_net</span></dt><dd><p>
the network namespace this wiphy currently lives in
      </p></dd><dt><span class="term">wext</span></dt><dd><p>
wireless extension handlers
      </p></dd><dt><span class="term">coalesce</span></dt><dd><p>
packet coalescing support information
      </p></dd><dt><span class="term">priv[0]</span></dt><dd><p>
driver private data (sized according to <code class="function">wiphy_new</code> parameter)
      </p></dd></dl></div></div><div class="refsect1" title="four bits are variable then set it to 00"><a id="idp5096288"></a><h2>four bits are variable then set it to 00</h2><p>
   ...:00:0f. The actual
   variable bits shall be determined by the interfaces added, with
   interfaces not matching the mask being rejected to be brought up.
</p></div></div><div class="refentry" title="struct wireless_dev"><div class="refentry.separator"><hr></div><a id="API-struct-wireless-dev"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct wireless_dev — 
  wireless device state
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct wireless_dev {
  struct wiphy * wiphy;
  enum nl80211_iftype iftype;
  struct list_head list;
  struct net_device * netdev;
  u32 identifier;
  struct list_head mgmt_registrations;
  spinlock_t mgmt_registrations_lock;
  struct mutex mtx;
  bool use_4addr;
  bool p2p_started;
  u8 address[ETH_ALEN];
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len;
  u8 mesh_id_len;
  u8 mesh_id_up_len;
  struct cfg80211_conn * conn;
  struct cfg80211_cached_keys * connect_keys;
  struct list_head event_list;
  spinlock_t event_lock;
  struct cfg80211_internal_bss * current_bss;
  struct cfg80211_chan_def preset_chandef;
  struct ieee80211_channel * channel;
  bool ibss_fixed;
  bool ps;
  int ps_timeout;
  int beacon_interval;
  u32 ap_unexpected_nlportid;
  bool cac_started;
  unsigned long cac_start_time;
#ifdef CONFIG_CFG80211_WEXT
  struct wext;
#endif
};  </pre></div><div class="refsect1" title="Members"><a id="idp5105344"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">wiphy</span></dt><dd><p>
pointer to hardware description
      </p></dd><dt><span class="term">iftype</span></dt><dd><p>
interface type
      </p></dd><dt><span class="term">list</span></dt><dd><p>
(private) Used to collect the interfaces
      </p></dd><dt><span class="term">netdev</span></dt><dd><p>
(private) Used to reference back to the netdev, may be <code class="constant">NULL</code>
      </p></dd><dt><span class="term">identifier</span></dt><dd><p>
(private) Identifier used in nl80211 to identify this
wireless device if it has no netdev
      </p></dd><dt><span class="term">mgmt_registrations</span></dt><dd><p>
list of registrations for management frames
      </p></dd><dt><span class="term">mgmt_registrations_lock</span></dt><dd><p>
lock for the list
      </p></dd><dt><span class="term">mtx</span></dt><dd><p>
mutex used to lock data in this struct, may be used by drivers
and some API functions require it held
      </p></dd><dt><span class="term">use_4addr</span></dt><dd><p>
indicates 4addr mode is used on this interface, must be
set by driver (if supported) on add_interface BEFORE registering the
netdev and may otherwise be used by driver read-only, will be update
by cfg80211 on change_interface
      </p></dd><dt><span class="term">p2p_started</span></dt><dd><p>
true if this is a P2P Device that has been started
      </p></dd><dt><span class="term">address[ETH_ALEN]</span></dt><dd><p>
The address for this device, valid only if <em class="parameter"><code>netdev</code></em> is <code class="constant">NULL</code>
      </p></dd><dt><span class="term">ssid[IEEE80211_MAX_SSID_LEN]</span></dt><dd><p>
(private) Used by the internal configuration code
      </p></dd><dt><span class="term">ssid_len</span></dt><dd><p>
(private) Used by the internal configuration code
      </p></dd><dt><span class="term">mesh_id_len</span></dt><dd><p>
(private) Used by the internal configuration code
      </p></dd><dt><span class="term">mesh_id_up_len</span></dt><dd><p>
(private) Used by the internal configuration code
      </p></dd><dt><span class="term">conn</span></dt><dd><p>
(private) cfg80211 software SME connection state machine data
      </p></dd><dt><span class="term">connect_keys</span></dt><dd><p>
(private) keys to set after connection is established
      </p></dd><dt><span class="term">event_list</span></dt><dd><p>
(private) list for internal event processing
      </p></dd><dt><span class="term">event_lock</span></dt><dd><p>
(private) lock for event list
      </p></dd><dt><span class="term">current_bss</span></dt><dd><p>
(private) Used by the internal configuration code
      </p></dd><dt><span class="term">preset_chandef</span></dt><dd><p>
(private) Used by the internal configuration code to
track the channel to be used for AP later
      </p></dd><dt><span class="term">channel</span></dt><dd><p>
(private) Used by the internal configuration code to track
the user-set AP, monitor and WDS channel
      </p></dd><dt><span class="term">ibss_fixed</span></dt><dd><p>
(private) IBSS is using fixed BSSID
      </p></dd><dt><span class="term">ps</span></dt><dd><p>
powersave mode is enabled
      </p></dd><dt><span class="term">ps_timeout</span></dt><dd><p>
dynamic powersave timeout
      </p></dd><dt><span class="term">beacon_interval</span></dt><dd><p>
beacon interval used on this device for transmitting
beacons, 0 when not valid
      </p></dd><dt><span class="term">ap_unexpected_nlportid</span></dt><dd><p>
(private) netlink port ID of application
registered for unexpected class 3 frames (AP mode)
      </p></dd><dt><span class="term">cac_started</span></dt><dd><p>
true if DFS channel availability check has been started
      </p></dd><dt><span class="term">cac_start_time</span></dt><dd><p>
timestamp (jiffies) when the dfs state was entered.
      </p></dd><dt><span class="term">wext</span></dt><dd><p>
(private) Used by the internal wireless extensions compat code
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5148192"></a><h2>Description</h2><p>
   </p><p>

   For netdevs, this structure must be allocated by the driver
   that uses the ieee80211_ptr field in struct net_device (this
   is intentional so it can be allocated along with the netdev.)
   It need not be registered then as netdev registration will
   be intercepted by cfg80211 to see the new wireless device.
   </p><p>

   For non-netdev uses, it must also be allocated by the driver
   in response to the cfg80211 callbacks that require it, as
   there's no netdev registration in that case it may not be
   allocated outside of callback operations that return it.
</p></div></div><div class="refentry" title="wiphy_new"><div class="refentry.separator"><hr></div><a id="API-wiphy-new"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_new — 
  create a new wiphy for use with cfg80211
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct wiphy * <strong>fsfuncwiphy_new </strong>(</code></td><td><var class="pdparam">ops</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">sizeof_priv</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>const struct cfg80211_ops * <var class="pdparam">ops</var></code>;<br><code>int <var class="pdparam">sizeof_priv</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5159840"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>ops</code></em></span></dt><dd><p>
     The configuration operations for this device
    </p></dd><dt><span class="term"><em class="parameter"><code>sizeof_priv</code></em></span></dt><dd><p>
     The size of the private area to allocate
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5164800"></a><h2>Description</h2><p>
   Create a new wiphy and associate the given operations with it.
   <em class="parameter"><code>sizeof_priv</code></em> bytes are allocated for private use.
</p></div><div class="refsect1" title="Return"><a id="idp5166656"></a><h2>Return</h2><p>
   A pointer to the new wiphy. This pointer must be
   assigned to each netdev's ieee80211_ptr for proper operation.
</p></div></div><div class="refentry" title="wiphy_register"><div class="refentry.separator"><hr></div><a id="API-wiphy-register"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_register — 
  register a wiphy with cfg80211
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncwiphy_register </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5176432"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     The wiphy to register.
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp5179488"></a><h2>Return</h2><p>
   A non-negative wiphy index or a negative error code.
</p></div></div><div class="refentry" title="wiphy_unregister"><div class="refentry.separator"><hr></div><a id="API-wiphy-unregister"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_unregister — 
  deregister a wiphy from cfg80211
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncwiphy_unregister </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5189216"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     The wiphy to unregister.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5192272"></a><h2>Description</h2><p>
   After this call, no more requests can be made with this priv
   pointer, but the call may sleep to wait for an outstanding
   request that is being handled.
</p></div></div><div class="refentry" title="wiphy_free"><div class="refentry.separator"><hr></div><a id="API-wiphy-free"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_free — 
  free wiphy
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncwiphy_free </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5202096"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     The wiphy to free
    </p></dd></dl></div></div></div><div class="refentry" title="wiphy_name"><div class="refentry.separator"><hr></div><a id="API-wiphy-name"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_name — 
  get wiphy name
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">const char * <strong>fsfuncwiphy_name </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>const struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5213648"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     The wiphy whose name to return
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp5216704"></a><h2>Return</h2><p>
   The name of <em class="parameter"><code>wiphy</code></em>.
</p></div></div><div class="refentry" title="wiphy_dev"><div class="refentry.separator"><hr></div><a id="API-wiphy-dev"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_dev — 
  get wiphy dev pointer
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct device * <strong>fsfuncwiphy_dev </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5226976"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     The wiphy whose device struct to look up
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp5230032"></a><h2>Return</h2><p>
   The dev of <em class="parameter"><code>wiphy</code></em>.
</p></div></div><div class="refentry" title="wiphy_priv"><div class="refentry.separator"><hr></div><a id="API-wiphy-priv"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_priv — 
  return priv from wiphy
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void * <strong>fsfuncwiphy_priv </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5240304"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy whose priv pointer to return
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp5243360"></a><h2>Return</h2><p>
   The priv of <em class="parameter"><code>wiphy</code></em>.
</p></div></div><div class="refentry" title="priv_to_wiphy"><div class="refentry.separator"><hr></div><a id="API-priv-to-wiphy"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>priv_to_wiphy — 
  return the wiphy containing the priv
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct wiphy * <strong>fsfuncpriv_to_wiphy </strong>(</code></td><td><var class="pdparam">priv</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>void * <var class="pdparam">priv</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5253632"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>priv</code></em></span></dt><dd><p>
     a pointer previously returned by wiphy_priv
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp5256688"></a><h2>Return</h2><p>
   The wiphy of <em class="parameter"><code>priv</code></em>.
</p></div></div><div class="refentry" title="set_wiphy_dev"><div class="refentry.separator"><hr></div><a id="API-set-wiphy-dev"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>set_wiphy_dev — 
  set device pointer for wiphy
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncset_wiphy_dev </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">dev</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>struct device * <var class="pdparam">dev</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5267840"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     The wiphy whose device to bind
    </p></dd><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     The device to parent it to
    </p></dd></dl></div></div></div><div class="refentry" title="wdev_priv"><div class="refentry.separator"><hr></div><a id="API-wdev-priv"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wdev_priv — 
  return wiphy priv from wireless_dev
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void * <strong>fsfuncwdev_priv </strong>(</code></td><td><var class="pdparam">wdev</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wireless_dev * <var class="pdparam">wdev</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp5281296"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wdev</code></em></span></dt><dd><p>
     The wireless device whose wiphy's priv pointer to return
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp5284432"></a><h2>Return</h2><p>
   The wiphy priv of <em class="parameter"><code>wdev</code></em>.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Actions and configuration"><div class="titlepage"><div><div><h2 class="title"><a id="idp5286464"></a>Chapter&nbsp;2.&nbsp;Actions and configuration</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ops"><span>struct cfg80211_ops</span></a></span><span class="refpurpose"> — 
  backend description for wireless configuration
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-vif-params"><span>struct vif_params</span></a></span><span class="refpurpose"> — 
  describes virtual interface parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-key-params"><span>struct key_params</span></a></span><span class="refpurpose"> — 
  key information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-survey-info-flags"><span>enum survey_info_flags</span></a></span><span class="refpurpose"> — 
  survey information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-survey-info"><span>struct survey_info</span></a></span><span class="refpurpose"> — 
  channel survey response
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-beacon-data"><span>struct cfg80211_beacon_data</span></a></span><span class="refpurpose"> — 
  beacon data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ap-settings"><span>struct cfg80211_ap_settings</span></a></span><span class="refpurpose"> — 
  AP configuration
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-station-parameters"><span>struct station_parameters</span></a></span><span class="refpurpose"> — 
  station parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-station-info-flags"><span>enum station_info_flags</span></a></span><span class="refpurpose"> — 
  station information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-rate-info-flags"><span>enum rate_info_flags</span></a></span><span class="refpurpose"> — 
  bitrate info flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-rate-info"><span>struct rate_info</span></a></span><span class="refpurpose"> — 
  bitrate information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-station-info"><span>struct station_info</span></a></span><span class="refpurpose"> — 
  station information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-monitor-flags"><span>enum monitor_flags</span></a></span><span class="refpurpose"> — 
  monitor flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-mpath-info-flags"><span>enum mpath_info_flags</span></a></span><span class="refpurpose"> — 
  mesh path information flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-mpath-info"><span>struct mpath_info</span></a></span><span class="refpurpose"> — 
  mesh path information
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-bss-parameters"><span>struct bss_parameters</span></a></span><span class="refpurpose"> — 
  BSS parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-txq-params"><span>struct ieee80211_txq_params</span></a></span><span class="refpurpose"> — 
  TX queue parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-crypto-settings"><span>struct cfg80211_crypto_settings</span></a></span><span class="refpurpose"> — 
  Crypto settings
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-auth-request"><span>struct cfg80211_auth_request</span></a></span><span class="refpurpose"> — 
  Authentication request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-assoc-request"><span>struct cfg80211_assoc_request</span></a></span><span class="refpurpose"> — 
  (Re)Association request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-deauth-request"><span>struct cfg80211_deauth_request</span></a></span><span class="refpurpose"> — 
  Deauthentication request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-disassoc-request"><span>struct cfg80211_disassoc_request</span></a></span><span class="refpurpose"> — 
  Disassociation request data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ibss-params"><span>struct cfg80211_ibss_params</span></a></span><span class="refpurpose"> — 
  IBSS parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-connect-params"><span>struct cfg80211_connect_params</span></a></span><span class="refpurpose"> — 
  Connection parameters
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-pmksa"><span>struct cfg80211_pmksa</span></a></span><span class="refpurpose"> — 
  PMK Security Association
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-mlme-mgmt"><span>cfg80211_rx_mlme_mgmt</span></a></span><span class="refpurpose"> — 
  notification of processed MLME management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-auth-timeout"><span>cfg80211_auth_timeout</span></a></span><span class="refpurpose"> — 
  notification of timed out authentication
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-assoc-resp"><span>cfg80211_rx_assoc_resp</span></a></span><span class="refpurpose"> — 
  notification of processed association response
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-assoc-timeout"><span>cfg80211_assoc_timeout</span></a></span><span class="refpurpose"> — 
  notification of timed out association
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-tx-mlme-mgmt"><span>cfg80211_tx_mlme_mgmt</span></a></span><span class="refpurpose"> — 
  notification of transmitted deauth/disassoc frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-ibss-joined"><span>cfg80211_ibss_joined</span></a></span><span class="refpurpose"> — 
  notify cfg80211 that device joined an IBSS
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-connect-result"><span>cfg80211_connect_result</span></a></span><span class="refpurpose"> — 
  notify cfg80211 of connection result
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-roamed"><span>cfg80211_roamed</span></a></span><span class="refpurpose"> — 
  notify cfg80211 of roaming
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-disconnected"><span>cfg80211_disconnected</span></a></span><span class="refpurpose"> — 
  notify cfg80211 that connection was dropped
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-ready-on-channel"><span>cfg80211_ready_on_channel</span></a></span><span class="refpurpose"> — 
  notification of remain_on_channel start
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-remain-on-channel-expired"><span>cfg80211_remain_on_channel_expired</span></a></span><span class="refpurpose"> — 
  remain_on_channel duration expired
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-new-sta"><span>cfg80211_new_sta</span></a></span><span class="refpurpose"> — 
  notify userspace about station
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-rx-mgmt"><span>cfg80211_rx_mgmt</span></a></span><span class="refpurpose"> — 
  notification of received, unprocessed management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-mgmt-tx-status"><span>cfg80211_mgmt_tx_status</span></a></span><span class="refpurpose"> — 
  notification of TX status for management frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-cqm-rssi-notify"><span>cfg80211_cqm_rssi_notify</span></a></span><span class="refpurpose"> — 
  connection quality monitoring rssi event
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-cqm-pktloss-notify"><span>cfg80211_cqm_pktloss_notify</span></a></span><span class="refpurpose"> — 
  notify userspace about packetloss to peer
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-michael-mic-failure"><span>cfg80211_michael_mic_failure</span></a></span><span class="refpurpose"> — 
  notification of Michael MIC failure (TKIP)
 </span></dt></dl></div><p>
   </p><p>
   Each wireless device and each virtual interface offer a set of configuration
   operations and other actions that are invoked by userspace. Each of these
   actions is described in the operations structure, and the parameters these
   operations use are described separately.
   </p><p>
   Additionally, some operations are asynchronous and expect to get status
   information via some functions that drivers need to call.
   </p><p>
   Scanning and BSS list handling with its associated functionality is described
   in a separate chapter.
</p><div class="refentry" title="struct cfg80211_ops"><a id="API-struct-cfg80211-ops"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_ops — 
  backend description for wireless configuration
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_ops {
  int (* suspend) (struct wiphy *wiphy, struct cfg80211_wowlan *wow);
  int (* resume) (struct wiphy *wiphy);
  void (* set_wakeup) (struct wiphy *wiphy, bool enabled);
  struct wireless_dev * (* add_virtual_intf) (struct wiphy *wiphy,const char *name,enum nl80211_iftype type,u32 *flags,struct vif_params *params);
  int (* del_virtual_intf) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* change_virtual_intf) (struct wiphy *wiphy,struct net_device *dev,enum nl80211_iftype type, u32 *flags,struct vif_params *params);
  int (* add_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,struct key_params *params);
  int (* get_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr,void *cookie,void (*callback);
  int (* del_key) (struct wiphy *wiphy, struct net_device *netdev,u8 key_index, bool pairwise, const u8 *mac_addr);
  int (* set_default_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index, bool unicast, bool multicast);
  int (* set_default_mgmt_key) (struct wiphy *wiphy,struct net_device *netdev,u8 key_index);
  int (* start_ap) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ap_settings *settings);
  int (* change_beacon) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_beacon_data *info);
  int (* stop_ap) (struct wiphy *wiphy, struct net_device *dev);
  int (* add_station) (struct wiphy *wiphy, struct net_device *dev,u8 *mac, struct station_parameters *params);
  int (* del_station) (struct wiphy *wiphy, struct net_device *dev,u8 *mac);
  int (* change_station) (struct wiphy *wiphy, struct net_device *dev,u8 *mac, struct station_parameters *params);
  int (* get_station) (struct wiphy *wiphy, struct net_device *dev,u8 *mac, struct station_info *sinfo);
  int (* dump_station) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *mac, struct station_info *sinfo);
  int (* add_mpath) (struct wiphy *wiphy, struct net_device *dev,u8 *dst, u8 *next_hop);
  int (* del_mpath) (struct wiphy *wiphy, struct net_device *dev,u8 *dst);
  int (* change_mpath) (struct wiphy *wiphy, struct net_device *dev,u8 *dst, u8 *next_hop);
  int (* get_mpath) (struct wiphy *wiphy, struct net_device *dev,u8 *dst, u8 *next_hop,struct mpath_info *pinfo);
  int (* dump_mpath) (struct wiphy *wiphy, struct net_device *dev,int idx, u8 *dst, u8 *next_hop,struct mpath_info *pinfo);
  int (* get_mesh_config) (struct wiphy *wiphy,struct net_device *dev,struct mesh_config *conf);
  int (* update_mesh_config) (struct wiphy *wiphy,struct net_device *dev, u32 mask,const struct mesh_config *nconf);
  int (* join_mesh) (struct wiphy *wiphy, struct net_device *dev,const struct mesh_config *conf,const struct mesh_setup *setup);
  int (* leave_mesh) (struct wiphy *wiphy, struct net_device *dev);
  int (* change_bss) (struct wiphy *wiphy, struct net_device *dev,struct bss_parameters *params);
  int (* set_txq_params) (struct wiphy *wiphy, struct net_device *dev,struct ieee80211_txq_params *params);
  int (* libertas_set_mesh_channel) (struct wiphy *wiphy,struct net_device *dev,struct ieee80211_channel *chan);
  int (* set_monitor_channel) (struct wiphy *wiphy,struct cfg80211_chan_def *chandef);
  int (* scan) (struct wiphy *wiphy,struct cfg80211_scan_request *request);
  int (* auth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_auth_request *req);
  int (* assoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_assoc_request *req);
  int (* deauth) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_deauth_request *req);
  int (* disassoc) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_disassoc_request *req);
  int (* connect) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_connect_params *sme);
  int (* disconnect) (struct wiphy *wiphy, struct net_device *dev,u16 reason_code);
  int (* join_ibss) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_ibss_params *params);
  int (* leave_ibss) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_mcast_rate) (struct wiphy *wiphy, struct net_device *dev,int rate[IEEE80211_NUM_BANDS]);
  int (* set_wiphy_params) (struct wiphy *wiphy, u32 changed);
  int (* set_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,enum nl80211_tx_power_setting type, int mbm);
  int (* get_tx_power) (struct wiphy *wiphy, struct wireless_dev *wdev,int *dbm);
  int (* set_wds_peer) (struct wiphy *wiphy, struct net_device *dev,const u8 *addr);
  void (* rfkill_poll) (struct wiphy *wiphy);
#ifdef CONFIG_NL80211_TESTMODE
  int (* testmode_cmd) (struct wiphy *wiphy, struct wireless_dev *wdev,void *data, int len);
  int (* testmode_dump) (struct wiphy *wiphy, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
#endif
  int (* set_bitrate_mask) (struct wiphy *wiphy,struct net_device *dev,const u8 *peer,const struct cfg80211_bitrate_mask *mask);
  int (* dump_survey) (struct wiphy *wiphy, struct net_device *netdev,int idx, struct survey_info *info);
  int (* set_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* del_pmksa) (struct wiphy *wiphy, struct net_device *netdev,struct cfg80211_pmksa *pmksa);
  int (* flush_pmksa) (struct wiphy *wiphy, struct net_device *netdev);
  int (* remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct ieee80211_channel *chan,unsigned int duration,u64 *cookie);
  int (* cancel_remain_on_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* mgmt_tx) (struct wiphy *wiphy, struct wireless_dev *wdev,struct ieee80211_channel *chan, bool offchan,unsigned int wait, const u8 *buf, size_t len,bool no_cck, bool dont_wait_for_ack, u64 *cookie);
  int (* mgmt_tx_cancel_wait) (struct wiphy *wiphy,struct wireless_dev *wdev,u64 cookie);
  int (* set_power_mgmt) (struct wiphy *wiphy, struct net_device *dev,bool enabled, int timeout);
  int (* set_cqm_rssi_config) (struct wiphy *wiphy,struct net_device *dev,s32 rssi_thold, u32 rssi_hyst);
  int (* set_cqm_txe_config) (struct wiphy *wiphy,struct net_device *dev,u32 rate, u32 pkts, u32 intvl);
  void (* mgmt_frame_register) (struct wiphy *wiphy,struct wireless_dev *wdev,u16 frame_type, bool reg);
  int (* set_antenna) (struct wiphy *wiphy, u32 tx_ant, u32 rx_ant);
  int (* get_antenna) (struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant);
  int (* set_ringparam) (struct wiphy *wiphy, u32 tx, u32 rx);
  void (* get_ringparam) (struct wiphy *wiphy,u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
  int (* sched_scan_start) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_sched_scan_request *request);
  int (* sched_scan_stop) (struct wiphy *wiphy, struct net_device *dev);
  int (* set_rekey_data) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_gtk_rekey_data *data);
  int (* tdls_mgmt) (struct wiphy *wiphy, struct net_device *dev,u8 *peer, u8 action_code,  u8 dialog_token,u16 status_code, const u8 *buf, size_t len);
  int (* tdls_oper) (struct wiphy *wiphy, struct net_device *dev,u8 *peer, enum nl80211_tdls_operation oper);
  int (* probe_client) (struct wiphy *wiphy, struct net_device *dev,const u8 *peer, u64 *cookie);
  int (* set_noack_map) (struct wiphy *wiphy,struct net_device *dev,u16 noack_map);
  int (* get_et_sset_count) (struct wiphy *wiphy,struct net_device *dev, int sset);
  void (* get_et_stats) (struct wiphy *wiphy, struct net_device *dev,struct ethtool_stats *stats, u64 *data);
  void (* get_et_strings) (struct wiphy *wiphy, struct net_device *dev,u32 sset, u8 *data);
  int (* get_channel) (struct wiphy *wiphy,struct wireless_dev *wdev,struct cfg80211_chan_def *chandef);
  int (* start_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  void (* stop_p2p_device) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_mac_acl) (struct wiphy *wiphy, struct net_device *dev,const struct cfg80211_acl_data *params);
  int (* start_radar_detection) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_chan_def *chandef);
  int (* update_ft_ies) (struct wiphy *wiphy, struct net_device *dev,struct cfg80211_update_ft_ies_params *ftie);
  int (* crit_proto_start) (struct wiphy *wiphy,struct wireless_dev *wdev,enum nl80211_crit_proto_id protocol,u16 duration);
  void (* crit_proto_stop) (struct wiphy *wiphy,struct wireless_dev *wdev);
  int (* set_coalesce) (struct wiphy *wiphy,struct cfg80211_coalesce *coalesce);
  int (* channel_switch) (struct wiphy *wiphy,struct net_device *dev,struct cfg80211_csa_settings *params);
};  </pre></div><div class="refsect1" title="Members"><a id="idp5310336"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">suspend</span></dt><dd><p>
wiphy device needs to be suspended. The variable <em class="parameter"><code>wow</code></em> will
be <code class="constant">NULL</code> or contain the enabled Wake-on-Wireless triggers that are
configured for the device.
      </p></dd><dt><span class="term">resume</span></dt><dd><p>
wiphy device needs to be resumed
      </p></dd><dt><span class="term">set_wakeup</span></dt><dd><p>
Called when WoWLAN is enabled/disabled, use this callback
to call <code class="function">device_set_wakeup_enable</code> to enable/disable wakeup from
the device.
      </p></dd><dt><span class="term">add_virtual_intf</span></dt><dd><p>
create a new virtual interface with the given name,
must set the struct wireless_dev's iftype. Beware: You must create
the new netdev in the wiphy's network namespace! Returns the struct
wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must
also set the address member in the wdev.
      </p></dd><dt><span class="term">del_virtual_intf</span></dt><dd><p>
remove the virtual interface
      </p></dd><dt><span class="term">change_virtual_intf</span></dt><dd><p>
change type/configuration of virtual interface,
keep the struct wireless_dev's iftype updated.
      </p></dd><dt><span class="term">add_key</span></dt><dd><p>
add a key with the given parameters. <em class="parameter"><code>mac_addr</code></em> will be <code class="constant">NULL</code>
when adding a group key.
      </p></dd><dt><span class="term">get_key</span></dt><dd><p>
get information about the key with the given parameters.
<em class="parameter"><code>mac_addr</code></em> will be <code class="constant">NULL</code> when requesting information for a group
key. All pointers given to the <em class="parameter"><code>callback</code></em> function need not be valid
after it returns. This function should return an error if it is
not possible to retrieve the key, -ENOENT if it doesn't exist.
      </p></dd><dt><span class="term">del_key</span></dt><dd><p>
remove a key given the <em class="parameter"><code>mac_addr</code></em> (<code class="constant">NULL</code> for a group key)
and <em class="parameter"><code>key_index</code></em>, return -ENOENT if the key doesn't exist.
      </p></dd><dt><span class="term">set_default_key</span></dt><dd><p>
set the default key on an interface
      </p></dd><dt><span class="term">set_default_mgmt_key</span></dt><dd><p>
set the default management frame key on an interface
      </p></dd><dt><span class="term">start_ap</span></dt><dd><p>
Start acting in AP mode defined by the parameters.
      </p></dd><dt><span class="term">change_beacon</span></dt><dd><p>
Change the beacon parameters for an access point mode
interface. This should reject the call when AP mode wasn't started.
      </p></dd><dt><span class="term">stop_ap</span></dt><dd><p>
Stop being an AP, including stopping beaconing.
      </p></dd><dt><span class="term">add_station</span></dt><dd><p>
Add a new station.
      </p></dd><dt><span class="term">del_station</span></dt><dd><p>
Remove a station; <em class="parameter"><code>mac</code></em> may be NULL to remove all stations.
      </p></dd><dt><span class="term">change_station</span></dt><dd><p>
Modify a given station. Note that flags changes are not much
validated in cfg80211, in particular the auth/assoc/authorized flags
might come to the driver in invalid combinations -- make sure to check
them, also against the existing state! Drivers must call
<code class="function">cfg80211_check_station_change</code> to validate the information.
      </p></dd><dt><span class="term">get_station</span></dt><dd><p>
get station information for the station identified by <em class="parameter"><code>mac</code></em>
      </p></dd><dt><span class="term">dump_station</span></dt><dd><p>
dump station callback -- resume dump at index <em class="parameter"><code>idx</code></em>
      </p></dd><dt><span class="term">add_mpath</span></dt><dd><p>
add a fixed mesh path
      </p></dd><dt><span class="term">del_mpath</span></dt><dd><p>
delete a given mesh path
      </p></dd><dt><span class="term">change_mpath</span></dt><dd><p>
change a given mesh path
      </p></dd><dt><span class="term">get_mpath</span></dt><dd><p>
get a mesh path for the given parameters
      </p></dd><dt><span class="term">dump_mpath</span></dt><dd><p>
dump mesh path callback -- resume dump at index <em class="parameter"><code>idx</code></em>
      </p></dd><dt><span class="term">get_mesh_config</span></dt><dd><p>
Get the current mesh configuration
      </p></dd><dt><span class="term">update_mesh_config</span></dt><dd><p>
Update mesh parameters on a running mesh.
The mask is a bitfield which tells us which parameters to
set, and which to leave alone.
      </p></dd><dt><span class="term">join_mesh</span></dt><dd><p>
join the mesh network with the specified parameters
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">leave_mesh</span></dt><dd><p>
leave the current mesh network
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">change_bss</span></dt><dd><p>
Modify parameters for a given BSS.
      </p></dd><dt><span class="term">set_txq_params</span></dt><dd><p>
Set TX queue parameters
      </p></dd><dt><span class="term">libertas_set_mesh_channel</span></dt><dd><p>
Only for backward compatibility for libertas,
as it doesn't implement join_mesh and needs to set the channel to
join the mesh instead.
      </p></dd><dt><span class="term">set_monitor_channel</span></dt><dd><p>
Set the monitor mode channel for the device. If other
interfaces are active this callback should reject the configuration.
If no interfaces are active or the device is down, the channel should
be stored for when a monitor interface becomes active.
      </p></dd><dt><span class="term">scan</span></dt><dd><p>
Request to do a scan. If returning zero, the scan request is given
the driver, and will be valid until passed to <code class="function">cfg80211_scan_done</code>.
For scan results, call <code class="function">cfg80211_inform_bss</code>; you can call this outside
the scan/scan_done bracket too.
      </p></dd><dt><span class="term">auth</span></dt><dd><p>
Request to authenticate with the specified peer
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">assoc</span></dt><dd><p>
Request to (re)associate with the specified peer
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">deauth</span></dt><dd><p>
Request to deauthenticate from the specified peer
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">disassoc</span></dt><dd><p>
Request to disassociate from the specified peer
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">connect</span></dt><dd><p>
Connect to the ESS with the specified parameters. When connected,
call <code class="function">cfg80211_connect_result</code> with status code <code class="constant">WLAN_STATUS_SUCCESS</code>.
If the connection fails for some reason, call <code class="function">cfg80211_connect_result</code>
with the status from the AP.
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">disconnect</span></dt><dd><p>
Disconnect from the BSS/ESS.
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">join_ibss</span></dt><dd><p>
Join the specified IBSS (or create if necessary). Once done, call
<code class="function">cfg80211_ibss_joined</code>, also call that function when changing BSSID due
to a merge.
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">leave_ibss</span></dt><dd><p>
Leave the IBSS.
(invoked with the wireless_dev mutex held)
      </p></dd><dt><span class="term">set_mcast_rate</span></dt><dd><p>
Set the specified multicast rate (only if vif is in ADHOC or
MESH mode)
      </p></dd><dt><span class="term">set_wiphy_params</span></dt><dd><p>
Notify that wiphy parameters have changed;
<em class="parameter"><code>changed</code></em> bitfield (see <span class="structname">enum</span> wiphy_params_flags) describes which values
have changed. The actual parameter values are available in
struct wiphy. If returning an error, no value should be changed.
      </p></dd><dt><span class="term">set_tx_power</span></dt><dd><p>
set the transmit power according to the parameters,
the power passed is in mBm, to get dBm use <code class="function">MBM_TO_DBM</code>. The
wdev may be <code class="constant">NULL</code> if power was set for the wiphy, and will
always be <code class="constant">NULL</code> unless the driver supports per-vif TX power
(as advertised by the nl80211 feature flag.)
      </p></dd><dt><span class="term">get_tx_power</span></dt><dd><p>
store the current TX power into the dbm variable;
return 0 if successful
      </p></dd><dt><span class="term">set_wds_peer</span></dt><dd><p>
set the WDS peer for a WDS interface
      </p></dd><dt><span class="term">rfkill_poll</span></dt><dd><p>
polls the hw rfkill line, use cfg80211 reporting
functions to adjust rfkill hw state
      </p></dd><dt><span class="term">testmode_cmd</span></dt><dd><p>
run a test mode command; <em class="parameter"><code>wdev</code></em> may be <code class="constant">NULL</code>
      </p></dd><dt><span class="term">testmode_dump</span></dt><dd><p>
Implement a test mode dump. The cb-&gt;args[2] and up may be
used by the function, but 0 and 1 must not be touched. Additionally,
return error codes other than -ENOBUFS and -ENOENT will terminate the
dump and return to userspace with an error, so be careful. If any data
was passed in from userspace then the data/len arguments will be present
and point to the data contained in <code class="constant">NL80211_ATTR_TESTDATA</code>.
      </p></dd><dt><span class="term">set_bitrate_mask</span></dt><dd><p>
set the bitrate mask configuration
      </p></dd><dt><span class="term">dump_survey</span></dt><dd><p>
get site survey information.
      </p></dd><dt><span class="term">set_pmksa</span></dt><dd><p>
Cache a PMKID for a BSSID. This is mostly useful for fullmac
devices running firmwares capable of generating the (re) association
RSN IE. It allows for faster roaming between WPA2 BSSIDs.
      </p></dd><dt><span class="term">del_pmksa</span></dt><dd><p>
Delete a cached PMKID.
      </p></dd><dt><span class="term">flush_pmksa</span></dt><dd><p>
Flush all cached PMKIDs.
      </p></dd><dt><span class="term">remain_on_channel</span></dt><dd><p>
Request the driver to remain awake on the specified
channel for the specified duration to complete an off-channel
operation (e.g., public action frame exchange). When the driver is
ready on the requested channel, it must indicate this with an event
notification by calling <code class="function">cfg80211_ready_on_channel</code>.
      </p></dd><dt><span class="term">cancel_remain_on_channel</span></dt><dd><p>
Cancel an on-going remain-on-channel operation.
This allows the operation to be terminated prior to timeout based on
the duration value.
      </p></dd><dt><span class="term">mgmt_tx</span></dt><dd><p>
Transmit a management frame.
      </p></dd><dt><span class="term">mgmt_tx_cancel_wait</span></dt><dd><p>
Cancel the wait time from transmitting a management
frame on another channel
      </p></dd><dt><span class="term">set_power_mgmt</span></dt><dd><p>
Configure WLAN power management. A timeout value of -1
allows the driver to adjust the dynamic ps timeout value.
      </p></dd><dt><span class="term">set_cqm_rssi_config</span></dt><dd><p>
Configure connection quality monitor RSSI threshold.
      </p></dd><dt><span class="term">set_cqm_txe_config</span></dt><dd><p>
Configure connection quality monitor TX error
thresholds.
      </p></dd><dt><span class="term">mgmt_frame_register</span></dt><dd><p>
Notify driver that a management frame type was
registered. Note that this callback may not sleep, and cannot run
concurrently with itself.
      </p></dd><dt><span class="term">set_antenna</span></dt><dd><p>
Set antenna configuration (tx_ant, rx_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h <em class="parameter"><code>NL80211_ATTR_WIPHY_ANTENNA_TX</code></em>).
      </p></dd><dt><span class="term">get_antenna</span></dt><dd><p>
Get current antenna configuration from device (tx_ant, rx_ant).
      </p></dd><dt><span class="term">set_ringparam</span></dt><dd><p>
Set tx and rx ring sizes.
      </p></dd><dt><span class="term">get_ringparam</span></dt><dd><p>
Get tx and rx ring current and maximum sizes.
      </p></dd><dt><span class="term">sched_scan_start</span></dt><dd><p>
Tell the driver to start a scheduled scan.
      </p></dd><dt><span class="term">sched_scan_stop</span></dt><dd><p>
Tell the driver to stop an ongoing scheduled scan.
      </p></dd><dt><span class="term">set_rekey_data</span></dt><dd><p>
give the data necessary for GTK rekeying to the driver
      </p></dd><dt><span class="term">tdls_mgmt</span></dt><dd><p>
Transmit a TDLS management frame.
      </p></dd><dt><span class="term">tdls_oper</span></dt><dd><p>
Perform a high-level TDLS operation (e.g. TDLS link setup).
      </p></dd><dt><span class="term">probe_client</span></dt><dd><p>
probe an associated client, must return a cookie that it
later passes to <code class="function">cfg80211_probe_status</code>.
      </p></dd><dt><span class="term">set_noack_map</span></dt><dd><p>
Set the NoAck Map for the TIDs.
      </p></dd><dt><span class="term">get_et_sset_count</span></dt><dd><p>
Ethtool API to get string-set count.
See <em class="parameter"><code>ethtool_ops</code></em>.get_sset_count
      </p></dd><dt><span class="term">get_et_stats</span></dt><dd><p>
Ethtool API to get a set of u64 stats.
See <em class="parameter"><code>ethtool_ops</code></em>.get_ethtool_stats
      </p></dd><dt><span class="term">get_et_strings</span></dt><dd><p>
Ethtool API to get a set of strings to describe stats
and perhaps other supported types of ethtool data-sets.
See <em class="parameter"><code>ethtool_ops</code></em>.get_strings
      </p></dd><dt><span class="term">get_channel</span></dt><dd><p>
Get the current operating channel for the virtual interface.
For monitor interfaces, it should return <code class="constant">NULL</code> unless there's a single
current monitoring channel.
      </p></dd><dt><span class="term">start_p2p_device</span></dt><dd><p>
Start the given P2P device.
      </p></dd><dt><span class="term">stop_p2p_device</span></dt><dd><p>
Stop the given P2P device.
      </p></dd><dt><span class="term">set_mac_acl</span></dt><dd><p>
Sets MAC address control list in AP and P2P GO mode.
Parameters include ACL policy, an array of MAC address of stations
and the number of MAC addresses. If there is already a list in driver
this new list replaces the existing one. Driver has to clear its ACL
when number of MAC addresses entries is passed as 0. Drivers which
advertise the support for MAC based ACL have to implement this callback.
      </p></dd><dt><span class="term">start_radar_detection</span></dt><dd><p>
Start radar detection in the driver.
      </p></dd><dt><span class="term">update_ft_ies</span></dt><dd><p>
Provide updated Fast BSS Transition information to the
driver. If the SME is in the driver/firmware, this information can be
used in building Authentication and Reassociation Request frames.
      </p></dd><dt><span class="term">crit_proto_start</span></dt><dd><p>
Indicates a critical protocol needs more link reliability
for a given duration (milliseconds). The protocol is provided so the
driver can take the most appropriate actions.
      </p></dd><dt><span class="term">crit_proto_stop</span></dt><dd><p>
Indicates critical protocol no longer needs increased link
reliability. This operation can not fail.
      </p></dd><dt><span class="term">set_coalesce</span></dt><dd><p>
Set coalesce parameters.
      </p></dd><dt><span class="term">channel_switch</span></dt><dd><p>
initiate channel-switch procedure (with CSA)
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5458752"></a><h2>Description</h2><p>
   </p><p>

   This struct is registered by fullmac card drivers and/or wireless stacks
   in order to handle configuration requests on their interfaces.
   </p><p>

   All callbacks except where otherwise noted should return 0
   on success or a negative error code.
   </p><p>

   All operations are currently invoked under rtnl for consistency with the
   wireless extensions but this is subject to reevaluation as soon as this
   code is used more widely and we have a first user without wext.
</p></div></div><div class="refentry" title="struct vif_params"><div class="refentry.separator"><hr></div><a id="API-struct-vif-params"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct vif_params — 
  describes virtual interface parameters
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct vif_params {
  int use_4addr;
  u8 macaddr[ETH_ALEN];
};  </pre></div><div class="refsect1" title="Members"><a id="idp5468128"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">use_4addr</span></dt><dd><p>
use 4-address frames
      </p></dd><dt><span class="term">macaddr[ETH_ALEN]</span></dt><dd><p>
address to use for this virtual interface. This will only
be used for non-netdevice interfaces. If this parameter is set
to zero address the driver may determine the address as needed.
      </p></dd></dl></div></div></div><div class="refentry" title="struct key_params"><div class="refentry.separator"><hr></div><a id="API-struct-key-params"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct key_params — 
  key information
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct key_params {
  u8 * key;
  u8 * seq;
  int key_len;
  int seq_len;
  u32 cipher;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5479008"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">key</span></dt><dd><p>
key material
      </p></dd><dt><span class="term">seq</span></dt><dd><p>
sequence counter (IV/PN) for TKIP and CCMP keys, only used
with the <code class="function">get_key</code> callback, must be in little endian,
length given by <em class="parameter"><code>seq_len</code></em>.
      </p></dd><dt><span class="term">key_len</span></dt><dd><p>
length of key material
      </p></dd><dt><span class="term">seq_len</span></dt><dd><p>
length of <em class="parameter"><code>seq</code></em>.
      </p></dd><dt><span class="term">cipher</span></dt><dd><p>
cipher suite selector
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5488512"></a><h2>Description</h2><p>
   </p><p>

   Information about a key
</p></div></div><div class="refentry" title="enum survey_info_flags"><div class="refentry.separator"><hr></div><a id="API-enum-survey-info-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum survey_info_flags — 
  survey information flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum survey_info_flags {
  SURVEY_INFO_NOISE_DBM,
  SURVEY_INFO_IN_USE,
  SURVEY_INFO_CHANNEL_TIME,
  SURVEY_INFO_CHANNEL_TIME_BUSY,
  SURVEY_INFO_CHANNEL_TIME_EXT_BUSY,
  SURVEY_INFO_CHANNEL_TIME_RX,
  SURVEY_INFO_CHANNEL_TIME_TX
};  </pre></div><div class="refsect1" title="Constants"><a id="idp5497024"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">SURVEY_INFO_NOISE_DBM</span></dt><dd><p>
noise (in dBm) was filled in
      </p></dd><dt><span class="term">SURVEY_INFO_IN_USE</span></dt><dd><p>
channel is currently being used
      </p></dd><dt><span class="term">SURVEY_INFO_CHANNEL_TIME</span></dt><dd><p>
channel active time (in ms) was filled in
      </p></dd><dt><span class="term">SURVEY_INFO_CHANNEL_TIME_BUSY</span></dt><dd><p>
channel busy time was filled in
      </p></dd><dt><span class="term">SURVEY_INFO_CHANNEL_TIME_EXT_BUSY</span></dt><dd><p>
extension channel busy time was filled in
      </p></dd><dt><span class="term">SURVEY_INFO_CHANNEL_TIME_RX</span></dt><dd><p>
channel receive time was filled in
      </p></dd><dt><span class="term">SURVEY_INFO_CHANNEL_TIME_TX</span></dt><dd><p>
channel transmit time was filled in
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5507136"></a><h2>Description</h2><p>
   Used by the driver to indicate which info in <span class="structname">struct survey_info</span>
   it has filled in during the <code class="function">get_survey</code>.
</p></div></div><div class="refentry" title="struct survey_info"><div class="refentry.separator"><hr></div><a id="API-struct-survey-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct survey_info — 
  channel survey response
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct survey_info {
  struct ieee80211_channel * channel;
  u64 channel_time;
  u64 channel_time_busy;
  u64 channel_time_ext_busy;
  u64 channel_time_rx;
  u64 channel_time_tx;
  u32 filled;
  s8 noise;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5516368"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">channel</span></dt><dd><p>
the channel this survey record reports, mandatory
      </p></dd><dt><span class="term">channel_time</span></dt><dd><p>
amount of time in ms the radio spent on the channel
      </p></dd><dt><span class="term">channel_time_busy</span></dt><dd><p>
amount of time the primary channel was sensed busy
      </p></dd><dt><span class="term">channel_time_ext_busy</span></dt><dd><p>
amount of time the extension channel was sensed busy
      </p></dd><dt><span class="term">channel_time_rx</span></dt><dd><p>
amount of time the radio spent receiving data
      </p></dd><dt><span class="term">channel_time_tx</span></dt><dd><p>
amount of time the radio spent transmitting data
      </p></dd><dt><span class="term">filled</span></dt><dd><p>
bitflag of flags from <span class="structname">enum</span> survey_info_flags
      </p></dd><dt><span class="term">noise</span></dt><dd><p>
channel noise in dBm. This and all following fields are
optional
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5528640"></a><h2>Description</h2><p>
   Used by <code class="function">dump_survey</code> to report back per-channel survey information.
   </p><p>

   This structure can later be expanded with things like
   channel duty cycle etc.
</p></div></div><div class="refentry" title="struct cfg80211_beacon_data"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-beacon-data"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_beacon_data — 
  beacon data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_beacon_data {
  const u8 * head;
  const u8 * tail;
  const u8 * beacon_ies;
  const u8 * proberesp_ies;
  const u8 * assocresp_ies;
  const u8 * probe_resp;
  size_t head_len;
  size_t tail_len;
  size_t beacon_ies_len;
  size_t proberesp_ies_len;
  size_t assocresp_ies_len;
  size_t probe_resp_len;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5537952"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">head</span></dt><dd><p>
head portion of beacon (before TIM IE)
or <code class="constant">NULL</code> if not changed
      </p></dd><dt><span class="term">tail</span></dt><dd><p>
tail portion of beacon (after TIM IE)
or <code class="constant">NULL</code> if not changed
      </p></dd><dt><span class="term">beacon_ies</span></dt><dd><p>
extra information element(s) to add into Beacon frames or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">proberesp_ies</span></dt><dd><p>
extra information element(s) to add into Probe Response
frames or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">assocresp_ies</span></dt><dd><p>
extra information element(s) to add into (Re)Association
Response frames or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">probe_resp</span></dt><dd><p>
probe response template (AP mode only)
      </p></dd><dt><span class="term">head_len</span></dt><dd><p>
length of <em class="parameter"><code>head</code></em>
      </p></dd><dt><span class="term">tail_len</span></dt><dd><p>
length of <em class="parameter"><code>tail</code></em>
      </p></dd><dt><span class="term">beacon_ies_len</span></dt><dd><p>
length of beacon_ies in octets
      </p></dd><dt><span class="term">proberesp_ies_len</span></dt><dd><p>
length of proberesp_ies in octets
      </p></dd><dt><span class="term">assocresp_ies_len</span></dt><dd><p>
length of assocresp_ies in octets
      </p></dd><dt><span class="term">probe_resp_len</span></dt><dd><p>
length of probe response template (<em class="parameter"><code>probe_resp</code></em>)
      </p></dd></dl></div></div></div><div class="refentry" title="struct cfg80211_ap_settings"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-ap-settings"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_ap_settings — 
  AP configuration
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_ap_settings {
  struct cfg80211_chan_def chandef;
  struct cfg80211_beacon_data beacon;
  int beacon_interval;
  int dtim_period;
  const u8 * ssid;
  size_t ssid_len;
  enum nl80211_hidden_ssid hidden_ssid;
  struct cfg80211_crypto_settings crypto;
  bool privacy;
  enum nl80211_auth_type auth_type;
  int inactivity_timeout;
  u8 p2p_ctwindow;
  bool p2p_opp_ps;
  const struct cfg80211_acl_data * acl;
  bool radar_required;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5565824"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">chandef</span></dt><dd><p>
defines the channel to use
      </p></dd><dt><span class="term">beacon</span></dt><dd><p>
beacon data
      </p></dd><dt><span class="term">beacon_interval</span></dt><dd><p>
beacon interval
      </p></dd><dt><span class="term">dtim_period</span></dt><dd><p>
DTIM period
      </p></dd><dt><span class="term">ssid</span></dt><dd><p>
SSID to be used in the BSS (note: may be <code class="constant">NULL</code> if not provided from
user space)
      </p></dd><dt><span class="term">ssid_len</span></dt><dd><p>
length of <em class="parameter"><code>ssid</code></em>
      </p></dd><dt><span class="term">hidden_ssid</span></dt><dd><p>
whether to hide the SSID in Beacon/Probe Response frames
      </p></dd><dt><span class="term">crypto</span></dt><dd><p>
crypto settings
      </p></dd><dt><span class="term">privacy</span></dt><dd><p>
the BSS uses privacy
      </p></dd><dt><span class="term">auth_type</span></dt><dd><p>
Authentication type (algorithm)
      </p></dd><dt><span class="term">inactivity_timeout</span></dt><dd><p>
time in seconds to determine station's inactivity.
      </p></dd><dt><span class="term">p2p_ctwindow</span></dt><dd><p>
P2P CT Window
      </p></dd><dt><span class="term">p2p_opp_ps</span></dt><dd><p>
P2P opportunistic PS
      </p></dd><dt><span class="term">acl</span></dt><dd><p>
ACL configuration used by the drivers which has support for
MAC address based access control
      </p></dd><dt><span class="term">radar_required</span></dt><dd><p>
set if radar detection is required
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5587456"></a><h2>Description</h2><p>
   </p><p>

   Used to configure an AP interface.
</p></div></div><div class="refentry" title="struct station_parameters"><div class="refentry.separator"><hr></div><a id="API-struct-station-parameters"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct station_parameters — 
  station parameters
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct station_parameters {
  const u8 * supported_rates;
  struct net_device * vlan;
  u32 sta_flags_mask;
  u32 sta_flags_set;
  u32 sta_modify_mask;
  int listen_interval;
  u16 aid;
  u8 supported_rates_len;
  u8 plink_action;
  u8 plink_state;
  const struct ieee80211_ht_cap * ht_capa;
  const struct ieee80211_vht_cap * vht_capa;
  u8 uapsd_queues;
  u8 max_sp;
  enum nl80211_mesh_power_mode local_pm;
  u16 capability;
  const u8 * ext_capab;
  u8 ext_capab_len;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5596208"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">supported_rates</span></dt><dd><p>
supported rates in IEEE 802.11 format
(or NULL for no change)
      </p></dd><dt><span class="term">vlan</span></dt><dd><p>
vlan interface station should belong to
      </p></dd><dt><span class="term">sta_flags_mask</span></dt><dd><p>
station flags that changed
(bitmask of BIT(NL80211_STA_FLAG_...))
      </p></dd><dt><span class="term">sta_flags_set</span></dt><dd><p>
station flags values
(bitmask of BIT(NL80211_STA_FLAG_...))
      </p></dd><dt><span class="term">sta_modify_mask</span></dt><dd><p>
bitmap indicating which parameters changed
(for those that don't have a natural <span class="quote">“<span class="quote">no change</span>”</span> value),
see <span class="structname">enum</span> station_parameters_apply_mask
      </p></dd><dt><span class="term">listen_interval</span></dt><dd><p>
listen interval or -1 for no change
      </p></dd><dt><span class="term">aid</span></dt><dd><p>
AID or zero for no change
      </p></dd><dt><span class="term">supported_rates_len</span></dt><dd><p>
number of supported rates
      </p></dd><dt><span class="term">plink_action</span></dt><dd><p>
plink action to take
      </p></dd><dt><span class="term">plink_state</span></dt><dd><p>
set the peer link state for a station
      </p></dd><dt><span class="term">ht_capa</span></dt><dd><p>
HT capabilities of station
      </p></dd><dt><span class="term">vht_capa</span></dt><dd><p>
VHT capabilities of station
      </p></dd><dt><span class="term">uapsd_queues</span></dt><dd><p>
bitmap of queues configured for uapsd. same format
as the AC bitmap in the QoS info field
      </p></dd><dt><span class="term">max_sp</span></dt><dd><p>
max Service Period. same format as the MAX_SP in the
QoS info field (but already shifted down)
      </p></dd><dt><span class="term">local_pm</span></dt><dd><p>
local link-specific mesh power save mode (no change when set
to unknown)
      </p></dd><dt><span class="term">capability</span></dt><dd><p>
station capability
      </p></dd><dt><span class="term">ext_capab</span></dt><dd><p>
extended capabilities of the station
      </p></dd><dt><span class="term">ext_capab_len</span></dt><dd><p>
number of extended capabilities
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5621840"></a><h2>Description</h2><p>
   </p><p>

   Used to change and create a new station.
</p></div></div><div class="refentry" title="enum station_info_flags"><div class="refentry.separator"><hr></div><a id="API-enum-station-info-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum station_info_flags — 
  station information flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum station_info_flags {
  STATION_INFO_INACTIVE_TIME,
  STATION_INFO_RX_BYTES,
  STATION_INFO_TX_BYTES,
  STATION_INFO_LLID,
  STATION_INFO_PLID,
  STATION_INFO_PLINK_STATE,
  STATION_INFO_SIGNAL,
  STATION_INFO_TX_BITRATE,
  STATION_INFO_RX_PACKETS,
  STATION_INFO_TX_PACKETS,
  STATION_INFO_TX_RETRIES,
  STATION_INFO_TX_FAILED,
  STATION_INFO_RX_DROP_MISC,
  STATION_INFO_SIGNAL_AVG,
  STATION_INFO_RX_BITRATE,
  STATION_INFO_BSS_PARAM,
  STATION_INFO_CONNECTED_TIME,
  STATION_INFO_ASSOC_REQ_IES,
  STATION_INFO_STA_FLAGS,
  STATION_INFO_BEACON_LOSS_COUNT,
  STATION_INFO_T_OFFSET,
  STATION_INFO_LOCAL_PM,
  STATION_INFO_PEER_PM,
  STATION_INFO_NONPEER_PM,
  STATION_INFO_RX_BYTES64,
  STATION_INFO_TX_BYTES64,
  STATION_INFO_CHAIN_SIGNAL,
  STATION_INFO_CHAIN_SIGNAL_AVG
};  </pre></div><div class="refsect1" title="Constants"><a id="idp5630896"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">STATION_INFO_INACTIVE_TIME</span></dt><dd><p>
<em class="parameter"><code>inactive_time</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_RX_BYTES</span></dt><dd><p>
<em class="parameter"><code>rx_bytes</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_TX_BYTES</span></dt><dd><p>
<em class="parameter"><code>tx_bytes</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_LLID</span></dt><dd><p>
<em class="parameter"><code>llid</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_PLID</span></dt><dd><p>
<em class="parameter"><code>plid</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_PLINK_STATE</span></dt><dd><p>
<em class="parameter"><code>plink_state</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_SIGNAL</span></dt><dd><p>
<em class="parameter"><code>signal</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_TX_BITRATE</span></dt><dd><p>
<em class="parameter"><code>txrate</code></em> fields are filled
(tx_bitrate, tx_bitrate_flags and tx_bitrate_mcs)
      </p></dd><dt><span class="term">STATION_INFO_RX_PACKETS</span></dt><dd><p>
<em class="parameter"><code>rx_packets</code></em> filled with 32-bit value
      </p></dd><dt><span class="term">STATION_INFO_TX_PACKETS</span></dt><dd><p>
<em class="parameter"><code>tx_packets</code></em> filled with 32-bit value
      </p></dd><dt><span class="term">STATION_INFO_TX_RETRIES</span></dt><dd><p>
<em class="parameter"><code>tx_retries</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_TX_FAILED</span></dt><dd><p>
<em class="parameter"><code>tx_failed</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_RX_DROP_MISC</span></dt><dd><p>
<em class="parameter"><code>rx_dropped_misc</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_SIGNAL_AVG</span></dt><dd><p>
<em class="parameter"><code>signal_avg</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_RX_BITRATE</span></dt><dd><p>
<em class="parameter"><code>rxrate</code></em> fields are filled
      </p></dd><dt><span class="term">STATION_INFO_BSS_PARAM</span></dt><dd><p>
<em class="parameter"><code>bss_param</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_CONNECTED_TIME</span></dt><dd><p>
<em class="parameter"><code>connected_time</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_ASSOC_REQ_IES</span></dt><dd><p>
<em class="parameter"><code>assoc_req_ies</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_STA_FLAGS</span></dt><dd><p>
<em class="parameter"><code>sta_flags</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_BEACON_LOSS_COUNT</span></dt><dd><p>
<em class="parameter"><code>beacon_loss_count</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_T_OFFSET</span></dt><dd><p>
<em class="parameter"><code>t_offset</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_LOCAL_PM</span></dt><dd><p>
<em class="parameter"><code>local_pm</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_PEER_PM</span></dt><dd><p>
<em class="parameter"><code>peer_pm</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_NONPEER_PM</span></dt><dd><p>
<em class="parameter"><code>nonpeer_pm</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_RX_BYTES64</span></dt><dd><p>
<em class="parameter"><code>rx_bytes</code></em> filled with 64-bit value
      </p></dd><dt><span class="term">STATION_INFO_TX_BYTES64</span></dt><dd><p>
<em class="parameter"><code>tx_bytes</code></em> filled with 64-bit value
      </p></dd><dt><span class="term">STATION_INFO_CHAIN_SIGNAL</span></dt><dd><p>
<em class="parameter"><code>chain_signal</code></em> filled
      </p></dd><dt><span class="term">STATION_INFO_CHAIN_SIGNAL_AVG</span></dt><dd><p>
<em class="parameter"><code>chain_signal_avg</code></em> filled
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5685456"></a><h2>Description</h2><p>
   </p><p>

   Used by the driver to indicate which info in <span class="structname">struct station_info</span>
   it has filled in during <code class="function">get_station</code> or <code class="function">dump_station</code>.
</p></div></div><div class="refentry" title="enum rate_info_flags"><div class="refentry.separator"><hr></div><a id="API-enum-rate-info-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum rate_info_flags — 
  bitrate info flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum rate_info_flags {
  RATE_INFO_FLAGS_MCS,
  RATE_INFO_FLAGS_VHT_MCS,
  RATE_INFO_FLAGS_40_MHZ_WIDTH,
  RATE_INFO_FLAGS_80_MHZ_WIDTH,
  RATE_INFO_FLAGS_80P80_MHZ_WIDTH,
  RATE_INFO_FLAGS_160_MHZ_WIDTH,
  RATE_INFO_FLAGS_SHORT_GI,
  RATE_INFO_FLAGS_60G
};  </pre></div><div class="refsect1" title="Constants"><a id="idp5695616"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">RATE_INFO_FLAGS_MCS</span></dt><dd><p>
mcs field filled with HT MCS
      </p></dd><dt><span class="term">RATE_INFO_FLAGS_VHT_MCS</span></dt><dd><p>
mcs field filled with VHT MCS
      </p></dd><dt><span class="term">RATE_INFO_FLAGS_40_MHZ_WIDTH</span></dt><dd><p>
40 MHz width transmission
      </p></dd><dt><span class="term">RATE_INFO_FLAGS_80_MHZ_WIDTH</span></dt><dd><p>
80 MHz width transmission
      </p></dd><dt><span class="term">RATE_INFO_FLAGS_80P80_MHZ_WIDTH</span></dt><dd><p>
80+80 MHz width transmission
      </p></dd><dt><span class="term">RATE_INFO_FLAGS_160_MHZ_WIDTH</span></dt><dd><p>
160 MHz width transmission
      </p></dd><dt><span class="term">RATE_INFO_FLAGS_SHORT_GI</span></dt><dd><p>
400ns guard interval
      </p></dd><dt><span class="term">RATE_INFO_FLAGS_60G</span></dt><dd><p>
60GHz MCS
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5707008"></a><h2>Description</h2><p>
   </p><p>

   Used by the driver to indicate the specific rate transmission
   type for 802.11n transmissions.
</p></div></div><div class="refentry" title="struct rate_info"><div class="refentry.separator"><hr></div><a id="API-struct-rate-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct rate_info — 
  bitrate information
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct rate_info {
  u8 flags;
  u8 mcs;
  u16 legacy;
  u8 nss;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5715456"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">flags</span></dt><dd><p>
bitflag of flags from <span class="structname">enum</span> rate_info_flags
      </p></dd><dt><span class="term">mcs</span></dt><dd><p>
mcs index if struct describes a 802.11n bitrate
      </p></dd><dt><span class="term">legacy</span></dt><dd><p>
bitrate in 100kbit/s for 802.11abg
      </p></dd><dt><span class="term">nss</span></dt><dd><p>
number of streams (VHT only)
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5722112"></a><h2>Description</h2><p>
   </p><p>

   Information about a receiving or transmitting bitrate
</p></div></div><div class="refentry" title="struct station_info"><div class="refentry.separator"><hr></div><a id="API-struct-station-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct station_info — 
  station information
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct station_info {
  u32 filled;
  u32 connected_time;
  u32 inactive_time;
  u64 rx_bytes;
  u64 tx_bytes;
  u16 llid;
  u16 plid;
  u8 plink_state;
  s8 signal;
  s8 signal_avg;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  s8 chain_signal_avg[IEEE80211_MAX_CHAINS];
  struct rate_info txrate;
  struct rate_info rxrate;
  u32 rx_packets;
  u32 tx_packets;
  u32 tx_retries;
  u32 tx_failed;
  u32 rx_dropped_misc;
  struct sta_bss_parameters bss_param;
  struct nl80211_sta_flag_update sta_flags;
  int generation;
  const u8 * assoc_req_ies;
  size_t assoc_req_ies_len;
  u32 beacon_loss_count;
  s64 t_offset;
  enum nl80211_mesh_power_mode local_pm;
  enum nl80211_mesh_power_mode peer_pm;
  enum nl80211_mesh_power_mode nonpeer_pm;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5731984"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">filled</span></dt><dd><p>
bitflag of flags from <span class="structname">enum</span> station_info_flags
      </p></dd><dt><span class="term">connected_time</span></dt><dd><p>
time(in secs) since a station is last connected
      </p></dd><dt><span class="term">inactive_time</span></dt><dd><p>
time since last station activity (tx/rx) in milliseconds
      </p></dd><dt><span class="term">rx_bytes</span></dt><dd><p>
bytes received from this station
      </p></dd><dt><span class="term">tx_bytes</span></dt><dd><p>
bytes transmitted to this station
      </p></dd><dt><span class="term">llid</span></dt><dd><p>
mesh local link id
      </p></dd><dt><span class="term">plid</span></dt><dd><p>
mesh peer link id
      </p></dd><dt><span class="term">plink_state</span></dt><dd><p>
mesh peer link state
      </p></dd><dt><span class="term">signal</span></dt><dd><p>
The signal strength, type depends on the wiphy's signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
      </p></dd><dt><span class="term">signal_avg</span></dt><dd><p>
Average signal strength, type depends on the wiphy's signal_type.
For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
      </p></dd><dt><span class="term">chains</span></dt><dd><p>
bitmask for filled values in <em class="parameter"><code>chain_signal</code></em>, <em class="parameter"><code>chain_signal_avg</code></em>
      </p></dd><dt><span class="term">chain_signal[IEEE80211_MAX_CHAINS]</span></dt><dd><p>
per-chain signal strength of last received packet in dBm
      </p></dd><dt><span class="term">chain_signal_avg[IEEE80211_MAX_CHAINS]</span></dt><dd><p>
per-chain signal strength average in dBm
      </p></dd><dt><span class="term">txrate</span></dt><dd><p>
current unicast bitrate from this station
      </p></dd><dt><span class="term">rxrate</span></dt><dd><p>
current unicast bitrate to this station
      </p></dd><dt><span class="term">rx_packets</span></dt><dd><p>
packets received from this station
      </p></dd><dt><span class="term">tx_packets</span></dt><dd><p>
packets transmitted to this station
      </p></dd><dt><span class="term">tx_retries</span></dt><dd><p>
cumulative retry counts
      </p></dd><dt><span class="term">tx_failed</span></dt><dd><p>
number of failed transmissions (retries exceeded, no ACK)
      </p></dd><dt><span class="term">rx_dropped_misc</span></dt><dd><p>
Dropped for un-specified reason.
      </p></dd><dt><span class="term">bss_param</span></dt><dd><p>
current BSS parameters
      </p></dd><dt><span class="term">sta_flags</span></dt><dd><p>
station flags mask &amp; values
      </p></dd><dt><span class="term">generation</span></dt><dd><p>
generation number for nl80211 dumps.
This number should increase every time the list of stations
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.
      </p></dd><dt><span class="term">assoc_req_ies</span></dt><dd><p>
IEs from (Re)Association Request.
This is used only when in AP mode with drivers that do not use
user space MLME/SME implementation. The information is provided for
the <code class="function">cfg80211_new_sta</code> calls to notify user space of the IEs.
      </p></dd><dt><span class="term">assoc_req_ies_len</span></dt><dd><p>
Length of assoc_req_ies buffer in octets.
      </p></dd><dt><span class="term">beacon_loss_count</span></dt><dd><p>
Number of times beacon loss event has triggered.
      </p></dd><dt><span class="term">t_offset</span></dt><dd><p>
Time offset of the station relative to this host.
      </p></dd><dt><span class="term">local_pm</span></dt><dd><p>
local mesh STA power save mode
      </p></dd><dt><span class="term">peer_pm</span></dt><dd><p>
peer mesh STA power save mode
      </p></dd><dt><span class="term">nonpeer_pm</span></dt><dd><p>
non-peer mesh STA power save mode
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5774912"></a><h2>Description</h2><p>
   </p><p>

   Station information filled by driver for <code class="function">get_station</code> and dump_station.
</p></div></div><div class="refentry" title="enum monitor_flags"><div class="refentry.separator"><hr></div><a id="API-enum-monitor-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum monitor_flags — 
  monitor flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum monitor_flags {
  MONITOR_FLAG_FCSFAIL,
  MONITOR_FLAG_PLCPFAIL,
  MONITOR_FLAG_CONTROL,
  MONITOR_FLAG_OTHER_BSS,
  MONITOR_FLAG_COOK_FRAMES,
  MONITOR_FLAG_ACTIVE
};  </pre></div><div class="refsect1" title="Constants"><a id="idp5783984"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">MONITOR_FLAG_FCSFAIL</span></dt><dd><p>
pass frames with bad FCS
      </p></dd><dt><span class="term">MONITOR_FLAG_PLCPFAIL</span></dt><dd><p>
pass frames with bad PLCP
      </p></dd><dt><span class="term">MONITOR_FLAG_CONTROL</span></dt><dd><p>
pass control frames
      </p></dd><dt><span class="term">MONITOR_FLAG_OTHER_BSS</span></dt><dd><p>
disable BSSID filtering
      </p></dd><dt><span class="term">MONITOR_FLAG_COOK_FRAMES</span></dt><dd><p>
report frames after processing
      </p></dd><dt><span class="term">MONITOR_FLAG_ACTIVE</span></dt><dd><p>
active monitor, ACKs frames on its MAC address
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5792816"></a><h2>Description</h2><p>
   </p><p>

   Monitor interface configuration flags. Note that these must be the bits
   according to the nl80211 flags.
</p></div></div><div class="refentry" title="enum mpath_info_flags"><div class="refentry.separator"><hr></div><a id="API-enum-mpath-info-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum mpath_info_flags — 
  mesh path information flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum mpath_info_flags {
  MPATH_INFO_FRAME_QLEN,
  MPATH_INFO_SN,
  MPATH_INFO_METRIC,
  MPATH_INFO_EXPTIME,
  MPATH_INFO_DISCOVERY_TIMEOUT,
  MPATH_INFO_DISCOVERY_RETRIES,
  MPATH_INFO_FLAGS
};  </pre></div><div class="refsect1" title="Constants"><a id="idp5801408"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">MPATH_INFO_FRAME_QLEN</span></dt><dd><p>
<em class="parameter"><code>frame_qlen</code></em> filled
      </p></dd><dt><span class="term">MPATH_INFO_SN</span></dt><dd><p>
<em class="parameter"><code>sn</code></em> filled
      </p></dd><dt><span class="term">MPATH_INFO_METRIC</span></dt><dd><p>
<em class="parameter"><code>metric</code></em> filled
      </p></dd><dt><span class="term">MPATH_INFO_EXPTIME</span></dt><dd><p>
<em class="parameter"><code>exptime</code></em> filled
      </p></dd><dt><span class="term">MPATH_INFO_DISCOVERY_TIMEOUT</span></dt><dd><p>
<em class="parameter"><code>discovery_timeout</code></em> filled
      </p></dd><dt><span class="term">MPATH_INFO_DISCOVERY_RETRIES</span></dt><dd><p>
<em class="parameter"><code>discovery_retries</code></em> filled
      </p></dd><dt><span class="term">MPATH_INFO_FLAGS</span></dt><dd><p>
<em class="parameter"><code>flags</code></em> filled
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5815888"></a><h2>Description</h2><p>
   </p><p>

   Used by the driver to indicate which info in <span class="structname">struct mpath_info</span> it has filled
   in during <code class="function">get_station</code> or <code class="function">dump_station</code>.
</p></div></div><div class="refentry" title="struct mpath_info"><div class="refentry.separator"><hr></div><a id="API-struct-mpath-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct mpath_info — 
  mesh path information
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct mpath_info {
  u32 filled;
  u32 frame_qlen;
  u32 sn;
  u32 metric;
  u32 exptime;
  u32 discovery_timeout;
  u8 discovery_retries;
  u8 flags;
  int generation;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5825968"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">filled</span></dt><dd><p>
bitfield of flags from <span class="structname">enum</span> mpath_info_flags
      </p></dd><dt><span class="term">frame_qlen</span></dt><dd><p>
number of queued frames for this destination
      </p></dd><dt><span class="term">sn</span></dt><dd><p>
target sequence number
      </p></dd><dt><span class="term">metric</span></dt><dd><p>
metric (cost) of this mesh path
      </p></dd><dt><span class="term">exptime</span></dt><dd><p>
expiration time for the mesh path from now, in msecs
      </p></dd><dt><span class="term">discovery_timeout</span></dt><dd><p>
total mesh path discovery timeout, in msecs
      </p></dd><dt><span class="term">discovery_retries</span></dt><dd><p>
mesh path discovery retries
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
mesh path flags
      </p></dd><dt><span class="term">generation</span></dt><dd><p>
generation number for nl80211 dumps.
This number should increase every time the list of mesh paths
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5839344"></a><h2>Description</h2><p>
   </p><p>

   Mesh path information filled by driver for <code class="function">get_mpath</code> and <code class="function">dump_mpath</code>.
</p></div></div><div class="refentry" title="struct bss_parameters"><div class="refentry.separator"><hr></div><a id="API-struct-bss-parameters"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct bss_parameters — 
  BSS parameters
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct bss_parameters {
  int use_cts_prot;
  int use_short_preamble;
  int use_short_slot_time;
  u8 * basic_rates;
  u8 basic_rates_len;
  int ap_isolate;
  int ht_opmode;
  s8 p2p_ctwindow;
  s8 p2p_opp_ps;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5849072"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">use_cts_prot</span></dt><dd><p>
Whether to use CTS protection
(0 = no, 1 = yes, -1 = do not change)
      </p></dd><dt><span class="term">use_short_preamble</span></dt><dd><p>
Whether the use of short preambles is allowed
(0 = no, 1 = yes, -1 = do not change)
      </p></dd><dt><span class="term">use_short_slot_time</span></dt><dd><p>
Whether the use of short slot time is allowed
(0 = no, 1 = yes, -1 = do not change)
      </p></dd><dt><span class="term">basic_rates</span></dt><dd><p>
basic rates in IEEE 802.11 format
(or NULL for no change)
      </p></dd><dt><span class="term">basic_rates_len</span></dt><dd><p>
number of basic rates
      </p></dd><dt><span class="term">ap_isolate</span></dt><dd><p>
do not forward packets between connected stations
      </p></dd><dt><span class="term">ht_opmode</span></dt><dd><p>
HT Operation mode
(u16 = opmode, -1 = do not change)
      </p></dd><dt><span class="term">p2p_ctwindow</span></dt><dd><p>
P2P CT Window (-1 = no change)
      </p></dd><dt><span class="term">p2p_opp_ps</span></dt><dd><p>
P2P opportunistic PS (-1 = no change)
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5862304"></a><h2>Description</h2><p>
   </p><p>

   Used to change BSS parameters (mainly for AP mode).
</p></div></div><div class="refentry" title="struct ieee80211_txq_params"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-txq-params"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_txq_params — 
  TX queue parameters
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_txq_params {
  enum nl80211_ac ac;
  u16 txop;
  u16 cwmin;
  u16 cwmax;
  u8 aifs;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5870768"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">ac</span></dt><dd><p>
AC identifier
      </p></dd><dt><span class="term">txop</span></dt><dd><p>
Maximum burst time in units of 32 usecs, 0 meaning disabled
      </p></dd><dt><span class="term">cwmin</span></dt><dd><p>
Minimum contention window [a value of the form 2^n-1 in the range
1..32767]
      </p></dd><dt><span class="term">cwmax</span></dt><dd><p>
Maximum contention window [a value of the form 2^n-1 in the range
1..32767]
      </p></dd><dt><span class="term">aifs</span></dt><dd><p>
Arbitration interframe space [0..255]
      </p></dd></dl></div></div></div><div class="refentry" title="struct cfg80211_crypto_settings"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-crypto-settings"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_crypto_settings — 
  Crypto settings
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_crypto_settings {
  u32 wpa_versions;
  u32 cipher_group;
  int n_ciphers_pairwise;
  u32 ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES];
  int n_akm_suites;
  u32 akm_suites[NL80211_MAX_NR_AKM_SUITES];
  bool control_port;
  __be16 control_port_ethertype;
  bool control_port_no_encrypt;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5885760"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">wpa_versions</span></dt><dd><p>
indicates which, if any, WPA versions are enabled
(from enum nl80211_wpa_versions)
      </p></dd><dt><span class="term">cipher_group</span></dt><dd><p>
group key cipher suite (or 0 if unset)
      </p></dd><dt><span class="term">n_ciphers_pairwise</span></dt><dd><p>
number of AP supported unicast ciphers
      </p></dd><dt><span class="term">ciphers_pairwise[NL80211_MAX_NR_CIPHER_SUITES]</span></dt><dd><p>
unicast key cipher suites
      </p></dd><dt><span class="term">n_akm_suites</span></dt><dd><p>
number of AKM suites
      </p></dd><dt><span class="term">akm_suites[NL80211_MAX_NR_AKM_SUITES]</span></dt><dd><p>
AKM suites
      </p></dd><dt><span class="term">control_port</span></dt><dd><p>
Whether user space controls IEEE 802.1X port, i.e.,
sets/clears <code class="constant">NL80211_STA_FLAG_AUTHORIZED</code>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.
      </p></dd><dt><span class="term">control_port_ethertype</span></dt><dd><p>
the control port protocol that should be
allowed through even on unauthorized ports
      </p></dd><dt><span class="term">control_port_no_encrypt</span></dt><dd><p>
TRUE to prevent encryption of control port
protocol frames.
      </p></dd></dl></div></div></div><div class="refentry" title="struct cfg80211_auth_request"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-auth-request"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_auth_request — 
  Authentication request data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_auth_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  size_t ie_len;
  enum nl80211_auth_type auth_type;
  const u8 * key;
  u8 key_len;
  u8 key_idx;
  const u8 * sae_data;
  size_t sae_data_len;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5906464"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">bss</span></dt><dd><p>
The BSS to authenticate with, the callee must obtain a reference
to it if it needs to keep it.
      </p></dd><dt><span class="term">ie</span></dt><dd><p>
Extra IEs to add to Authentication frame or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">ie_len</span></dt><dd><p>
Length of ie buffer in octets
      </p></dd><dt><span class="term">auth_type</span></dt><dd><p>
Authentication type (algorithm)
      </p></dd><dt><span class="term">key</span></dt><dd><p>
WEP key for shared key authentication
      </p></dd><dt><span class="term">key_len</span></dt><dd><p>
length of WEP key for shared key authentication
      </p></dd><dt><span class="term">key_idx</span></dt><dd><p>
index of WEP key for shared key authentication
      </p></dd><dt><span class="term">sae_data</span></dt><dd><p>
Non-IE data to use with SAE or <code class="constant">NULL</code>. This starts with
Authentication transaction sequence number field.
      </p></dd><dt><span class="term">sae_data_len</span></dt><dd><p>
Length of sae_data buffer in octets
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5920112"></a><h2>Description</h2><p>
   </p><p>

   This structure provides information needed to complete IEEE 802.11
   authentication.
</p></div></div><div class="refentry" title="struct cfg80211_assoc_request"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-assoc-request"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_assoc_request — 
  (Re)Association request data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_assoc_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  const u8 * prev_bssid;
  size_t ie_len;
  struct cfg80211_crypto_settings crypto;
  bool use_mfp;
  u32 flags;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa;
  struct ieee80211_vht_cap vht_capa_mask;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5928848"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">bss</span></dt><dd><p>
The BSS to associate with. If the call is successful the driver is
given a reference that it must give back to <code class="function">cfg80211_send_rx_assoc</code>
or to <code class="function">cfg80211_assoc_timeout</code>. To ensure proper refcounting, new
association requests while already associating must be rejected.
      </p></dd><dt><span class="term">ie</span></dt><dd><p>
Extra IEs to add to (Re)Association Request frame or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">prev_bssid</span></dt><dd><p>
previous BSSID, if not <code class="constant">NULL</code> use reassociate frame
      </p></dd><dt><span class="term">ie_len</span></dt><dd><p>
Length of ie buffer in octets
      </p></dd><dt><span class="term">crypto</span></dt><dd><p>
crypto settings
      </p></dd><dt><span class="term">use_mfp</span></dt><dd><p>
Use management frame protection (IEEE 802.11w) in this association
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
See <span class="structname">enum</span> cfg80211_assoc_req_flags
      </p></dd><dt><span class="term">ht_capa</span></dt><dd><p>
HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.
      </p></dd><dt><span class="term">ht_capa_mask</span></dt><dd><p>
The bits of ht_capa which are to be used.
      </p></dd><dt><span class="term">vht_capa</span></dt><dd><p>
VHT capability override
      </p></dd><dt><span class="term">vht_capa_mask</span></dt><dd><p>
VHT capability mask indicating which fields to use
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5947056"></a><h2>Description</h2><p>
   </p><p>

   This structure provides information needed to complete IEEE 802.11
   (re)association.
</p></div></div><div class="refentry" title="struct cfg80211_deauth_request"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-deauth-request"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_deauth_request — 
  Deauthentication request data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_deauth_request {
  const u8 * bssid;
  const u8 * ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5955584"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">bssid</span></dt><dd><p>
the BSSID of the BSS to deauthenticate from
      </p></dd><dt><span class="term">ie</span></dt><dd><p>
Extra IEs to add to Deauthentication frame or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">ie_len</span></dt><dd><p>
Length of ie buffer in octets
      </p></dd><dt><span class="term">reason_code</span></dt><dd><p>
The reason code for the deauthentication
      </p></dd><dt><span class="term">local_state_change</span></dt><dd><p>
if set, change local state only and
do not set a deauth frame
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5963600"></a><h2>Description</h2><p>
   </p><p>

   This structure provides information needed to complete IEEE 802.11
   deauthentication.
</p></div></div><div class="refentry" title="struct cfg80211_disassoc_request"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-disassoc-request"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_disassoc_request — 
  Disassociation request data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_disassoc_request {
  struct cfg80211_bss * bss;
  const u8 * ie;
  size_t ie_len;
  u16 reason_code;
  bool local_state_change;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5972128"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">bss</span></dt><dd><p>
the BSS to disassociate from
      </p></dd><dt><span class="term">ie</span></dt><dd><p>
Extra IEs to add to Disassociation frame or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">ie_len</span></dt><dd><p>
Length of ie buffer in octets
      </p></dd><dt><span class="term">reason_code</span></dt><dd><p>
The reason code for the disassociation
      </p></dd><dt><span class="term">local_state_change</span></dt><dd><p>
This is a request for a local state only, i.e., no
Disassociation frame is to be transmitted.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp5980176"></a><h2>Description</h2><p>
   </p><p>

   This structure provides information needed to complete IEEE 802.11
   disassocation.
</p></div></div><div class="refentry" title="struct cfg80211_ibss_params"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-ibss-params"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_ibss_params — 
  IBSS parameters
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_ibss_params {
  u8 * ssid;
  u8 * bssid;
  struct cfg80211_chan_def chandef;
  u8 * ie;
  u8 ssid_len;
  u8 ie_len;
  u16 beacon_interval;
  u32 basic_rates;
  bool channel_fixed;
  bool privacy;
  bool control_port;
  int mcast_rate[IEEE80211_NUM_BANDS];
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
};  </pre></div><div class="refsect1" title="Members"><a id="idp5988912"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">ssid</span></dt><dd><p>
The SSID, will always be non-null.
      </p></dd><dt><span class="term">bssid</span></dt><dd><p>
Fixed BSSID requested, maybe be <code class="constant">NULL</code>, if set do not
search for IBSSs with a different BSSID.
      </p></dd><dt><span class="term">chandef</span></dt><dd><p>
defines the channel to use if no other IBSS to join can be found
      </p></dd><dt><span class="term">ie</span></dt><dd><p>
information element(s) to include in the beacon
      </p></dd><dt><span class="term">ssid_len</span></dt><dd><p>
The length of the SSID, will always be non-zero.
      </p></dd><dt><span class="term">ie_len</span></dt><dd><p>
length of that
      </p></dd><dt><span class="term">beacon_interval</span></dt><dd><p>
beacon interval to use
      </p></dd><dt><span class="term">basic_rates</span></dt><dd><p>
bitmap of basic rates to use when creating the IBSS
      </p></dd><dt><span class="term">channel_fixed</span></dt><dd><p>
The channel should be fixed -- do not search for
IBSSs to join on other channels.
      </p></dd><dt><span class="term">privacy</span></dt><dd><p>
this is a protected network, keys will be configured
after joining
      </p></dd><dt><span class="term">control_port</span></dt><dd><p>
whether user space controls IEEE 802.1X port, i.e.,
sets/clears <code class="constant">NL80211_STA_FLAG_AUTHORIZED</code>. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.
      </p></dd><dt><span class="term">mcast_rate[IEEE80211_NUM_BANDS]</span></dt><dd><p>
per-band multicast rate index + 1 (0: disabled)
      </p></dd><dt><span class="term">ht_capa</span></dt><dd><p>
HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.
      </p></dd><dt><span class="term">ht_capa_mask</span></dt><dd><p>
The bits of ht_capa which are to be used.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6009696"></a><h2>Description</h2><p>
   </p><p>

   This structure defines the IBSS parameters for the <code class="function">join_ibss</code>
   method.
</p></div></div><div class="refentry" title="struct cfg80211_connect_params"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-connect-params"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_connect_params — 
  Connection parameters
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_connect_params {
  struct ieee80211_channel * channel;
  u8 * bssid;
  u8 * ssid;
  size_t ssid_len;
  enum nl80211_auth_type auth_type;
  u8 * ie;
  size_t ie_len;
  bool privacy;
  enum nl80211_mfp mfp;
  struct cfg80211_crypto_settings crypto;
  const u8 * key;
  u8 key_len;
  u8 key_idx;
  u32 flags;
  int bg_scan_period;
  struct ieee80211_ht_cap ht_capa;
  struct ieee80211_ht_cap ht_capa_mask;
  struct ieee80211_vht_cap vht_capa;
  struct ieee80211_vht_cap vht_capa_mask;
};  </pre></div><div class="refsect1" title="Members"><a id="idp6019168"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">channel</span></dt><dd><p>
The channel to use or <code class="constant">NULL</code> if not specified (auto-select based
on scan results)
      </p></dd><dt><span class="term">bssid</span></dt><dd><p>
The AP BSSID or <code class="constant">NULL</code> if not specified (auto-select based on scan
results)
      </p></dd><dt><span class="term">ssid</span></dt><dd><p>
SSID
      </p></dd><dt><span class="term">ssid_len</span></dt><dd><p>
Length of ssid in octets
      </p></dd><dt><span class="term">auth_type</span></dt><dd><p>
Authentication type (algorithm)
      </p></dd><dt><span class="term">ie</span></dt><dd><p>
IEs for association request
      </p></dd><dt><span class="term">ie_len</span></dt><dd><p>
Length of assoc_ie in octets
      </p></dd><dt><span class="term">privacy</span></dt><dd><p>
indicates whether privacy-enabled APs should be used
      </p></dd><dt><span class="term">mfp</span></dt><dd><p>
indicate whether management frame protection is used
      </p></dd><dt><span class="term">crypto</span></dt><dd><p>
crypto settings
      </p></dd><dt><span class="term">key</span></dt><dd><p>
WEP key for shared key authentication
      </p></dd><dt><span class="term">key_len</span></dt><dd><p>
length of WEP key for shared key authentication
      </p></dd><dt><span class="term">key_idx</span></dt><dd><p>
index of WEP key for shared key authentication
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
See <span class="structname">enum</span> cfg80211_assoc_req_flags
      </p></dd><dt><span class="term">bg_scan_period</span></dt><dd><p>
Background scan period in seconds
or -1 to indicate that default value is to be used.
      </p></dd><dt><span class="term">ht_capa</span></dt><dd><p>
HT Capabilities over-rides.  Values set in ht_capa_mask
will be used in ht_capa.  Un-supported values will be ignored.
      </p></dd><dt><span class="term">ht_capa_mask</span></dt><dd><p>
The bits of ht_capa which are to be used.
      </p></dd><dt><span class="term">vht_capa</span></dt><dd><p>
VHT Capability overrides
      </p></dd><dt><span class="term">vht_capa_mask</span></dt><dd><p>
The bits of vht_capa which are to be used.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6046368"></a><h2>Description</h2><p>
   </p><p>

   This structure provides information needed to complete IEEE 802.11
   authentication and association.
</p></div></div><div class="refentry" title="struct cfg80211_pmksa"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-pmksa"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_pmksa — 
  PMK Security Association
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_pmksa {
  u8 * bssid;
  u8 * pmkid;
};  </pre></div><div class="refsect1" title="Members"><a id="idp6054832"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">bssid</span></dt><dd><p>
The AP's BSSID.
      </p></dd><dt><span class="term">pmkid</span></dt><dd><p>
The PMK material itself.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6058544"></a><h2>Description</h2><p>
   </p><p>

   This structure is passed to the set/<code class="function">del_pmksa</code> method for PMKSA
   caching.
</p></div></div><div class="refentry" title="cfg80211_rx_mlme_mgmt"><div class="refentry.separator"><hr></div><a id="API-cfg80211-rx-mlme-mgmt"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_rx_mlme_mgmt — 
  notification of processed MLME management frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_rx_mlme_mgmt </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">buf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">len</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">buf</var></code>;<br><code>size_t <var class="pdparam">len</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6070832"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>buf</code></em></span></dt><dd><p>
     authentication frame (header + body)
    </p></dd><dt><span class="term"><em class="parameter"><code>len</code></em></span></dt><dd><p>
     length of the frame data
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6077696"></a><h2>Description</h2><p>
   This function is called whenever an authentication, disassociation or
   deauthentication frame has been received and processed in station mode.
</p></div><div class="refsect1" title="After being asked to authenticate via cfg80211_ops"><a id="idp6079008"></a><h2>After being asked to authenticate via cfg80211_ops</h2><p>
   :<code class="function">auth</code> the driver must
   call either this function or <code class="function">cfg80211_auth_timeout</code>.
</p></div><div class="refsect1" title="After being asked to associate via cfg80211_ops"><a id="idp6081408"></a><h2>After being asked to associate via cfg80211_ops</h2><p>
   :<code class="function">assoc</code> the driver must
   call either this function or <code class="function">cfg80211_auth_timeout</code>.
   While connected, the driver must calls this for received and processed
   disassociation and deauthentication frames. If the frame couldn't be used
   because it was unprotected, the driver must call the function
   <code class="function">cfg80211_rx_unprot_mlme_mgmt</code> instead.
   </p><p>

   This function may sleep. The caller must hold the corresponding wdev's mutex.
</p></div></div><div class="refentry" title="cfg80211_auth_timeout"><div class="refentry.separator"><hr></div><a id="API-cfg80211-auth-timeout"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_auth_timeout — 
  notification of timed out authentication
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_auth_timeout </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">addr</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6094400"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     The MAC address of the device with which the authentication timed out
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6099456"></a><h2>Description</h2><p>
   This function may sleep. The caller must hold the corresponding wdev's
   mutex.
</p></div></div><div class="refentry" title="cfg80211_rx_assoc_resp"><div class="refentry.separator"><hr></div><a id="API-cfg80211-rx-assoc-resp"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_rx_assoc_resp — 
  notification of processed association response
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_rx_assoc_resp </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bss</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">buf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">len</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>struct cfg80211_bss * <var class="pdparam">bss</var></code>;<br><code>const u8 * <var class="pdparam">buf</var></code>;<br><code>size_t <var class="pdparam">len</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6111840"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>bss</code></em></span></dt><dd><p>
     the BSS that association was requested with, ownership of the pointer
     moves to cfg80211 in this call
    </p></dd><dt><span class="term"><em class="parameter"><code>buf</code></em></span></dt><dd><p>
     authentication frame (header + body)
    </p></dd><dt><span class="term"><em class="parameter"><code>len</code></em></span></dt><dd><p>
     length of the frame data
    </p></dd></dl></div></div><div class="refsect1" title="After being asked to associate via cfg80211_ops"><a id="idp6120736"></a><h2>After being asked to associate via cfg80211_ops</h2><p>
   :<code class="function">assoc</code> the driver must
   call either this function or <code class="function">cfg80211_auth_timeout</code>.
   </p><p>

   This function may sleep. The caller must hold the corresponding wdev's mutex.
</p></div></div><div class="refentry" title="cfg80211_assoc_timeout"><div class="refentry.separator"><hr></div><a id="API-cfg80211-assoc-timeout"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_assoc_timeout — 
  notification of timed out association
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_assoc_timeout </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bss</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>struct cfg80211_bss * <var class="pdparam">bss</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6132864"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>bss</code></em></span></dt><dd><p>
     The BSS entry with which association timed out.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6137904"></a><h2>Description</h2><p>
   This function may sleep. The caller must hold the corresponding wdev's mutex.
</p></div></div><div class="refentry" title="cfg80211_tx_mlme_mgmt"><div class="refentry.separator"><hr></div><a id="API-cfg80211-tx-mlme-mgmt"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_tx_mlme_mgmt — 
  notification of transmitted deauth/disassoc frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_tx_mlme_mgmt </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">buf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">len</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">buf</var></code>;<br><code>size_t <var class="pdparam">len</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6149408"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>buf</code></em></span></dt><dd><p>
     802.11 frame (header + body)
    </p></dd><dt><span class="term"><em class="parameter"><code>len</code></em></span></dt><dd><p>
     length of the frame data
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6156272"></a><h2>Description</h2><p>
   This function is called whenever deauthentication has been processed in
   station mode. This includes both received deauthentication frames and
   locally generated ones. This function may sleep. The caller must hold the
   corresponding wdev's mutex.
</p></div></div><div class="refentry" title="cfg80211_ibss_joined"><div class="refentry.separator"><hr></div><a id="API-cfg80211-ibss-joined"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_ibss_joined — 
  notify cfg80211 that device joined an IBSS
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_ibss_joined </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bssid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">bssid</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6167952"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>bssid</code></em></span></dt><dd><p>
     the BSSID of the IBSS joined
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6174816"></a><h2>Description</h2><p>
   This function notifies cfg80211 that the device joined an IBSS or
   switched to a different BSSID. Before this function can be called,
   either a beacon has to have been received from the IBSS, or one of
   the cfg80211_inform_bss{,_frame} functions must have been called
   with the locally generated beacon -- this guarantees that there is
   always a scan result for this IBSS. cfg80211 will handle the rest.
</p></div></div><div class="refentry" title="cfg80211_connect_result"><div class="refentry.separator"><hr></div><a id="API-cfg80211-connect-result"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_connect_result — 
  notify cfg80211 of connection result
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_connect_result </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bssid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">req_ie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">req_ie_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">resp_ie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">resp_ie_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">status</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">bssid</var></code>;<br><code>const u8 * <var class="pdparam">req_ie</var></code>;<br><code>size_t <var class="pdparam">req_ie_len</var></code>;<br><code>const u8 * <var class="pdparam">resp_ie</var></code>;<br><code>size_t <var class="pdparam">resp_ie_len</var></code>;<br><code>u16 <var class="pdparam">status</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6191056"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>bssid</code></em></span></dt><dd><p>
     the BSSID of the AP
    </p></dd><dt><span class="term"><em class="parameter"><code>req_ie</code></em></span></dt><dd><p>
     association request IEs (maybe be <code class="constant">NULL</code>)
    </p></dd><dt><span class="term"><em class="parameter"><code>req_ie_len</code></em></span></dt><dd><p>
     association request IEs length
    </p></dd><dt><span class="term"><em class="parameter"><code>resp_ie</code></em></span></dt><dd><p>
     association response IEs (may be <code class="constant">NULL</code>)
    </p></dd><dt><span class="term"><em class="parameter"><code>resp_ie_len</code></em></span></dt><dd><p>
     assoc response IEs length
    </p></dd><dt><span class="term"><em class="parameter"><code>status</code></em></span></dt><dd><p>
     status code, 0 for successful connection, use
     <code class="constant">WLAN_STATUS_UNSPECIFIED_FAILURE</code> if your device cannot give you
     the real status code for failures.
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6208768"></a><h2>Description</h2><p>
   It should be called by the underlying driver whenever <code class="function">connect</code> has
   succeeded.
</p></div></div><div class="refentry" title="cfg80211_roamed"><div class="refentry.separator"><hr></div><a id="API-cfg80211-roamed"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_roamed — 
  notify cfg80211 of roaming
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_roamed </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">channel</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bssid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">req_ie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">req_ie_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">resp_ie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">resp_ie_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>struct ieee80211_channel * <var class="pdparam">channel</var></code>;<br><code>const u8 * <var class="pdparam">bssid</var></code>;<br><code>const u8 * <var class="pdparam">req_ie</var></code>;<br><code>size_t <var class="pdparam">req_ie_len</var></code>;<br><code>const u8 * <var class="pdparam">resp_ie</var></code>;<br><code>size_t <var class="pdparam">resp_ie_len</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6225280"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>channel</code></em></span></dt><dd><p>
     the channel of the new AP
    </p></dd><dt><span class="term"><em class="parameter"><code>bssid</code></em></span></dt><dd><p>
     the BSSID of the new AP
    </p></dd><dt><span class="term"><em class="parameter"><code>req_ie</code></em></span></dt><dd><p>
     association request IEs (maybe be <code class="constant">NULL</code>)
    </p></dd><dt><span class="term"><em class="parameter"><code>req_ie_len</code></em></span></dt><dd><p>
     association request IEs length
    </p></dd><dt><span class="term"><em class="parameter"><code>resp_ie</code></em></span></dt><dd><p>
     association response IEs (may be <code class="constant">NULL</code>)
    </p></dd><dt><span class="term"><em class="parameter"><code>resp_ie_len</code></em></span></dt><dd><p>
     assoc response IEs length
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6242432"></a><h2>Description</h2><p>
   It should be called by the underlying driver whenever it roamed
   from one AP to another while connected.
</p></div></div><div class="refentry" title="cfg80211_disconnected"><div class="refentry.separator"><hr></div><a id="API-cfg80211-disconnected"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_disconnected — 
  notify cfg80211 that connection was dropped
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_disconnected </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">reason</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ie_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>u16 <var class="pdparam">reason</var></code>;<br><code>u8 * <var class="pdparam">ie</var></code>;<br><code>size_t <var class="pdparam">ie_len</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6255728"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>reason</code></em></span></dt><dd><p>
     reason code for the disconnection, set it to 0 if unknown
    </p></dd><dt><span class="term"><em class="parameter"><code>ie</code></em></span></dt><dd><p>
     information elements of the deauth/disassoc frame (may be <code class="constant">NULL</code>)
    </p></dd><dt><span class="term"><em class="parameter"><code>ie_len</code></em></span></dt><dd><p>
     length of IEs
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6266944"></a><h2>Description</h2><p>
   After it calls this function, the driver should enter an idle state
   and not try to connect to any AP any more.
</p></div></div><div class="refentry" title="cfg80211_ready_on_channel"><div class="refentry.separator"><hr></div><a id="API-cfg80211-ready-on-channel"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_ready_on_channel — 
  notification of remain_on_channel start
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_ready_on_channel </strong>(</code></td><td><var class="pdparam">wdev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">cookie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">chan</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">duration</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wireless_dev * <var class="pdparam">wdev</var></code>;<br><code>u64 <var class="pdparam">cookie</var></code>;<br><code>struct ieee80211_channel * <var class="pdparam">chan</var></code>;<br><code>unsigned int <var class="pdparam">duration</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6280240"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wdev</code></em></span></dt><dd><p>
     wireless device
    </p></dd><dt><span class="term"><em class="parameter"><code>cookie</code></em></span></dt><dd><p>
     the request cookie
    </p></dd><dt><span class="term"><em class="parameter"><code>chan</code></em></span></dt><dd><p>
     The current channel (from remain_on_channel request)
    </p></dd><dt><span class="term"><em class="parameter"><code>duration</code></em></span></dt><dd><p>
     Duration in milliseconds that the driver intents to remain on the
     channel
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div></div><div class="refentry" title="cfg80211_remain_on_channel_expired"><div class="refentry.separator"><hr></div><a id="API-cfg80211-remain-on-channel-expired"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_remain_on_channel_expired — 
  remain_on_channel duration expired
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_remain_on_channel_expired </strong>(</code></td><td><var class="pdparam">wdev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">cookie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">chan</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wireless_dev * <var class="pdparam">wdev</var></code>;<br><code>u64 <var class="pdparam">cookie</var></code>;<br><code>struct ieee80211_channel * <var class="pdparam">chan</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6302240"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wdev</code></em></span></dt><dd><p>
     wireless device
    </p></dd><dt><span class="term"><em class="parameter"><code>cookie</code></em></span></dt><dd><p>
     the request cookie
    </p></dd><dt><span class="term"><em class="parameter"><code>chan</code></em></span></dt><dd><p>
     The current channel (from remain_on_channel request)
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div></div><div class="refentry" title="cfg80211_new_sta"><div class="refentry.separator"><hr></div><a id="API-cfg80211-new-sta"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_new_sta — 
  notify userspace about station
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_new_sta </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">mac_addr</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">sinfo</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">mac_addr</var></code>;<br><code>struct station_info * <var class="pdparam">sinfo</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6322224"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     the netdev
    </p></dd><dt><span class="term"><em class="parameter"><code>mac_addr</code></em></span></dt><dd><p>
     the station's address
    </p></dd><dt><span class="term"><em class="parameter"><code>sinfo</code></em></span></dt><dd><p>
     the station information
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div></div><div class="refentry" title="cfg80211_rx_mgmt"><div class="refentry.separator"><hr></div><a id="API-cfg80211-rx-mgmt"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_rx_mgmt — 
  notification of received, unprocessed management frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">bool <strong>fsfunccfg80211_rx_mgmt </strong>(</code></td><td><var class="pdparam">wdev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">freq</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">sig_dbm</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">buf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">flags</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wireless_dev * <var class="pdparam">wdev</var></code>;<br><code>int <var class="pdparam">freq</var></code>;<br><code>int <var class="pdparam">sig_dbm</var></code>;<br><code>const u8 * <var class="pdparam">buf</var></code>;<br><code>size_t <var class="pdparam">len</var></code>;<br><code>u32 <var class="pdparam">flags</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6344848"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wdev</code></em></span></dt><dd><p>
     wireless device receiving the frame
    </p></dd><dt><span class="term"><em class="parameter"><code>freq</code></em></span></dt><dd><p>
     Frequency on which the frame was received in MHz
    </p></dd><dt><span class="term"><em class="parameter"><code>sig_dbm</code></em></span></dt><dd><p>
     signal strength in mBm, or 0 if unknown
    </p></dd><dt><span class="term"><em class="parameter"><code>buf</code></em></span></dt><dd><p>
     Management frame (header + body)
    </p></dd><dt><span class="term"><em class="parameter"><code>len</code></em></span></dt><dd><p>
     length of the frame data
    </p></dd><dt><span class="term"><em class="parameter"><code>flags</code></em></span></dt><dd><p>
     flags, as defined in enum nl80211_rxmgmt_flags
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     context flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6359488"></a><h2>Description</h2><p>
   This function is called whenever an Action frame is received for a station
   mode interface, but is not processed in kernel.
</p></div><div class="refsect1" title="Return"><a id="idp6360784"></a><h2>Return</h2><p>
   <code class="constant">true</code> if a user space application has registered for this frame.
   For action frames, that makes it responsible for rejecting unrecognized
   action frames; <code class="constant">false</code> otherwise, in which case for action frames the
   driver is responsible for rejecting the frame.
</p></div></div><div class="refentry" title="cfg80211_mgmt_tx_status"><div class="refentry.separator"><hr></div><a id="API-cfg80211-mgmt-tx-status"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_mgmt_tx_status — 
  notification of TX status for management frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_mgmt_tx_status </strong>(</code></td><td><var class="pdparam">wdev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">cookie</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">buf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ack</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wireless_dev * <var class="pdparam">wdev</var></code>;<br><code>u64 <var class="pdparam">cookie</var></code>;<br><code>const u8 * <var class="pdparam">buf</var></code>;<br><code>size_t <var class="pdparam">len</var></code>;<br><code>bool <var class="pdparam">ack</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6375888"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wdev</code></em></span></dt><dd><p>
     wireless device receiving the frame
    </p></dd><dt><span class="term"><em class="parameter"><code>cookie</code></em></span></dt><dd><p>
     Cookie returned by cfg80211_ops::<code class="function">mgmt_tx</code>
    </p></dd><dt><span class="term"><em class="parameter"><code>buf</code></em></span></dt><dd><p>
     Management frame (header + body)
    </p></dd><dt><span class="term"><em class="parameter"><code>len</code></em></span></dt><dd><p>
     length of the frame data
    </p></dd><dt><span class="term"><em class="parameter"><code>ack</code></em></span></dt><dd><p>
     Whether frame was acknowledged
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     context flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6389088"></a><h2>Description</h2><p>
   This function is called whenever a management frame was requested to be
</p></div><div class="refsect1" title="transmitted with cfg80211_ops"><a id="idp6390336"></a><h2>transmitted with cfg80211_ops</h2><p>
   :<code class="function">mgmt_tx</code> to report the TX status of the
   transmission attempt.
</p></div></div><div class="refentry" title="cfg80211_cqm_rssi_notify"><div class="refentry.separator"><hr></div><a id="API-cfg80211-cqm-rssi-notify"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_cqm_rssi_notify — 
  connection quality monitoring rssi event
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_cqm_rssi_notify </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">rssi_event</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>enum nl80211_cqm_rssi_threshold_event <var class="pdparam">rssi_event</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6402448"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>rssi_event</code></em></span></dt><dd><p>
     the triggered RSSI event
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     context flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6409312"></a><h2>Description</h2><p>
   This function is called when a configured connection quality monitoring
   rssi threshold reached event occurs.
</p></div></div><div class="refentry" title="cfg80211_cqm_pktloss_notify"><div class="refentry.separator"><hr></div><a id="API-cfg80211-cqm-pktloss-notify"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_cqm_pktloss_notify — 
  notify userspace about packetloss to peer
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_cqm_pktloss_notify </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">peer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">num_packets</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">peer</var></code>;<br><code>u32 <var class="pdparam">num_packets</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6421728"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>peer</code></em></span></dt><dd><p>
     peer's MAC address
    </p></dd><dt><span class="term"><em class="parameter"><code>num_packets</code></em></span></dt><dd><p>
     how many packets were lost -- should be a fixed threshold
     but probably no less than maybe 50, or maybe a throughput dependent
     threshold (to account for temporary interference)
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     context flags
    </p></dd></dl></div></div></div><div class="refentry" title="cfg80211_michael_mic_failure"><div class="refentry.separator"><hr></div><a id="API-cfg80211-michael-mic-failure"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_michael_mic_failure — 
  notification of Michael MIC failure (TKIP)
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_michael_mic_failure </strong>(</code></td><td><var class="pdparam">dev</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">key_type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">key_id</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tsc</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct net_device * <var class="pdparam">dev</var></code>;<br><code>const u8 * <var class="pdparam">addr</var></code>;<br><code>enum nl80211_key_type <var class="pdparam">key_type</var></code>;<br><code>int <var class="pdparam">key_id</var></code>;<br><code>const u8 * <var class="pdparam">tsc</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6443600"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     network device
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     The source MAC address of the frame
    </p></dd><dt><span class="term"><em class="parameter"><code>key_type</code></em></span></dt><dd><p>
     The key type that the received frame used
    </p></dd><dt><span class="term"><em class="parameter"><code>key_id</code></em></span></dt><dd><p>
     Key identifier (0..3). Can be -1 if missing.
    </p></dd><dt><span class="term"><em class="parameter"><code>tsc</code></em></span></dt><dd><p>
     The TSC value of the frame that generated the MIC failure (6 octets)
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6456272"></a><h2>Description</h2><p>
   This function is called whenever the local MAC detects a MIC failure in a
   received frame. This matches with MLME-MICHAELMICFAILURE.<code class="function">indication</code>
   primitive.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Scanning and BSS list handling"><div class="titlepage"><div><div><h2 class="title"><a id="idp6458464"></a>Chapter&nbsp;3.&nbsp;Scanning and BSS list handling</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-ssid"><span>struct cfg80211_ssid</span></a></span><span class="refpurpose"> — 
  SSID description
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-scan-request"><span>struct cfg80211_scan_request</span></a></span><span class="refpurpose"> — 
  scan request description
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-scan-done"><span>cfg80211_scan_done</span></a></span><span class="refpurpose"> — 
  notify that scan finished
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-cfg80211-bss"><span>struct cfg80211_bss</span></a></span><span class="refpurpose"> — 
  BSS description
 </span></dt><dt><span class="refentrytitle"><a href="#idp6542112">
   /home/landley/linux/linux//include/net/cfg80211.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#idp6546128">
   /home/landley/linux/linux//include/net/cfg80211.h
  </a></span><span class="refpurpose"> — 
   Document generation inconsistency
  </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-unlink-bss"><span>cfg80211_unlink_bss</span></a></span><span class="refpurpose"> — 
  unlink BSS from internal data structures
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-find-ie"><span>cfg80211_find_ie</span></a></span><span class="refpurpose"> — 
  find information element in data
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-bss-get-ie"><span>ieee80211_bss_get_ie</span></a></span><span class="refpurpose"> — 
  find IE with given ID
 </span></dt></dl></div><p>
   </p><p>
   The scanning process itself is fairly simple, but cfg80211 offers quite
   a bit of helper functionality. To start a scan, the scan operation will
   be invoked with a scan definition. This scan definition contains the
   channels to scan, and the SSIDs to send probe requests for (including the
   wildcard, if desired). A passive scan is indicated by having no SSIDs to
   probe. Additionally, a scan request may contain extra information elements
   that should be added to the probe request. The IEs are guaranteed to be
   well-formed, and will not exceed the maximum length the driver advertised
   in the wiphy structure.
   </p><p>
   When scanning finds a BSS, cfg80211 needs to be notified of that, because
   it is responsible for maintaining the BSS list; the driver should not
   maintain a list itself. For this notification, various functions exist.
   </p><p>
   Since drivers do not maintain a BSS list, there are also a number of
   functions to search for a BSS and obtain information about it from the
   BSS structure cfg80211 maintains. The BSS list is also made available
   to userspace.
</p><div class="refentry" title="struct cfg80211_ssid"><a id="API-struct-cfg80211-ssid"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_ssid — 
  SSID description
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_ssid {
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len;
};  </pre></div><div class="refsect1" title="Members"><a id="idp6468224"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">ssid[IEEE80211_MAX_SSID_LEN]</span></dt><dd><p>
the SSID
      </p></dd><dt><span class="term">ssid_len</span></dt><dd><p>
length of the ssid
      </p></dd></dl></div></div></div><div class="refentry" title="struct cfg80211_scan_request"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-scan-request"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_scan_request — 
  scan request description
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_scan_request {
  struct cfg80211_ssid * ssids;
  int n_ssids;
  u32 n_channels;
  enum nl80211_bss_scan_width scan_width;
  const u8 * ie;
  size_t ie_len;
  u32 flags;
  u32 rates[IEEE80211_NUM_BANDS];
  struct wireless_dev * wdev;
  struct wiphy * wiphy;
  unsigned long scan_start;
  bool aborted;
  bool notified;
  bool no_cck;
  struct ieee80211_channel * channels[0];
};  </pre></div><div class="refsect1" title="Members"><a id="idp6479200"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">ssids</span></dt><dd><p>
SSIDs to scan for (active scan only)
      </p></dd><dt><span class="term">n_ssids</span></dt><dd><p>
number of SSIDs
      </p></dd><dt><span class="term">n_channels</span></dt><dd><p>
total number of channels to scan
      </p></dd><dt><span class="term">scan_width</span></dt><dd><p>
channel width for scanning
      </p></dd><dt><span class="term">ie</span></dt><dd><p>
optional information element(s) to add into Probe Request or <code class="constant">NULL</code>
      </p></dd><dt><span class="term">ie_len</span></dt><dd><p>
length of ie in octets
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
bit field of flags controlling operation
      </p></dd><dt><span class="term">rates[IEEE80211_NUM_BANDS]</span></dt><dd><p>
bitmap of rates to advertise for each band
      </p></dd><dt><span class="term">wdev</span></dt><dd><p>
the wireless device to scan for
      </p></dd><dt><span class="term">wiphy</span></dt><dd><p>
the wiphy this was for
      </p></dd><dt><span class="term">scan_start</span></dt><dd><p>
time (in jiffies) when the scan started
      </p></dd><dt><span class="term">aborted</span></dt><dd><p>
(internal) scan request was notified as aborted
      </p></dd><dt><span class="term">notified</span></dt><dd><p>
(internal) scan request was notified as done or aborted
      </p></dd><dt><span class="term">no_cck</span></dt><dd><p>
used to send probe requests at non CCK rate in 2GHz band
      </p></dd><dt><span class="term">channels[0]</span></dt><dd><p>
channels to scan on.
      </p></dd></dl></div></div></div><div class="refentry" title="cfg80211_scan_done"><div class="refentry.separator"><hr></div><a id="API-cfg80211-scan-done"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_scan_done — 
  notify that scan finished
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_scan_done </strong>(</code></td><td><var class="pdparam">request</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">aborted</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct cfg80211_scan_request * <var class="pdparam">request</var></code>;<br><code>bool <var class="pdparam">aborted</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6509552"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>
     the corresponding scan request
    </p></dd><dt><span class="term"><em class="parameter"><code>aborted</code></em></span></dt><dd><p>
     set to true if the scan was aborted for any reason,
     userspace will be notified of that
    </p></dd></dl></div></div></div><div class="refentry" title="struct cfg80211_bss"><div class="refentry.separator"><hr></div><a id="API-struct-cfg80211-bss"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct cfg80211_bss — 
  BSS description
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct cfg80211_bss {
  struct ieee80211_channel * channel;
  enum nl80211_bss_scan_width scan_width;
  const struct cfg80211_bss_ies __rcu * ies;
  const struct cfg80211_bss_ies __rcu * beacon_ies;
  const struct cfg80211_bss_ies __rcu * proberesp_ies;
  struct cfg80211_bss * hidden_beacon_bss;
  s32 signal;
  u16 beacon_interval;
  u16 capability;
  u8 bssid[ETH_ALEN];
  u8 priv[0];
};  </pre></div><div class="refsect1" title="Members"><a id="idp6521888"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">channel</span></dt><dd><p>
channel this BSS is on
      </p></dd><dt><span class="term">scan_width</span></dt><dd><p>
width of the control channel
      </p></dd><dt><span class="term">ies</span></dt><dd><p>
the information elements (Note that there is no guarantee that these
are well-formed!); this is a pointer to either the beacon_ies or
proberesp_ies depending on whether Probe Response frame has been
received. It is always non-<code class="constant">NULL</code>.
      </p></dd><dt><span class="term">beacon_ies</span></dt><dd><p>
the information elements from the last Beacon frame
(implementation note: if <em class="parameter"><code>hidden_beacon_bss</code></em> is set this struct doesn't
own the beacon_ies, but they're just pointers to the ones from the
<em class="parameter"><code>hidden_beacon_bss</code></em> struct)
      </p></dd><dt><span class="term">proberesp_ies</span></dt><dd><p>
the information elements from the last Probe Response frame
      </p></dd><dt><span class="term">hidden_beacon_bss</span></dt><dd><p>
in case this BSS struct represents a probe response from
a BSS that hides the SSID in its beacon, this points to the BSS struct
that holds the beacon data. <em class="parameter"><code>beacon_ies</code></em> is still valid, of course, and
points to the same data as hidden_beacon_bss-&gt;beacon_ies in that case.
      </p></dd><dt><span class="term">signal</span></dt><dd><p>
signal strength value (type depends on the wiphy's signal_type)
      </p></dd><dt><span class="term">beacon_interval</span></dt><dd><p>
the beacon interval as from the frame
      </p></dd><dt><span class="term">capability</span></dt><dd><p>
the capability field in host byte order
      </p></dd><dt><span class="term">bssid[ETH_ALEN]</span></dt><dd><p>
BSSID of the BSS
      </p></dd><dt><span class="term">priv[0]</span></dt><dd><p>
private area for driver use, has at least wiphy-&gt;bss_priv_size bytes
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6540448"></a><h2>Description</h2><p>
   </p><p>

   This structure describes a BSS (which may also be a mesh network)
   for use in scan results and similar.
</p></div></div><div class="refentry" title="/home/landley/linux/linux//include/net/cfg80211.h"><div class="refentry.separator"><hr></div><a id="idp6542112"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
   /home/landley/linux/linux//include/net/cfg80211.h
   — 
   Document generation inconsistency
  </p></div><div class="refsect1" title="Oops"><a id="idp6543600"></a><h2>
   Oops
  </h2><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
    The template for this document tried to insert
    the structured comment from the file
    <code class="filename">/home/landley/linux/linux//include/net/cfg80211.h</code> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </p></div></div></div><div class="refentry" title="/home/landley/linux/linux//include/net/cfg80211.h"><div class="refentry.separator"><hr></div><a id="idp6546128"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
   /home/landley/linux/linux//include/net/cfg80211.h
   — 
   Document generation inconsistency
  </p></div><div class="refsect1" title="Oops"><a id="idp6547616"></a><h2>
   Oops
  </h2><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
    The template for this document tried to insert
    the structured comment from the file
    <code class="filename">/home/landley/linux/linux//include/net/cfg80211.h</code> at this point,
    but none was found.
    This dummy section is inserted to allow
    generation to continue.
   </p></div></div></div><div class="refentry" title="cfg80211_unlink_bss"><div class="refentry.separator"><hr></div><a id="API-cfg80211-unlink-bss"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_unlink_bss — 
  unlink BSS from internal data structures
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_unlink_bss </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bss</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>struct cfg80211_bss * <var class="pdparam">bss</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6559392"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy
    </p></dd><dt><span class="term"><em class="parameter"><code>bss</code></em></span></dt><dd><p>
     the bss to remove
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6564352"></a><h2>Description</h2><p>
   This function removes the given BSS from the internal data structures
   thereby making it no longer show up in scan results etc. Use this
   function when you detect a BSS is gone. Normally BSSes will also time
   out, so it is not necessary to use this function at all.
</p></div></div><div class="refentry" title="cfg80211_find_ie"><div class="refentry.separator"><hr></div><a id="API-cfg80211-find-ie"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_find_ie — 
  find information element in data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">const u8 * <strong>fsfunccfg80211_find_ie </strong>(</code></td><td><var class="pdparam">eid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ies</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">len</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>u8 <var class="pdparam">eid</var></code>;<br><code>const u8 * <var class="pdparam">ies</var></code>;<br><code>int <var class="pdparam">len</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6576048"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>eid</code></em></span></dt><dd><p>
     element ID
    </p></dd><dt><span class="term"><em class="parameter"><code>ies</code></em></span></dt><dd><p>
     data consisting of IEs
    </p></dd><dt><span class="term"><em class="parameter"><code>len</code></em></span></dt><dd><p>
     length of data
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6582912"></a><h2>Return</h2><p>
   <code class="constant">NULL</code> if the element ID could not be found or if
   the element is invalid (claims to be longer than the given
   data), or a pointer to the first byte of the requested
   element, that is the byte containing the element ID.
</p></div><div class="refsect1" title="Note"><a id="idp6584688"></a><h2>Note</h2><p>
   There are no checks on the element length other than
   having to fit into the given data.
</p></div></div><div class="refentry" title="ieee80211_bss_get_ie"><div class="refentry.separator"><hr></div><a id="API-ieee80211-bss-get-ie"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_bss_get_ie — 
  find IE with given ID
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">const u8 * <strong>fsfuncieee80211_bss_get_ie </strong>(</code></td><td><var class="pdparam">bss</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ie</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct cfg80211_bss * <var class="pdparam">bss</var></code>;<br><code>u8 <var class="pdparam">ie</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6595328"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>bss</code></em></span></dt><dd><p>
     the bss to search
    </p></dd><dt><span class="term"><em class="parameter"><code>ie</code></em></span></dt><dd><p>
     the IE ID
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6600288"></a><h2>Description</h2><p>
   Note that the return value is an RCU-protected pointer, so
   <code class="function">rcu_read_lock</code> must be held when calling this function.
</p></div><div class="refsect1" title="Return"><a id="idp6602144"></a><h2>Return</h2><p>
   <code class="constant">NULL</code> if not found.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Utility functions"><div class="titlepage"><div><div><h2 class="title"><a id="idp6603936"></a>Chapter&nbsp;4.&nbsp;Utility functions</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-channel-to-frequency"><span>ieee80211_channel_to_frequency</span></a></span><span class="refpurpose"> — 
  convert channel number to frequency
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-frequency-to-channel"><span>ieee80211_frequency_to_channel</span></a></span><span class="refpurpose"> — 
  convert frequency to channel number
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-channel"><span>ieee80211_get_channel</span></a></span><span class="refpurpose"> — 
  get channel struct from wiphy for specified frequency
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-response-rate"><span>ieee80211_get_response_rate</span></a></span><span class="refpurpose"> — 
  get basic rate for a given rate
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-hdrlen"><span>ieee80211_hdrlen</span></a></span><span class="refpurpose"> — 
  get header length in bytes from frame control
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-hdrlen-from-skb"><span>ieee80211_get_hdrlen_from_skb</span></a></span><span class="refpurpose"> — 
  get header length from data
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-radiotap-iterator"><span>struct ieee80211_radiotap_iterator</span></a></span><span class="refpurpose"> — 
  tracks walk thru present radiotap args
 </span></dt></dl></div><p>
   </p><p>
   cfg80211 offers a number of utility functions that can be useful.
</p><div class="refentry" title="ieee80211_channel_to_frequency"><a id="API-ieee80211-channel-to-frequency"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_channel_to_frequency — 
  convert channel number to frequency
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_channel_to_frequency </strong>(</code></td><td><var class="pdparam">chan</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">band</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>int <var class="pdparam">chan</var></code>;<br><code>enum ieee80211_band <var class="pdparam">band</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6614544"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>chan</code></em></span></dt><dd><p>
     channel number
    </p></dd><dt><span class="term"><em class="parameter"><code>band</code></em></span></dt><dd><p>
     band, necessary due to channel number overlap
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6619584"></a><h2>Return</h2><p>
   The corresponding frequency (in MHz), or 0 if the conversion failed.
</p></div></div><div class="refentry" title="ieee80211_frequency_to_channel"><div class="refentry.separator"><hr></div><a id="API-ieee80211-frequency-to-channel"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_frequency_to_channel — 
  convert frequency to channel number
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_frequency_to_channel </strong>(</code></td><td><var class="pdparam">freq</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>int <var class="pdparam">freq</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6629328"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>freq</code></em></span></dt><dd><p>
     center frequency
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6632384"></a><h2>Return</h2><p>
   The corresponding channel, or 0 if the conversion failed.
</p></div></div><div class="refentry" title="ieee80211_get_channel"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-channel"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_channel — 
  get channel struct from wiphy for specified frequency
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct ieee80211_channel * <strong>fsfuncieee80211_get_channel </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">freq</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>int <var class="pdparam">freq</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6643072"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the struct wiphy to get the channel for
    </p></dd><dt><span class="term"><em class="parameter"><code>freq</code></em></span></dt><dd><p>
     the center frequency of the channel
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6648032"></a><h2>Return</h2><p>
   The channel struct from <em class="parameter"><code>wiphy</code></em> at <em class="parameter"><code>freq</code></em>.
</p></div></div><div class="refentry" title="ieee80211_get_response_rate"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-response-rate"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_response_rate — 
  get basic rate for a given rate
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct ieee80211_rate * <strong>fsfuncieee80211_get_response_rate </strong>(</code></td><td><var class="pdparam">sband</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">basic_rates</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bitrate</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_supported_band * <var class="pdparam">sband</var></code>;<br><code>u32 <var class="pdparam">basic_rates</var></code>;<br><code>int <var class="pdparam">bitrate</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6660688"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>sband</code></em></span></dt><dd><p>
     the band to look for rates in
    </p></dd><dt><span class="term"><em class="parameter"><code>basic_rates</code></em></span></dt><dd><p>
     bitmap of basic rates
    </p></dd><dt><span class="term"><em class="parameter"><code>bitrate</code></em></span></dt><dd><p>
     the bitrate for which to find the basic rate
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6667552"></a><h2>Return</h2><p>
   The basic rate corresponding to a given bitrate, that
   is the next lower bitrate contained in the basic rate map,
   which is, for this function, given as a bitmap of indices of
   rates in the band's bitrate table.
</p></div></div><div class="refentry" title="ieee80211_hdrlen"><div class="refentry.separator"><hr></div><a id="API-ieee80211-hdrlen"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_hdrlen — 
  get header length in bytes from frame control
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">unsigned int __attribute_const__ <strong>fsfuncieee80211_hdrlen </strong>(</code></td><td><var class="pdparam">fc</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>__le16 <var class="pdparam">fc</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6677440"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>fc</code></em></span></dt><dd><p>
     frame control field in little-endian format
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6680496"></a><h2>Return</h2><p>
   The header length in bytes.
</p></div></div><div class="refentry" title="ieee80211_get_hdrlen_from_skb"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-hdrlen-from-skb"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_hdrlen_from_skb — 
  get header length from data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">unsigned int <strong>fsfuncieee80211_get_hdrlen_from_skb </strong>(</code></td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>const struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6690144"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the frame
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6693200"></a><h2>Description</h2><p>
   Given an skb with a raw 802.11 header at the data pointer this function
   returns the 802.11 header length.
</p></div><div class="refsect1" title="Return"><a id="idp6694480"></a><h2>Return</h2><p>
   The 802.11 header length in bytes (not including encryption
   headers). Or 0 if the data in the sk_buff is too short to contain a valid
   802.11 header.
</p></div></div><div class="refentry" title="struct ieee80211_radiotap_iterator"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-radiotap-iterator"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_radiotap_iterator — 
  tracks walk thru present radiotap args
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_radiotap_iterator {
  struct ieee80211_radiotap_header * _rtheader;
  const struct ieee80211_radiotap_vendor_namespaces * _vns;
  const struct ieee80211_radiotap_namespace * current_namespace;
  unsigned char * _arg;
  unsigned char * _next_ns_data;
  __le32 * _next_bitmap;
  unsigned char * this_arg;
  int this_arg_index;
  int this_arg_size;
  int is_radiotap_ns;
  int _max_length;
  int _arg_index;
  uint32_t _bitmap_shifter;
  int _reset_on_ext;
};  </pre></div><div class="refsect1" title="Members"><a id="idp6703152"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">_rtheader</span></dt><dd><p>
pointer to the radiotap header we are walking through
      </p></dd><dt><span class="term">_vns</span></dt><dd><p>
vendor namespace definitions
      </p></dd><dt><span class="term">current_namespace</span></dt><dd><p>
pointer to the current namespace definition
(or internally <code class="constant">NULL</code> if the current namespace is unknown)
      </p></dd><dt><span class="term">_arg</span></dt><dd><p>
next argument pointer
      </p></dd><dt><span class="term">_next_ns_data</span></dt><dd><p>
beginning of the next namespace's data
      </p></dd><dt><span class="term">_next_bitmap</span></dt><dd><p>
internal pointer to next present u32
      </p></dd><dt><span class="term">this_arg</span></dt><dd><p>
pointer to current radiotap arg; it is valid after each
call to <code class="function">ieee80211_radiotap_iterator_next</code> but also after
<code class="function">ieee80211_radiotap_iterator_init</code> where it will point to
the beginning of the actual data portion
      </p></dd><dt><span class="term">this_arg_index</span></dt><dd><p>
index of current arg, valid after each successful call
to <code class="function">ieee80211_radiotap_iterator_next</code>
      </p></dd><dt><span class="term">this_arg_size</span></dt><dd><p>
length of the current arg, for convenience
      </p></dd><dt><span class="term">is_radiotap_ns</span></dt><dd><p>
indicates whether the current namespace is the default
radiotap namespace or not
      </p></dd><dt><span class="term">_max_length</span></dt><dd><p>
length of radiotap header in cpu byte ordering
      </p></dd><dt><span class="term">_arg_index</span></dt><dd><p>
next argument index
      </p></dd><dt><span class="term">_bitmap_shifter</span></dt><dd><p>
internal shifter for curr u32 bitmap, b0 set == arg present
      </p></dd><dt><span class="term">_reset_on_ext</span></dt><dd><p>
internal; reset the arg index to 0 when going to the
next bitmap word
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6725168"></a><h2>Description</h2><p>
   Describes the radiotap parser state. Fields prefixed with an underscore
   must not be used by users of the parser, only by the parser internally.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Data path helpers"><div class="titlepage"><div><div><h2 class="title"><a id="idp6726736"></a>Chapter&nbsp;5.&nbsp;Data path helpers</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-data-to-8023"><span>ieee80211_data_to_8023</span></a></span><span class="refpurpose"> — 
  convert an 802.11 data frame to 802.3
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-data-from-8023"><span>ieee80211_data_from_8023</span></a></span><span class="refpurpose"> — 
  convert an 802.3 frame to 802.11
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-amsdu-to-8023s"><span>ieee80211_amsdu_to_8023s</span></a></span><span class="refpurpose"> — 
  decode an IEEE 802.11n A-MSDU frame
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-classify8021d"><span>cfg80211_classify8021d</span></a></span><span class="refpurpose"> — 
  determine the 802.1p/1d tag for a data frame
 </span></dt></dl></div><p>
   </p><p>
   In addition to generic utilities, cfg80211 also offers
   functions that help implement the data path for devices
   that do not do the 802.11/802.3 conversion on the device.
</p><div class="refentry" title="ieee80211_data_to_8023"><a id="API-ieee80211-data-to-8023"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_data_to_8023 — 
  convert an 802.11 data frame to 802.3
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_data_to_8023 </strong>(</code></td><td><var class="pdparam">skb</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iftype</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct sk_buff * <var class="pdparam">skb</var></code>;<br><code>const u8 * <var class="pdparam">addr</var></code>;<br><code>enum nl80211_iftype <var class="pdparam">iftype</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6738336"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the 802.11 data frame
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     the device MAC address
    </p></dd><dt><span class="term"><em class="parameter"><code>iftype</code></em></span></dt><dd><p>
     the virtual interface type
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6745200"></a><h2>Return</h2><p>
   0 on success. Non-zero on error.
</p></div></div><div class="refentry" title="ieee80211_data_from_8023"><div class="refentry.separator"><hr></div><a id="API-ieee80211-data-from-8023"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_data_from_8023 — 
  convert an 802.3 frame to 802.11
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_data_from_8023 </strong>(</code></td><td><var class="pdparam">skb</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iftype</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">bssid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">qos</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct sk_buff * <var class="pdparam">skb</var></code>;<br><code>const u8 * <var class="pdparam">addr</var></code>;<br><code>enum nl80211_iftype <var class="pdparam">iftype</var></code>;<br><code>u8 * <var class="pdparam">bssid</var></code>;<br><code>bool <var class="pdparam">qos</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6759040"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the 802.3 frame
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     the device MAC address
    </p></dd><dt><span class="term"><em class="parameter"><code>iftype</code></em></span></dt><dd><p>
     the virtual interface type
    </p></dd><dt><span class="term"><em class="parameter"><code>bssid</code></em></span></dt><dd><p>
     the network bssid (used only for iftype STATION and ADHOC)
    </p></dd><dt><span class="term"><em class="parameter"><code>qos</code></em></span></dt><dd><p>
     build 802.11 QoS data frame
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6770272"></a><h2>Return</h2><p>
   0 on success, or a negative error code.
</p></div></div><div class="refentry" title="ieee80211_amsdu_to_8023s"><div class="refentry.separator"><hr></div><a id="API-ieee80211-amsdu-to-8023s"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_amsdu_to_8023s — 
  decode an IEEE 802.11n A-MSDU frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_amsdu_to_8023s </strong>(</code></td><td><var class="pdparam">skb</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">list</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iftype</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">extra_headroom</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">has_80211_header</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct sk_buff * <var class="pdparam">skb</var></code>;<br><code>struct sk_buff_head * <var class="pdparam">list</var></code>;<br><code>const u8 * <var class="pdparam">addr</var></code>;<br><code>enum nl80211_iftype <var class="pdparam">iftype</var></code>;<br><code>const unsigned int <var class="pdparam">extra_headroom</var></code>;<br><code>bool <var class="pdparam">has_80211_header</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6785600"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     The input IEEE 802.11n A-MSDU frame.
    </p></dd><dt><span class="term"><em class="parameter"><code>list</code></em></span></dt><dd><p>
     The output list of 802.3 frames. It must be allocated and
     initialized by by the caller.
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     The device MAC address.
    </p></dd><dt><span class="term"><em class="parameter"><code>iftype</code></em></span></dt><dd><p>
     The device interface type.
    </p></dd><dt><span class="term"><em class="parameter"><code>extra_headroom</code></em></span></dt><dd><p>
     The hardware extra headroom for SKBs in the <em class="parameter"><code>list</code></em>.
    </p></dd><dt><span class="term"><em class="parameter"><code>has_80211_header</code></em></span></dt><dd><p>
     Set it true if SKB is with IEEE 802.11 header.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6799696"></a><h2>Description</h2><p>
   </p><p>

   Decode an IEEE 802.11n A-MSDU frame and convert it to a list of
   802.3 frames. The <em class="parameter"><code>list</code></em> will be empty if the decode fails. The
   <em class="parameter"><code>skb</code></em> is consumed after the function returns.
</p></div></div><div class="refentry" title="cfg80211_classify8021d"><div class="refentry.separator"><hr></div><a id="API-cfg80211-classify8021d"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_classify8021d — 
  determine the 802.1p/1d tag for a data frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">unsigned int <strong>fsfunccfg80211_classify8021d </strong>(</code></td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6811984"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the data frame
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp6815104"></a><h2>Return</h2><p>
   The 802.1p/1d tag.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;Regulatory enforcement infrastructure"><div class="titlepage"><div><div><h2 class="title"><a id="idp6816576"></a>Chapter&nbsp;6.&nbsp;Regulatory enforcement infrastructure</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-regulatory-hint"><span>regulatory_hint</span></a></span><span class="refpurpose"> — 
  driver hint to the wireless core a regulatory domain
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-apply-custom-regulatory"><span>wiphy_apply_custom_regulatory</span></a></span><span class="refpurpose"> — 
  apply a custom driver regulatory domain
 </span></dt><dt><span class="refentrytitle"><a href="#API-freq-reg-info"><span>freq_reg_info</span></a></span><span class="refpurpose"> — 
  get regulatory information for the given frequency
 </span></dt></dl></div><p>
   </p><p>
   TODO
</p><div class="refentry" title="regulatory_hint"><a id="API-regulatory-hint"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>regulatory_hint — 
  driver hint to the wireless core a regulatory domain
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncregulatory_hint </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">alpha2</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>const char * <var class="pdparam">alpha2</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6828032"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wireless device giving the hint (used only for reporting
     conflicts)
    </p></dd><dt><span class="term"><em class="parameter"><code>alpha2</code></em></span></dt><dd><p>
     the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
     should be in. If <em class="parameter"><code>rd</code></em> is set this should be NULL. Note that if you
     set this to NULL you should still set rd-&gt;alpha2 to some accepted
     alpha2.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6834272"></a><h2>Description</h2><p>
   Wireless drivers can use this function to hint to the wireless core
   what it believes should be the current regulatory domain by
   giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
   domain should be in or by providing a completely build regulatory domain.
   If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
   for a regulatory domain structure for the respective country.
   </p><p>

   The wiphy must have been registered to cfg80211 prior to this call.
   For cfg80211 drivers this means you must first use <code class="function">wiphy_register</code>,
   for mac80211 drivers you must first use <code class="function">ieee80211_register_hw</code>.
   </p><p>

   Drivers should check the return value, its possible you can get
   an -ENOMEM.
</p></div><div class="refsect1" title="Return"><a id="idp6838128"></a><h2>Return</h2><p>
   0 on success. -ENOMEM.
</p></div></div><div class="refentry" title="wiphy_apply_custom_regulatory"><div class="refentry.separator"><hr></div><a id="API-wiphy-apply-custom-regulatory"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_apply_custom_regulatory — 
  apply a custom driver regulatory domain
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncwiphy_apply_custom_regulatory </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">regd</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>const struct ieee80211_regdomain * <var class="pdparam">regd</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6849648"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wireless device we want to process the regulatory domain on
    </p></dd><dt><span class="term"><em class="parameter"><code>regd</code></em></span></dt><dd><p>
     the custom regulatory domain to use for this wiphy
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6854944"></a><h2>Description</h2><p>
   Drivers can sometimes have custom regulatory domains which do not apply
   to a specific country. Drivers can use this to apply such custom regulatory
   domains. This routine must be called prior to wiphy registration. The
   custom regulatory domain will be trusted completely and as such previous
   default channel settings will be disregarded. If no rule is found for a
   channel on the regulatory domain the channel will be disabled.
</p></div></div><div class="refentry" title="freq_reg_info"><div class="refentry.separator"><hr></div><a id="API-freq-reg-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>freq_reg_info — 
  get regulatory information for the given frequency
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">const struct ieee80211_reg_rule * <strong>fsfuncfreq_reg_info </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">center_freq</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>u32 <var class="pdparam">center_freq</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6866752"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy for which we want to process this rule for
    </p></dd><dt><span class="term"><em class="parameter"><code>center_freq</code></em></span></dt><dd><p>
     Frequency in KHz for which we want regulatory information for
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6872048"></a><h2>Description</h2><p>
   Use this function to get the regulatory rule for a specific frequency on
   a given wireless device. If the device has a specific regulatory domain
   it wants to follow we respect that unless a country IE has been received
   and processed already.
</p></div><div class="refsect1" title="Return"><a id="idp6873504"></a><h2>Return</h2><p>
   A valid pointer, or, when an error occurs, for example if no rule
   can be found, the return value is encoded using <code class="function">ERR_PTR</code>. Use <code class="function">IS_ERR</code> to
   check and <code class="function">PTR_ERR</code> to obtain the numeric return value. The numeric return
   value will be -ERANGE if we determine the given center_freq does not even
   have a regulatory rule for a frequency range in the center_freq's band.
   See <code class="function">freq_in_rule_band</code> for our current definition of a band -- this is
   purely subjective and right now it's 802.11 specific.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;RFkill integration"><div class="titlepage"><div><div><h2 class="title"><a id="idp6878256"></a>Chapter&nbsp;7.&nbsp;RFkill integration</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-set-hw-state"><span>wiphy_rfkill_set_hw_state</span></a></span><span class="refpurpose"> — 
  notify cfg80211 about hw block state
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-start-polling"><span>wiphy_rfkill_start_polling</span></a></span><span class="refpurpose"> — 
  start polling rfkill
 </span></dt><dt><span class="refentrytitle"><a href="#API-wiphy-rfkill-stop-polling"><span>wiphy_rfkill_stop_polling</span></a></span><span class="refpurpose"> — 
  stop polling rfkill
 </span></dt></dl></div><p>
   </p><p>
   RFkill integration in cfg80211 is almost invisible to drivers,
   as cfg80211 automatically registers an rfkill instance for each
   wireless device it knows about. Soft kill is also translated
   into disconnecting and turning all interfaces off, drivers are
   expected to turn off the device when all interfaces are down.
   </p><p>
   However, devices may have a hard RFkill line, in which case they
   also need to interact with the rfkill subsystem, via cfg80211.
   They can do this with a few helper functions documented here.
</p><div class="refentry" title="wiphy_rfkill_set_hw_state"><a id="API-wiphy-rfkill-set-hw-state"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_rfkill_set_hw_state — 
  notify cfg80211 about hw block state
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncwiphy_rfkill_set_hw_state </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">blocked</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>bool <var class="pdparam">blocked</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6890608"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy
    </p></dd><dt><span class="term"><em class="parameter"><code>blocked</code></em></span></dt><dd><p>
     block status
    </p></dd></dl></div></div></div><div class="refentry" title="wiphy_rfkill_start_polling"><div class="refentry.separator"><hr></div><a id="API-wiphy-rfkill-start-polling"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_rfkill_start_polling — 
  start polling rfkill
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncwiphy_rfkill_start_polling </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6905072"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy
    </p></dd></dl></div></div></div><div class="refentry" title="wiphy_rfkill_stop_polling"><div class="refentry.separator"><hr></div><a id="API-wiphy-rfkill-stop-polling"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>wiphy_rfkill_stop_polling — 
  stop polling rfkill
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncwiphy_rfkill_stop_polling </strong>(</code></td><td><var class="pdparam">wiphy</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6917600"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy
    </p></dd></dl></div></div></div></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Test mode"><div class="titlepage"><div><div><h2 class="title"><a id="idp6921040"></a>Chapter&nbsp;8.&nbsp;Test mode</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-alloc-reply-skb"><span>cfg80211_testmode_alloc_reply_skb</span></a></span><span class="refpurpose"> — 
  allocate testmode reply
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-reply"><span>cfg80211_testmode_reply</span></a></span><span class="refpurpose"> — 
  send the reply skb
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-alloc-event-skb"><span>cfg80211_testmode_alloc_event_skb</span></a></span><span class="refpurpose"> — 
  allocate testmode event
 </span></dt><dt><span class="refentrytitle"><a href="#API-cfg80211-testmode-event"><span>cfg80211_testmode_event</span></a></span><span class="refpurpose"> — 
  send the event
 </span></dt></dl></div><p>
   </p><p>
   Test mode is a set of utility functions to allow drivers to
   interact with driver-specific tools to aid, for instance,
   factory programming.
   </p><p>
   This chapter describes how drivers interact with it, for more
   information see the nl80211 book's chapter on it.
</p><div class="refentry" title="cfg80211_testmode_alloc_reply_skb"><a id="API-cfg80211-testmode-alloc-reply-skb"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_testmode_alloc_reply_skb — 
  allocate testmode reply
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct sk_buff * <strong>fsfunccfg80211_testmode_alloc_reply_skb </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">approxlen</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>int <var class="pdparam">approxlen</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6933104"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy
    </p></dd><dt><span class="term"><em class="parameter"><code>approxlen</code></em></span></dt><dd><p>
     an upper bound of the length of the data that will
     be put into the skb
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6938352"></a><h2>Description</h2><p>
   This function allocates and pre-fills an skb for a reply to
   the testmode command. Since it is intended for a reply, calling
   it outside of the <em class="parameter"><code>testmode_cmd</code></em> operation is invalid.
   </p><p>

   The returned skb is pre-filled with the wiphy index and set up in
   a way that any data that is put into the skb (with <code class="function">skb_put</code>,
   <code class="function">nla_put</code> or similar) will end up being within the
   <code class="constant">NL80211_ATTR_TESTDATA</code> attribute, so all that needs to be done
   with the skb is adding data for the corresponding userspace tool
   which can then read that data out of the testdata attribute. You
   must not modify the skb in any other way.
   </p><p>

   When done, call <code class="function">cfg80211_testmode_reply</code> with the skb and return
   its error code as the result of the <em class="parameter"><code>testmode_cmd</code></em> operation.
</p></div><div class="refsect1" title="Return"><a id="idp6944752"></a><h2>Return</h2><p>
   An allocated and pre-filled skb. <code class="constant">NULL</code> if any errors happen.
</p></div></div><div class="refentry" title="cfg80211_testmode_reply"><div class="refentry.separator"><hr></div><a id="API-cfg80211-testmode-reply"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_testmode_reply — 
  send the reply skb
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfunccfg80211_testmode_reply </strong>(</code></td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6955696"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     The skb, must have been allocated with
     <code class="function">cfg80211_testmode_alloc_reply_skb</code>
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6959584"></a><h2>Description</h2><p>
   Since calling this function will usually be the last thing
   before returning from the <em class="parameter"><code>testmode_cmd</code></em> you should return
   the error code.  Note that this function consumes the skb
   regardless of the return value.
</p></div><div class="refsect1" title="Return"><a id="idp6961696"></a><h2>Return</h2><p>
   An error code or 0 on success.
</p></div></div><div class="refentry" title="cfg80211_testmode_alloc_event_skb"><div class="refentry.separator"><hr></div><a id="API-cfg80211-testmode-alloc-event-skb"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_testmode_alloc_event_skb — 
  allocate testmode event
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct sk_buff * <strong>fsfunccfg80211_testmode_alloc_event_skb </strong>(</code></td><td><var class="pdparam">wiphy</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">approxlen</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct wiphy * <var class="pdparam">wiphy</var></code>;<br><code>int <var class="pdparam">approxlen</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6974128"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>wiphy</code></em></span></dt><dd><p>
     the wiphy
    </p></dd><dt><span class="term"><em class="parameter"><code>approxlen</code></em></span></dt><dd><p>
     an upper bound of the length of the data that will
     be put into the skb
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp6981360"></a><h2>Description</h2><p>
   This function allocates and pre-fills an skb for an event on the
   testmode multicast group.
   </p><p>

   The returned skb is set up in the same way as with
   <code class="function">cfg80211_testmode_alloc_reply_skb</code> but prepared for an event. As
   there, you should simply add data to it that will then end up in the
   <code class="constant">NL80211_ATTR_TESTDATA</code> attribute. Again, you must not modify the skb
   in any other way.
   </p><p>

   When done filling the skb, call <code class="function">cfg80211_testmode_event</code> with the
   skb to send the event.
</p></div><div class="refsect1" title="Return"><a id="idp6985360"></a><h2>Return</h2><p>
   An allocated and pre-filled skb. <code class="constant">NULL</code> if any errors happen.
</p></div></div><div class="refentry" title="cfg80211_testmode_event"><div class="refentry.separator"><hr></div><a id="API-cfg80211-testmode-event"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>cfg80211_testmode_event — 
  send the event
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfunccfg80211_testmode_event </strong>(</code></td><td><var class="pdparam">skb</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">gfp</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct sk_buff * <var class="pdparam">skb</var></code>;<br><code>gfp_t <var class="pdparam">gfp</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp6997184"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     The skb, must have been allocated with
     <code class="function">cfg80211_testmode_alloc_event_skb</code>
    </p></dd><dt><span class="term"><em class="parameter"><code>gfp</code></em></span></dt><dd><p>
     allocation flags
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7003056"></a><h2>Description</h2><p>
   This function sends the given <em class="parameter"><code>skb</code></em>, which must have been allocated
   by <code class="function">cfg80211_testmode_alloc_event_skb</code>, as an event. It always
   consumes it.
</p></div></div></div></div><div class="book" title="The mac80211 subsystem"><div class="titlepage"><div><div><h1 class="title"><a id="mac80211-developers-guide"></a>The mac80211 subsystem</h1></div><div><div class="abstract" title="Abstract"><p class="title"><strong>Abstract</strong></p><p>
   </p><p>
   mac80211 is the Linux stack for 802.11 hardware that implements
   only partial functionality in hard- or firmware. This document
   defines the interface between mac80211 and low-level hardware
   drivers.
</p><p>
   </p><p>
   If you're reading this document and not the header file itself, it will
   be incomplete because not all documentation has been converted yet.
</p></div></div></div><hr></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="part"><a href="#idp7010160">I. The basic mac80211 driver interface</a></span></dt><dd><dl><dt><span class="chapter"><a href="#basics">1. Basic hardware handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-hw"><span>struct ieee80211_hw</span></a></span><span class="refpurpose"> — 
  hardware information and state
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-hw-flags"><span>enum ieee80211_hw_flags</span></a></span><span class="refpurpose"> — 
  hardware flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-DEV"><span>SET_IEEE80211_DEV</span></a></span><span class="refpurpose"> — 
  set device for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-PERM-ADDR"><span>SET_IEEE80211_PERM_ADDR</span></a></span><span class="refpurpose"> — 
  set the permanent MAC address for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-ops"><span>struct ieee80211_ops</span></a></span><span class="refpurpose"> — 
  callbacks from mac80211 to the driver
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-alloc-hw"><span>ieee80211_alloc_hw</span></a></span><span class="refpurpose"> — 
  Allocate a new hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-register-hw"><span>ieee80211_register_hw</span></a></span><span class="refpurpose"> — 
  Register hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-unregister-hw"><span>ieee80211_unregister_hw</span></a></span><span class="refpurpose"> — 
  Unregister a hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-free-hw"><span>ieee80211_free_hw</span></a></span><span class="refpurpose"> — 
  free hardware descriptor
 </span></dt></dl></dd><dt><span class="chapter"><a href="#phy-handling">2. PHY configuration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-conf"><span>struct ieee80211_conf</span></a></span><span class="refpurpose"> — 
  configuration of the device
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-conf-flags"><span>enum ieee80211_conf_flags</span></a></span><span class="refpurpose"> — 
  configuration flags
 </span></dt></dl></dd><dt><span class="chapter"><a href="#iface-handling">3. Virtual interfaces</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-vif"><span>struct ieee80211_vif</span></a></span><span class="refpurpose"> — 
  per-interface data
 </span></dt></dl></dd><dt><span class="chapter"><a href="#rx-tx">4. Receive and transmit processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp7493904">what should be here</a></span></dt><dt><span class="sect1"><a href="#idp7495616">Frame format</a></span></dt><dt><span class="sect1"><a href="#idp7499040">Packet alignment</a></span></dt><dt><span class="sect1"><a href="#idp7502544">Calling into mac80211 from interrupts</a></span></dt><dt><span class="sect1"><a href="#idp7506912">functions/definitions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">5. Frame filtering</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-filter-flags"><span>enum ieee80211_filter_flags</span></a></span><span class="refpurpose"> — 
  hardware filter flags
 </span></dt></dl></dd><dt><span class="chapter"><a href="#workqueue">6. The mac80211 workqueue</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-work"><span>ieee80211_queue_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-delayed-work"><span>ieee80211_queue_delayed_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#advanced">II. Advanced driver interface</a></span></dt><dd><dl><dt><span class="chapter"><a href="#led-support">7. LED support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tx-led-name"><span>ieee80211_get_tx_led_name</span></a></span><span class="refpurpose"> — 
  get name of TX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-rx-led-name"><span>ieee80211_get_rx_led_name</span></a></span><span class="refpurpose"> — 
  get name of RX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-assoc-led-name"><span>ieee80211_get_assoc_led_name</span></a></span><span class="refpurpose"> — 
  get name of association LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-radio-led-name"><span>ieee80211_get_radio_led_name</span></a></span><span class="refpurpose"> — 
  get name of radio LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tpt-blink"><span>struct ieee80211_tpt_blink</span></a></span><span class="refpurpose"> — 
  throughput blink description
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-tpt-led-trigger-flags"><span>enum ieee80211_tpt_led_trigger_flags</span></a></span><span class="refpurpose"> — 
  throughput trigger flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-create-tpt-led-trigger"><span>ieee80211_create_tpt_led_trigger</span></a></span><span class="refpurpose"> — 
  create throughput LED trigger
 </span></dt></dl></dd><dt><span class="chapter"><a href="#hardware-crypto-offload">8. Hardware crypto acceleration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-set-key-cmd"><span>enum set_key_cmd</span></a></span><span class="refpurpose"> — 
  key command
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-key-conf"><span>struct ieee80211_key_conf</span></a></span><span class="refpurpose"> — 
  key information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-key-flags"><span>enum ieee80211_key_flags</span></a></span><span class="refpurpose"> — 
  key flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k"><span>ieee80211_get_tkip_p1k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k-iv"><span>ieee80211_get_tkip_p1k_iv</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key for IV32
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p2k"><span>ieee80211_get_tkip_p2k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 2 key
 </span></dt></dl></dd><dt><span class="chapter"><a href="#powersave">9. Powersave support</a></span></dt><dt><span class="chapter"><a href="#beacon-filter">10. Beacon filter support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-loss"><span>ieee80211_beacon_loss</span></a></span><span class="refpurpose"> — 
  inform hardware does not receive beacons
 </span></dt></dl></dd><dt><span class="chapter"><a href="#qos">11. Multiple queues and QoS support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-queue-params"><span>struct ieee80211_tx_queue_params</span></a></span><span class="refpurpose"> — 
  transmit queue configuration
 </span></dt></dl></dd><dt><span class="chapter"><a href="#AP">12. Access point mode support</a></span></dt><dd><dl><dt><span class="section"><a href="#ps-client">support for powersaving clients</a></span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-buffered-bc"><span>ieee80211_get_buffered_bc</span></a></span><span class="refpurpose"> — 
  accessing buffered broadcast and multicast frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-get"><span>ieee80211_beacon_get</span></a></span><span class="refpurpose"> — 
  beacon generation function
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-eosp"><span>ieee80211_sta_eosp</span></a></span><span class="refpurpose"> — 
  notify mac80211 about end of SP
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-frame-release-type"><span>enum ieee80211_frame_release_type</span></a></span><span class="refpurpose"> — 
  frame release reason
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition"><span>ieee80211_sta_ps_transition</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition-ni"><span>ieee80211_sta_ps_transition_ni</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta (in process context)
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-set-buffered"><span>ieee80211_sta_set_buffered</span></a></span><span class="refpurpose"> — 
  inform mac80211 about driver-buffered frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-block-awake"><span>ieee80211_sta_block_awake</span></a></span><span class="refpurpose"> — 
  block station from waking up
 </span></dt></dl></dd><dt><span class="chapter"><a href="#multi-iface">13. Supporting multiple virtual interfaces</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces"><span>ieee80211_iterate_active_interfaces</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces-atomic"><span>ieee80211_iterate_active_interfaces_atomic</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt></dl></dd><dt><span class="chapter"><a href="#station-handling">14. Station handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-sta"><span>struct ieee80211_sta</span></a></span><span class="refpurpose"> — 
  station table entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-sta-notify-cmd"><span>enum sta_notify_cmd</span></a></span><span class="refpurpose"> — 
  sta notify command
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta"><span>ieee80211_find_sta</span></a></span><span class="refpurpose"> — 
  find a station
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta-by-ifaddr"><span>ieee80211_find_sta_by_ifaddr</span></a></span><span class="refpurpose"> — 
  find a station on hardware
 </span></dt></dl></dd><dt><span class="chapter"><a href="#hardware-scan-offload">15. Hardware scan offload</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-scan-completed"><span>ieee80211_scan_completed</span></a></span><span class="refpurpose"> — 
  completed hardware scan
 </span></dt></dl></dd><dt><span class="chapter"><a href="#aggregation">16. Aggregation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp8840448">TX A-MPDU aggregation</a></span></dt><dt><span class="sect1"><a href="#idp8851200">RX A-MPDU aggregation</a></span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-ampdu-mlme-action"><span>enum ieee80211_ampdu_mlme_action</span></a></span><span class="refpurpose"> — 
  A-MPDU actions
 </span></dt></dl></dd><dt><span class="chapter"><a href="#smps">17. Spatial Multiplexing Powersave (SMPS)</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-request-smps"><span>ieee80211_request_smps</span></a></span><span class="refpurpose"> — 
  request SM PS transition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-smps-mode"><span>enum ieee80211_smps_mode</span></a></span><span class="refpurpose"> — 
  spatial multiplexing power save mode
 </span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#rate-control">III. Rate control interface</a></span></dt><dd><dl><dt><span class="chapter"><a href="#ratecontrol-api">18. Rate Control API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-session"><span>ieee80211_start_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Start a tx Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-cb-irqsafe"><span>ieee80211_start_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-session"><span>ieee80211_stop_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Stop a Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-cb-irqsafe"><span>ieee80211_stop_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to stop aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-rate-control-changed"><span>enum ieee80211_rate_control_changed</span></a></span><span class="refpurpose"> — 
  flags to indicate what changed
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-rate-control"><span>struct ieee80211_tx_rate_control</span></a></span><span class="refpurpose"> — 
  rate control information for/from RC algo
 </span></dt><dt><span class="refentrytitle"><a href="#API-rate-control-send-low"><span>rate_control_send_low</span></a></span><span class="refpurpose"> — 
  helper for drivers for management/no-ack frames
 </span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#internal">IV. Internals</a></span></dt><dd><dl><dt><span class="chapter"><a href="#key-handling">19. Key handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9065360">Key handling basics</a></span></dt><dt><span class="sect1"><a href="#idp9069264">MORE TBD</a></span></dt></dl></dd><dt><span class="chapter"><a href="#rx-processing">20. Receive processing</a></span></dt><dt><span class="chapter"><a href="#tx-processing">21. Transmit processing</a></span></dt><dt><span class="chapter"><a href="#sta-info">22. Station info handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9074928">Programming information</a></span></dt><dt><span class="sect1"><a href="#idp9223600">STA information lifetime rules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#aggregation-internals">23. Aggregation</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-sta-ampdu-mlme"><span>struct sta_ampdu_mlme</span></a></span><span class="refpurpose"> — 
  STA aggregation information.
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-tx"><span>struct tid_ampdu_tx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Tx).
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-rx"><span>struct tid_ampdu_rx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Rx).
 </span></dt></dl></dd><dt><span class="chapter"><a href="#synchronisation">24. Synchronisation</a></span></dt></dl></dd></dl></div><div class="part" title="Part&nbsp;I.&nbsp;The basic mac80211 driver interface"><div class="titlepage"><div><div><h1 class="title"><a id="idp7010160"></a>Part&nbsp;I.&nbsp;The basic mac80211 driver interface</h1></div></div></div><div class="partintro" title="The basic mac80211 driver interface"><div></div><p>
          You should read and understand the information contained
          within this part of the book while implementing a driver.
          In some chapters, advanced usage is noted, that may be
          skipped at first.
        </p><p>
          This part of the book only covers station and monitor mode
          functionality, additional information required to implement
          the other modes is covered in the second part of the book.
        </p><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#basics">1. Basic hardware handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-hw"><span>struct ieee80211_hw</span></a></span><span class="refpurpose"> — 
  hardware information and state
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-hw-flags"><span>enum ieee80211_hw_flags</span></a></span><span class="refpurpose"> — 
  hardware flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-DEV"><span>SET_IEEE80211_DEV</span></a></span><span class="refpurpose"> — 
  set device for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-PERM-ADDR"><span>SET_IEEE80211_PERM_ADDR</span></a></span><span class="refpurpose"> — 
  set the permanent MAC address for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-ops"><span>struct ieee80211_ops</span></a></span><span class="refpurpose"> — 
  callbacks from mac80211 to the driver
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-alloc-hw"><span>ieee80211_alloc_hw</span></a></span><span class="refpurpose"> — 
  Allocate a new hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-register-hw"><span>ieee80211_register_hw</span></a></span><span class="refpurpose"> — 
  Register hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-unregister-hw"><span>ieee80211_unregister_hw</span></a></span><span class="refpurpose"> — 
  Unregister a hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-free-hw"><span>ieee80211_free_hw</span></a></span><span class="refpurpose"> — 
  free hardware descriptor
 </span></dt></dl></dd><dt><span class="chapter"><a href="#phy-handling">2. PHY configuration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-conf"><span>struct ieee80211_conf</span></a></span><span class="refpurpose"> — 
  configuration of the device
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-conf-flags"><span>enum ieee80211_conf_flags</span></a></span><span class="refpurpose"> — 
  configuration flags
 </span></dt></dl></dd><dt><span class="chapter"><a href="#iface-handling">3. Virtual interfaces</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-vif"><span>struct ieee80211_vif</span></a></span><span class="refpurpose"> — 
  per-interface data
 </span></dt></dl></dd><dt><span class="chapter"><a href="#rx-tx">4. Receive and transmit processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp7493904">what should be here</a></span></dt><dt><span class="sect1"><a href="#idp7495616">Frame format</a></span></dt><dt><span class="sect1"><a href="#idp7499040">Packet alignment</a></span></dt><dt><span class="sect1"><a href="#idp7502544">Calling into mac80211 from interrupts</a></span></dt><dt><span class="sect1"><a href="#idp7506912">functions/definitions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">5. Frame filtering</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-filter-flags"><span>enum ieee80211_filter_flags</span></a></span><span class="refpurpose"> — 
  hardware filter flags
 </span></dt></dl></dd><dt><span class="chapter"><a href="#workqueue">6. The mac80211 workqueue</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-work"><span>ieee80211_queue_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-delayed-work"><span>ieee80211_queue_delayed_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt></dl></dd></dl></div></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Basic hardware handling"><div class="titlepage"><div><div><h2 class="title"><a id="basics"></a>Chapter&nbsp;1.&nbsp;Basic hardware handling</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-hw"><span>struct ieee80211_hw</span></a></span><span class="refpurpose"> — 
  hardware information and state
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-hw-flags"><span>enum ieee80211_hw_flags</span></a></span><span class="refpurpose"> — 
  hardware flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-DEV"><span>SET_IEEE80211_DEV</span></a></span><span class="refpurpose"> — 
  set device for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-SET-IEEE80211-PERM-ADDR"><span>SET_IEEE80211_PERM_ADDR</span></a></span><span class="refpurpose"> — 
  set the permanent MAC address for 802.11 hardware
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-ops"><span>struct ieee80211_ops</span></a></span><span class="refpurpose"> — 
  callbacks from mac80211 to the driver
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-alloc-hw"><span>ieee80211_alloc_hw</span></a></span><span class="refpurpose"> — 
  Allocate a new hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-register-hw"><span>ieee80211_register_hw</span></a></span><span class="refpurpose"> — 
  Register hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-unregister-hw"><span>ieee80211_unregister_hw</span></a></span><span class="refpurpose"> — 
  Unregister a hardware device
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-free-hw"><span>ieee80211_free_hw</span></a></span><span class="refpurpose"> — 
  free hardware descriptor
 </span></dt></dl></div><p>TBD</p><p>
          This chapter shall contain information on getting a hw
          struct allocated and registered with mac80211.
        </p><p>
          Since it is required to allocate rates/modes before registering
          a hw struct, this chapter shall also contain information on setting
          up the rate/mode structs.
        </p><p>
          Additionally, some discussion about the callbacks and
          the general programming model should be in here, including
          the definition of ieee80211_ops which will be referred to
          a lot.
        </p><p>
          Finally, a discussion of hardware capabilities should be done
          with references to other parts of the book.
        </p><div class="refentry" title="struct ieee80211_hw"><a id="API-struct-ieee80211-hw"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_hw — 
  hardware information and state
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_hw {
  struct ieee80211_conf conf;
  struct wiphy * wiphy;
  const char * rate_control_algorithm;
  void * priv;
  u32 flags;
  unsigned int extra_tx_headroom;
  int channel_change_time;
  int vif_data_size;
  int sta_data_size;
  int chanctx_data_size;
  int napi_weight;
  u16 queues;
  u16 max_listen_interval;
  s8 max_signal;
  u8 max_rates;
  u8 max_report_rates;
  u8 max_rate_tries;
  u8 max_rx_aggregation_subframes;
  u8 max_tx_aggregation_subframes;
  u8 offchannel_tx_hw_queue;
  u8 radiotap_mcs_details;
  u16 radiotap_vht_details;
  netdev_features_t netdev_features;
  u8 uapsd_queues;
  u8 uapsd_max_sp_len;
};  </pre></div><div class="refsect1" title="Members"><a id="idp7024944"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">conf</span></dt><dd><p>
<span class="structname">struct ieee80211_conf</span>, device configuration, don't use.
      </p></dd><dt><span class="term">wiphy</span></dt><dd><p>
This points to the <span class="structname">struct wiphy</span> allocated for this
802.11 PHY. You must fill in the <em class="parameter"><code>perm_addr</code></em> and <em class="parameter"><code>dev</code></em>
members of this structure using <code class="function">SET_IEEE80211_DEV</code>
and <code class="function">SET_IEEE80211_PERM_ADDR</code>. Additionally, all supported
bands (with channels, bitrates) are registered here.
      </p></dd><dt><span class="term">rate_control_algorithm</span></dt><dd><p>
rate control algorithm for this hardware.
If unset (NULL), the default algorithm will be used. Must be
set before calling <code class="function">ieee80211_register_hw</code>.
      </p></dd><dt><span class="term">priv</span></dt><dd><p>
pointer to private area that was allocated for driver use
along with this structure.
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
hardware flags, see <span class="structname">enum</span> ieee80211_hw_flags.
      </p></dd><dt><span class="term">extra_tx_headroom</span></dt><dd><p>
headroom to reserve in each transmit skb
for use by the driver (e.g. for transmit headers.)
      </p></dd><dt><span class="term">channel_change_time</span></dt><dd><p>
time (in microseconds) it takes to change channels.
      </p></dd><dt><span class="term">vif_data_size</span></dt><dd><p>
size (in bytes) of the drv_priv data area
within <span class="structname">struct ieee80211_vif</span>.
      </p></dd><dt><span class="term">sta_data_size</span></dt><dd><p>
size (in bytes) of the drv_priv data area
within <span class="structname">struct ieee80211_sta</span>.
      </p></dd><dt><span class="term">chanctx_data_size</span></dt><dd><p>
size (in bytes) of the drv_priv data area
within <span class="structname">struct ieee80211_chanctx_conf</span>.
      </p></dd><dt><span class="term">napi_weight</span></dt><dd><p>
weight used for NAPI polling.  You must specify an
appropriate value here if a napi_poll operation is provided
by your driver.
      </p></dd><dt><span class="term">queues</span></dt><dd><p>
number of available hardware transmit queues for
data packets. WMM/QoS requires at least four, these
queues need to have configurable access parameters.
      </p></dd><dt><span class="term">max_listen_interval</span></dt><dd><p>
max listen interval in units of beacon interval
that HW supports
      </p></dd><dt><span class="term">max_signal</span></dt><dd><p>
Maximum value for signal (rssi) in RX information, used
only when <em class="parameter"><code>IEEE80211_HW_SIGNAL_UNSPEC</code></em> or <em class="parameter"><code>IEEE80211_HW_SIGNAL_DB</code></em>
      </p></dd><dt><span class="term">max_rates</span></dt><dd><p>
maximum number of alternate rate retry stages the hw
can handle.
      </p></dd><dt><span class="term">max_report_rates</span></dt><dd><p>
maximum number of alternate rate retry stages
the hw can report back.
      </p></dd><dt><span class="term">max_rate_tries</span></dt><dd><p>
maximum number of tries for each stage
      </p></dd><dt><span class="term">max_rx_aggregation_subframes</span></dt><dd><p>
maximum buffer size (number of
sub-frames) to be used for A-MPDU block ack receiver
aggregation.
This is only relevant if the device has restrictions on the
number of subframes, if it relies on mac80211 to do reordering
it shouldn't be set.
      </p></dd><dt><span class="term">max_tx_aggregation_subframes</span></dt><dd><p>
maximum number of subframes in an
aggregate an HT driver will transmit, used by the peer as a
hint to size its reorder buffer.
      </p></dd><dt><span class="term">offchannel_tx_hw_queue</span></dt><dd><p>
HW queue ID to use for offchannel TX
(if <code class="constant">IEEE80211_HW_QUEUE_CONTROL</code> is set)
      </p></dd><dt><span class="term">radiotap_mcs_details</span></dt><dd><p>
lists which MCS information can the HW
reports, by default it is set to _MCS, _GI and _BW but doesn't
include _FMT. Use <code class="constant">IEEE80211_RADIOTAP_MCS_HAVE_</code>* values, only
adding _BW is supported today.
      </p></dd><dt><span class="term">radiotap_vht_details</span></dt><dd><p>
lists which VHT MCS information the HW reports,
the default is _GI | _BANDWIDTH.
Use the <code class="constant">IEEE80211_RADIOTAP_VHT_KNOWN_</code>* values.
      </p></dd><dt><span class="term">netdev_features</span></dt><dd><p>
netdev features to be set in each netdev created
from this HW. Note only HW checksum features are currently
compatible with mac80211. Other feature bits will be rejected.
      </p></dd><dt><span class="term">uapsd_queues</span></dt><dd><p>
This bitmap is included in (re)association frame to indicate
for each access category if it is uAPSD trigger-enabled and delivery-
enabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.
Each bit corresponds to different AC. Value '1' in specific bit means
that corresponding AC is both trigger- and delivery-enabled. '0' means
neither enabled.
      </p></dd><dt><span class="term">uapsd_max_sp_len</span></dt><dd><p>
maximum number of total buffered frames the WMM AP may
deliver to a WMM STA during any Service Period triggered by the WMM STA.
Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7071376"></a><h2>Description</h2><p>
   </p><p>

   This structure contains the configuration and hardware
   information for an 802.11 PHY.
</p></div></div><div class="refentry" title="enum ieee80211_hw_flags"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-hw-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_hw_flags — 
  hardware flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_hw_flags {
  IEEE80211_HW_HAS_RATE_CONTROL,
  IEEE80211_HW_RX_INCLUDES_FCS,
  IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,
  IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE,
  IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE,
  IEEE80211_HW_SIGNAL_UNSPEC,
  IEEE80211_HW_SIGNAL_DBM,
  IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,
  IEEE80211_HW_SPECTRUM_MGMT,
  IEEE80211_HW_AMPDU_AGGREGATION,
  IEEE80211_HW_SUPPORTS_PS,
  IEEE80211_HW_PS_NULLFUNC_STACK,
  IEEE80211_HW_SUPPORTS_DYNAMIC_PS,
  IEEE80211_HW_MFP_CAPABLE,
  IEEE80211_HW_WANT_MONITOR_VIF,
  IEEE80211_HW_SUPPORTS_STATIC_SMPS,
  IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS,
  IEEE80211_HW_SUPPORTS_UAPSD,
  IEEE80211_HW_REPORTS_TX_ACK_STATUS,
  IEEE80211_HW_CONNECTION_MONITOR,
  IEEE80211_HW_QUEUE_CONTROL,
  IEEE80211_HW_SUPPORTS_PER_STA_GTK,
  IEEE80211_HW_AP_LINK_PS,
  IEEE80211_HW_TX_AMPDU_SETUP_IN_HW,
  IEEE80211_HW_SUPPORTS_RC_TABLE,
  IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,
  IEEE80211_HW_TIMING_BEACON_ONLY,
  IEEE80211_HW_SUPPORTS_HT_CCK_RATES
};  </pre></div><div class="refsect1" title="Constants"><a id="idp7081472"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_HW_HAS_RATE_CONTROL</span></dt><dd><p>
The hardware or firmware includes rate control, and cannot be
controlled by the stack. As such, no rate control algorithm
should be instantiated, and the TX rate reported to userspace
will be taken from the TX status instead of the rate control
algorithm.
Note that this requires that the driver implement a number of
callbacks so it has the correct information, it needs to have
the <em class="parameter"><code>set_rts_threshold</code></em> callback and must look at the BSS config
<em class="parameter"><code>use_cts_prot</code></em> for G/N protection, <em class="parameter"><code>use_short_slot</code></em> for slot
timing in 2.4 GHz and <em class="parameter"><code>use_short_preamble</code></em> for preambles for
CCK frames.
      </p></dd><dt><span class="term">IEEE80211_HW_RX_INCLUDES_FCS</span></dt><dd><p>
Indicates that received frames passed to the stack include
the FCS at the end.
      </p></dd><dt><span class="term">IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING</span></dt><dd><p>
Some wireless LAN chipsets buffer broadcast/multicast frames
for power saving stations in the hardware/firmware and others
rely on the host system for such buffering. This option is used
to configure the IEEE 802.11 upper layer to buffer broadcast and
multicast frames when there are power saving stations so that
the driver can fetch them with <code class="function">ieee80211_get_buffered_bc</code>.
      </p></dd><dt><span class="term">IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE</span></dt><dd><p>
Hardware is not capable of short slot operation on the 2.4 GHz band.
      </p></dd><dt><span class="term">IEEE80211_HW_2GHZ_SHORT_PREAMBLE_INCAPABLE</span></dt><dd><p>
Hardware is not capable of receiving frames with short preamble on
the 2.4 GHz band.
      </p></dd><dt><span class="term">IEEE80211_HW_SIGNAL_UNSPEC</span></dt><dd><p>
Hardware can provide signal values but we don't know its units. We
expect values between 0 and <em class="parameter"><code>max_signal</code></em>.
If possible please provide dB or dBm instead.
      </p></dd><dt><span class="term">IEEE80211_HW_SIGNAL_DBM</span></dt><dd><p>
Hardware gives signal values in dBm, decibel difference from
one milliwatt. This is the preferred method since it is standardized
between different devices. <em class="parameter"><code>max_signal</code></em> does not need to be set.
      </p></dd><dt><span class="term">IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC</span></dt><dd><p>
This device needs to get data from beacon before association (i.e.
dtim_period).
      </p></dd><dt><span class="term">IEEE80211_HW_SPECTRUM_MGMT</span></dt><dd><p>
Hardware supports spectrum management defined in 802.11h
Measurement, Channel Switch, Quieting, TPC
      </p></dd><dt><span class="term">IEEE80211_HW_AMPDU_AGGREGATION</span></dt><dd><p>
Hardware supports 11n A-MPDU aggregation.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_PS</span></dt><dd><p>
Hardware has power save support (i.e. can go to sleep).
      </p></dd><dt><span class="term">IEEE80211_HW_PS_NULLFUNC_STACK</span></dt><dd><p>
Hardware requires nullfunc frame handling in stack, implies
stack support for dynamic PS.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_DYNAMIC_PS</span></dt><dd><p>
Hardware has support for dynamic PS.
      </p></dd><dt><span class="term">IEEE80211_HW_MFP_CAPABLE</span></dt><dd><p>
Hardware supports management frame protection (MFP, IEEE 802.11w).
      </p></dd><dt><span class="term">IEEE80211_HW_WANT_MONITOR_VIF</span></dt><dd><p>
The driver would like to be informed of
a virtual monitor interface when monitor interfaces are the only
active interfaces.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_STATIC_SMPS</span></dt><dd><p>
Hardware supports static spatial multiplexing powersave,
ie. can turn off all but one chain even on HT connections
that should be using more chains.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS</span></dt><dd><p>
Hardware supports dynamic spatial multiplexing powersave,
ie. can turn off all but one chain and then wake the rest
up as required after, for example, rts/cts handshake.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_UAPSD</span></dt><dd><p>
Hardware supports Unscheduled Automatic Power Save Delivery
(U-APSD) in managed mode. The mode is configured with
<code class="function">conf_tx</code> operation.
      </p></dd><dt><span class="term">IEEE80211_HW_REPORTS_TX_ACK_STATUS</span></dt><dd><p>
Hardware can provide ack status reports of Tx frames to
the stack.
      </p></dd><dt><span class="term">IEEE80211_HW_CONNECTION_MONITOR</span></dt><dd><p>
The hardware performs its own connection monitoring, including
periodic keep-alives to the AP and probing the AP on beacon loss.
When this flag is set, signaling beacon-loss will cause an immediate
change to disassociated state.
      </p></dd><dt><span class="term">IEEE80211_HW_QUEUE_CONTROL</span></dt><dd><p>
The driver wants to control per-interface
queue mapping in order to use different queues (not just one per AC)
for different virtual interfaces. See the doc section on HW queue
control for more details.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_PER_STA_GTK</span></dt><dd><p>
The device's crypto engine supports
per-station GTKs as used by IBSS RSN or during fast transition. If
the device doesn't support per-station GTKs, but can be asked not
to decrypt group addressed frames, then IBSS RSN support is still
possible but software crypto will be used. Advertise the wiphy flag
only in that case.
      </p></dd><dt><span class="term">IEEE80211_HW_AP_LINK_PS</span></dt><dd><p>
When operating in AP mode the device
autonomously manages the PS status of connected stations. When
this flag is set mac80211 will not trigger PS mode for connected
stations based on the PM bit of incoming frames.
Use <code class="function">ieee80211_start_ps</code>/<code class="function">ieee8021_end_ps</code> to manually configure
the PS mode of connected stations.
      </p></dd><dt><span class="term">IEEE80211_HW_TX_AMPDU_SETUP_IN_HW</span></dt><dd><p>
The device handles TX A-MPDU session
setup strictly in HW. mac80211 should not attempt to do this in
software.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_RC_TABLE</span></dt><dd><p>
The driver supports using a rate
selection table provided by the rate control algorithm.
      </p></dd><dt><span class="term">IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF</span></dt><dd><p>
Use the P2P Device address for any
P2P Interface. This will be honoured even if more than one interface
is supported.
      </p></dd><dt><span class="term">IEEE80211_HW_TIMING_BEACON_ONLY</span></dt><dd><p>
Use sync timing from beacon frames
only, to allow getting TBTT of a DTIM beacon.
      </p></dd><dt><span class="term">IEEE80211_HW_SUPPORTS_HT_CCK_RATES</span></dt><dd><p>
-- undescribed --
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7131520"></a><h2>Description</h2><p>
   </p><p>

   These flags are used to indicate hardware capabilities to
   the stack. Generally, flags here should have their meaning
   done in a way that the simplest hardware doesn't need setting
   any particular flags. There are some exceptions to this rule,
   however, so you are advised to review these flags carefully.
</p></div></div><div class="refentry" title="SET_IEEE80211_DEV"><div class="refentry.separator"><hr></div><a id="API-SET-IEEE80211-DEV"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>SET_IEEE80211_DEV — 
  set device for 802.11 hardware
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncSET_IEEE80211_DEV </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">dev</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct device * <var class="pdparam">dev</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7143520"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the <span class="structname">struct ieee80211_hw</span> to set the device for
    </p></dd><dt><span class="term"><em class="parameter"><code>dev</code></em></span></dt><dd><p>
     the <span class="structname">struct device</span> of this 802.11 device
    </p></dd></dl></div></div></div><div class="refentry" title="SET_IEEE80211_PERM_ADDR"><div class="refentry.separator"><hr></div><a id="API-SET-IEEE80211-PERM-ADDR"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>SET_IEEE80211_PERM_ADDR — 
  set the permanent MAC address for 802.11 hardware
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncSET_IEEE80211_PERM_ADDR </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>u8 * <var class="pdparam">addr</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7159776"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the <span class="structname">struct ieee80211_hw</span> to set the MAC address for
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     the address to set
    </p></dd></dl></div></div></div><div class="refentry" title="struct ieee80211_ops"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-ops"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_ops — 
  callbacks from mac80211 to the driver
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_ops {
  void (* tx) (struct ieee80211_hw *hw,struct ieee80211_tx_control *control,struct sk_buff *skb);
  int (* start) (struct ieee80211_hw *hw);
  void (* stop) (struct ieee80211_hw *hw);
#ifdef CONFIG_PM
  int (* suspend) (struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
  int (* resume) (struct ieee80211_hw *hw);
  void (* set_wakeup) (struct ieee80211_hw *hw, bool enabled);
#endif
  int (* add_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* change_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum nl80211_iftype new_type, bool p2p);
  void (* remove_interface) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* config) (struct ieee80211_hw *hw, u32 changed);
  void (* bss_info_changed) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_bss_conf *info,u32 changed);
  int (* start_ap) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* stop_ap) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  u64 (* prepare_multicast) (struct ieee80211_hw *hw,struct netdev_hw_addr_list *mc_list);
  void (* configure_filter) (struct ieee80211_hw *hw,unsigned int changed_flags,unsigned int *total_flags,u64 multicast);
  void (* set_multicast_list) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, bool allmulti,struct netdev_hw_addr_list *mc_list);
  int (* set_tim) (struct ieee80211_hw *hw, struct ieee80211_sta *sta,bool set);
  int (* set_key) (struct ieee80211_hw *hw, enum set_key_cmd cmd,struct ieee80211_vif *vif, struct ieee80211_sta *sta,struct ieee80211_key_conf *key);
  void (* update_tkip_key) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_key_conf *conf,struct ieee80211_sta *sta,u32 iv32, u16 *phase1key);
  void (* set_rekey_data) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_gtk_rekey_data *data);
  void (* set_default_unicast_key) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, int idx);
  int (* hw_scan) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct cfg80211_scan_request *req);
  void (* cancel_hw_scan) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* sched_scan_start) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_sched_scan_request *req,struct ieee80211_sched_scan_ies *ies);
  void (* sched_scan_stop) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  void (* sw_scan_start) (struct ieee80211_hw *hw);
  void (* sw_scan_complete) (struct ieee80211_hw *hw);
  int (* get_stats) (struct ieee80211_hw *hw,struct ieee80211_low_level_stats *stats);
  void (* get_tkip_seq) (struct ieee80211_hw *hw, u8 hw_key_idx,u32 *iv32, u16 *iv16);
  int (* set_frag_threshold) (struct ieee80211_hw *hw, u32 value);
  int (* set_rts_threshold) (struct ieee80211_hw *hw, u32 value);
  int (* sta_add) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
  int (* sta_remove) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta);
#ifdef CONFIG_MAC80211_DEBUGFS
  void (* sta_add_debugfs) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
  void (* sta_remove_debugfs) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,struct dentry *dir);
#endif
  void (* sta_notify) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,enum sta_notify_cmd, struct ieee80211_sta *sta);
  int (* sta_state) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta,enum ieee80211_sta_state old_state,enum ieee80211_sta_state new_state);
  void (* sta_rc_update) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_sta *sta,u32 changed);
  int (* conf_tx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, u16 ac,const struct ieee80211_tx_queue_params *params);
  u64 (* get_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  void (* set_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,u64 tsf);
  void (* reset_tsf) (struct ieee80211_hw *hw, struct ieee80211_vif *vif);
  int (* tx_last_beacon) (struct ieee80211_hw *hw);
  int (* ampdu_action) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum ieee80211_ampdu_mlme_action action,struct ieee80211_sta *sta, u16 tid, u16 *ssn,u8 buf_size);
  int (* get_survey) (struct ieee80211_hw *hw, int idx,struct survey_info *survey);
  void (* rfkill_poll) (struct ieee80211_hw *hw);
  void (* set_coverage_class) (struct ieee80211_hw *hw, u8 coverage_class);
#ifdef CONFIG_NL80211_TESTMODE
  int (* testmode_cmd) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,void *data, int len);
  int (* testmode_dump) (struct ieee80211_hw *hw, struct sk_buff *skb,struct netlink_callback *cb,void *data, int len);
#endif
  void (* flush) (struct ieee80211_hw *hw, u32 queues, bool drop);
  void (* channel_switch) (struct ieee80211_hw *hw,struct ieee80211_channel_switch *ch_switch);
  int (* napi_poll) (struct ieee80211_hw *hw, int budget);
  int (* set_antenna) (struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
  int (* get_antenna) (struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
  int (* remain_on_channel) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_channel *chan,int duration,enum ieee80211_roc_type type);
  int (* cancel_remain_on_channel) (struct ieee80211_hw *hw);
  int (* set_ringparam) (struct ieee80211_hw *hw, u32 tx, u32 rx);
  void (* get_ringparam) (struct ieee80211_hw *hw,u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);
  bool (* tx_frames_pending) (struct ieee80211_hw *hw);
  int (* set_bitrate_mask) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,const struct cfg80211_bitrate_mask *mask);
  void (* rssi_callback) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,enum ieee80211_rssi_event rssi_event);
  void (* allow_buffered_frames) (struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
  void (* release_buffered_frames) (struct ieee80211_hw *hw,struct ieee80211_sta *sta,u16 tids, int num_frames,enum ieee80211_frame_release_type reason,bool more_data);
  int (* get_et_sset_count) (struct ieee80211_hw *hw,struct ieee80211_vif *vif, int sset);
  void (* get_et_stats) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ethtool_stats *stats, u64 *data);
  void (* get_et_strings) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,u32 sset, u8 *data);
  int (* get_rssi) (struct ieee80211_hw *hw, struct ieee80211_vif *vif,struct ieee80211_sta *sta, s8 *rssi_dbm);
  void (* mgd_prepare_tx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif);
  int (* add_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
  void (* remove_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx);
  void (* change_chanctx) (struct ieee80211_hw *hw,struct ieee80211_chanctx_conf *ctx,u32 changed);
  int (* assign_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
  void (* unassign_vif_chanctx) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct ieee80211_chanctx_conf *ctx);
  void (* restart_complete) (struct ieee80211_hw *hw);
#if IS_ENABLED(CONFIG_IPV6)
  void (* ipv6_addr_change) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct inet6_dev *idev);
#endif
  void (* channel_switch_beacon) (struct ieee80211_hw *hw,struct ieee80211_vif *vif,struct cfg80211_chan_def *chandef);
};  </pre></div><div class="refsect1" title="Members"><a id="idp7185920"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">tx</span></dt><dd><p>
Handler that 802.11 module calls for each transmitted frame.
skb contains the buffer starting from the IEEE 802.11 header.
The low-level driver should send the frame out based on
configuration in the TX control data. This handler should,
preferably, never fail and stop queues appropriately.
Must be atomic.
      </p></dd><dt><span class="term">start</span></dt><dd><p>
Called before the first netdevice attached to the hardware
is enabled. This should turn on the hardware and must turn on
frame reception (for possibly enabled monitor interfaces.)
Returns negative error codes, these may be seen in userspace,
or zero.
When the device is started it should not have a MAC address
to avoid acknowledging frames before a non-monitor device
is added.
Must be implemented and can sleep.
      </p></dd><dt><span class="term">stop</span></dt><dd><p>
Called after last netdevice attached to the hardware
is disabled. This should turn off the hardware (at least
it must turn off frame reception.)
May be called right after add_interface if that rejects
an interface. If you added any work onto the mac80211 workqueue
you should ensure to cancel it on this callback.
Must be implemented and can sleep.
      </p></dd><dt><span class="term">suspend</span></dt><dd><p>
Suspend the device; mac80211 itself will quiesce before and
stop transmitting and doing any other configuration, and then
ask the device to suspend. This is only invoked when WoWLAN is
configured, otherwise the device is deconfigured completely and
reconfigured at resume time.
The driver may also impose special conditions under which it
wants to use the <span class="quote">“<span class="quote">normal</span>”</span> suspend (deconfigure), say if it only
supports WoWLAN when the device is associated. In this case, it
must return 1 from this function.
      </p></dd><dt><span class="term">resume</span></dt><dd><p>
If WoWLAN was configured, this indicates that mac80211 is
now resuming its operation, after this the device must be fully
functional again. If this returns an error, the only way out is
to also unregister the device. If it returns 1, then mac80211
will also go through the regular complete restart on resume.
      </p></dd><dt><span class="term">set_wakeup</span></dt><dd><p>
Enable or disable wakeup when WoWLAN configuration is
modified. The reason is that <code class="function">device_set_wakeup_enable</code> is
supposed to be called when the configuration changes, not only
in <code class="function">suspend</code>.
      </p></dd><dt><span class="term">add_interface</span></dt><dd><p>
Called when a netdevice attached to the hardware is
enabled. Because it is not called for monitor mode devices, <em class="parameter"><code>start</code></em>
and <em class="parameter"><code>stop</code></em> must be implemented.
The driver should perform any initialization it needs before
the device can be enabled. The initial configuration for the
interface is given in the conf parameter.
The callback may refuse to add an interface by returning a
negative error code (which will be seen in userspace.)
Must be implemented and can sleep.
      </p></dd><dt><span class="term">change_interface</span></dt><dd><p>
Called when a netdevice changes type. This callback
is optional, but only if it is supported can interface types be
switched while the interface is UP. The callback may sleep.
Note that while an interface is being switched, it will not be
found by the interface iteration callbacks.
      </p></dd><dt><span class="term">remove_interface</span></dt><dd><p>
Notifies a driver that an interface is going down.
The <em class="parameter"><code>stop</code></em> callback is called after this if it is the last interface
and no monitor interfaces are present.
When all interfaces are removed, the MAC address in the hardware
must be cleared so the device no longer acknowledges packets,
the mac_addr member of the conf structure is, however, set to the
MAC address of the device going away.
Hence, this callback must be implemented. It can sleep.
      </p></dd><dt><span class="term">config</span></dt><dd><p>
Handler for configuration requests. IEEE 802.11 code calls this
function to change hardware configuration, e.g., channel.
This function should never fail but returns a negative error code
if it does. The callback can sleep.
      </p></dd><dt><span class="term">bss_info_changed</span></dt><dd><p>
Handler for configuration requests related to BSS
parameters that may vary during BSS's lifespan, and may affect low
level driver (e.g. assoc/disassoc status, erp parameters).
This function should not be used if no BSS has been set, unless
for association indication. The <em class="parameter"><code>changed</code></em> parameter indicates which
of the bss parameters has changed when a call is made. The callback
can sleep.
      </p></dd><dt><span class="term">start_ap</span></dt><dd><p>
Start operation on the AP interface, this is called after all the
information in bss_conf is set and beacon can be retrieved. A channel
context is bound before this is called. Note that if the driver uses
software scan or ROC, this (and <em class="parameter"><code>stop_ap</code></em>) isn't called when the AP is
just <span class="quote">“<span class="quote">paused</span>”</span> for scanning/ROC, which is indicated by the beacon being
disabled/enabled via <em class="parameter"><code>bss_info_changed</code></em>.
      </p></dd><dt><span class="term">stop_ap</span></dt><dd><p>
Stop operation on the AP interface.
      </p></dd><dt><span class="term">prepare_multicast</span></dt><dd><p>
Prepare for multicast filter configuration.
This callback is optional, and its return value is passed
to <code class="function">configure_filter</code>. This callback must be atomic.
      </p></dd><dt><span class="term">configure_filter</span></dt><dd><p>
Configure the device's RX filter.
See the section <span class="quote">“<span class="quote">Frame filtering</span>”</span> for more information.
This callback must be implemented and can sleep.
      </p></dd><dt><span class="term">set_multicast_list</span></dt><dd><p>
Configure the device's interface specific RX multicast
filter. This callback is optional. This callback must be atomic.
      </p></dd><dt><span class="term">set_tim</span></dt><dd><p>
Set TIM bit. mac80211 calls this function when a TIM bit
must be set or cleared for a given STA. Must be atomic.
      </p></dd><dt><span class="term">set_key</span></dt><dd><p>
See the section <span class="quote">“<span class="quote">Hardware crypto acceleration</span>”</span>
This callback is only called between add_interface and
remove_interface calls, i.e. while the given virtual interface
is enabled.
Returns a negative error code if the key can't be added.
The callback can sleep.
      </p></dd><dt><span class="term">update_tkip_key</span></dt><dd><p>
See the section <span class="quote">“<span class="quote">Hardware crypto acceleration</span>”</span>
This callback will be called in the context of Rx. Called for drivers
which set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.
The callback must be atomic.
      </p></dd><dt><span class="term">set_rekey_data</span></dt><dd><p>
If the device supports GTK rekeying, for example while the
host is suspended, it can assign this callback to retrieve the data
necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
After rekeying was done it should (for example during resume) notify
userspace of the new replay counter using <code class="function">ieee80211_gtk_rekey_notify</code>.
      </p></dd><dt><span class="term">set_default_unicast_key</span></dt><dd><p>
Set the default (unicast) key index, useful for
WEP when the device sends data packets autonomously, e.g. for ARP
offloading. The index can be 0-3, or -1 for unsetting it.
      </p></dd><dt><span class="term">hw_scan</span></dt><dd><p>
Ask the hardware to service the scan request, no need to start
the scan state machine in stack. The scan must honour the channel
configuration done by the regulatory agent in the wiphy's
registered bands. The hardware (or the driver) needs to make sure
that power save is disabled.
The <em class="parameter"><code>req</code></em> ie/ie_len members are rewritten by mac80211 to contain the
entire IEs after the SSID, so that drivers need not look at these
at all but just send them after the SSID -- mac80211 includes the
(extended) supported rates and HT information (where applicable).
When the scan finishes, <code class="function">ieee80211_scan_completed</code> must be called;
note that it also must be called when the scan cannot finish due to
any error unless this callback returned a negative error code.
The callback can sleep.
      </p></dd><dt><span class="term">cancel_hw_scan</span></dt><dd><p>
Ask the low-level tp cancel the active hw scan.
The driver should ask the hardware to cancel the scan (if possible),
but the scan will be completed only after the driver will call
<code class="function">ieee80211_scan_completed</code>.
This callback is needed for wowlan, to prevent enqueueing a new
scan_work after the low-level driver was already suspended.
The callback can sleep.
      </p></dd><dt><span class="term">sched_scan_start</span></dt><dd><p>
Ask the hardware to start scanning repeatedly at
specific intervals.  The driver must call the
<code class="function">ieee80211_sched_scan_results</code> function whenever it finds results.
This process will continue until sched_scan_stop is called.
      </p></dd><dt><span class="term">sched_scan_stop</span></dt><dd><p>
Tell the hardware to stop an ongoing scheduled scan.
      </p></dd><dt><span class="term">sw_scan_start</span></dt><dd><p>
Notifier function that is called just before a software scan
is started. Can be NULL, if the driver doesn't need this notification.
The callback can sleep.
      </p></dd><dt><span class="term">sw_scan_complete</span></dt><dd><p>
Notifier function that is called just after a
software scan finished. Can be NULL, if the driver doesn't need
this notification.
The callback can sleep.
      </p></dd><dt><span class="term">get_stats</span></dt><dd><p>
Return low-level statistics.
Returns zero if statistics are available.
The callback can sleep.
      </p></dd><dt><span class="term">get_tkip_seq</span></dt><dd><p>
If your device implements TKIP encryption in hardware this
callback should be provided to read the TKIP transmit IVs (both IV32
and IV16) for the given key from hardware.
The callback must be atomic.
      </p></dd><dt><span class="term">set_frag_threshold</span></dt><dd><p>
Configuration of fragmentation threshold. Assign this
if the device does fragmentation by itself; if this callback is
implemented then the stack will not do fragmentation.
The callback can sleep.
      </p></dd><dt><span class="term">set_rts_threshold</span></dt><dd><p>
Configuration of RTS threshold (if device needs it)
The callback can sleep.
      </p></dd><dt><span class="term">sta_add</span></dt><dd><p>
Notifies low level driver about addition of an associated station,
AP, IBSS/WDS/mesh peer etc. This callback can sleep.
      </p></dd><dt><span class="term">sta_remove</span></dt><dd><p>
Notifies low level driver about removal of an associated
station, AP, IBSS/WDS/mesh peer etc. This callback can sleep.
      </p></dd><dt><span class="term">sta_add_debugfs</span></dt><dd><p>
Drivers can use this callback to add debugfs files
when a station is added to mac80211's station list. This callback
and <em class="parameter"><code>sta_remove_debugfs</code></em> should be within a CONFIG_MAC80211_DEBUGFS
conditional. This callback can sleep.
      </p></dd><dt><span class="term">sta_remove_debugfs</span></dt><dd><p>
Remove the debugfs files which were added using
<em class="parameter"><code>sta_add_debugfs</code></em>. This callback can sleep.
      </p></dd><dt><span class="term">sta_notify</span></dt><dd><p>
Notifies low level driver about power state transition of an
associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
in AP mode, this callback will not be called when the flag
<code class="constant">IEEE80211_HW_AP_LINK_PS</code> is set. Must be atomic.
      </p></dd><dt><span class="term">sta_state</span></dt><dd><p>
Notifies low level driver about state transition of a
station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
This callback is mutually exclusive with <em class="parameter"><code>sta_add</code></em>/<em class="parameter"><code>sta_remove</code></em>.
It must not fail for down transitions but may fail for transitions
up the list of states.
The callback can sleep.
      </p></dd><dt><span class="term">sta_rc_update</span></dt><dd><p>
Notifies the driver of changes to the bitrates that can be
used to transmit to the station. The changes are advertised with bits
from <span class="structname">enum</span> ieee80211_rate_control_changed and the values are reflected
in the station data. This callback should only be used when the driver
uses hardware rate control (<code class="constant">IEEE80211_HW_HAS_RATE_CONTROL</code>) since
otherwise the rate control algorithm is notified directly.
Must be atomic.
      </p></dd><dt><span class="term">conf_tx</span></dt><dd><p>
Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),
bursting) for a hardware TX queue.
Returns a negative error code on failure.
The callback can sleep.
      </p></dd><dt><span class="term">get_tsf</span></dt><dd><p>
Get the current TSF timer value from firmware/hardware. Currently,
this is only used for IBSS mode BSSID merging and debugging. Is not a
required function.
The callback can sleep.
      </p></dd><dt><span class="term">set_tsf</span></dt><dd><p>
Set the TSF timer to the specified value in the firmware/hardware.
Currently, this is only used for IBSS mode debugging. Is not a
required function.
The callback can sleep.
      </p></dd><dt><span class="term">reset_tsf</span></dt><dd><p>
Reset the TSF timer and allow firmware/hardware to synchronize
with other STAs in the IBSS. This is only used in IBSS mode. This
function is optional if the firmware/hardware takes full care of
TSF synchronization.
The callback can sleep.
      </p></dd><dt><span class="term">tx_last_beacon</span></dt><dd><p>
Determine whether the last IBSS beacon was sent by us.
This is needed only for IBSS mode and the result of this function is
used to determine whether to reply to Probe Requests.
Returns non-zero if this device sent the last beacon.
The callback can sleep.
      </p></dd><dt><span class="term">ampdu_action</span></dt><dd><p>
Perform a certain A-MPDU action
The RA/TID combination determines the destination and TID we want
the ampdu action to be performed for. The action is defined through
ieee80211_ampdu_mlme_action. Starting sequence number (<em class="parameter"><code>ssn</code></em>)
is the first frame we expect to perform the action on. Notice
that TX/RX_STOP can pass NULL for this parameter.
The <em class="parameter"><code>buf_size</code></em> parameter is only valid when the action is set to
<code class="constant">IEEE80211_AMPDU_TX_OPERATIONAL</code> and indicates the peer's reorder
buffer size (number of subframes) for this session -- the driver
may neither send aggregates containing more subframes than this
nor send aggregates in a way that lost frames would exceed the
buffer size. If just limiting the aggregate size, this would be
      </p></dd><dt><span class="term">get_survey</span></dt><dd><p>
Return per-channel survey information
      </p></dd><dt><span class="term">rfkill_poll</span></dt><dd><p>
Poll rfkill hardware state. If you need this, you also
need to set wiphy-&gt;rfkill_poll to <code class="constant">true</code> before registration,
and need to call <code class="function">wiphy_rfkill_set_hw_state</code> in the callback.
The callback can sleep.
      </p></dd><dt><span class="term">set_coverage_class</span></dt><dd><p>
Set slot time for given coverage class as specified
in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
accordingly. This callback is not required and may sleep.
      </p></dd><dt><span class="term">testmode_cmd</span></dt><dd><p>
Implement a cfg80211 test mode command. The passed <em class="parameter"><code>vif</code></em> may
be <code class="constant">NULL</code>. The callback can sleep.
      </p></dd><dt><span class="term">testmode_dump</span></dt><dd><p>
Implement a cfg80211 test mode dump. The callback can sleep.
      </p></dd><dt><span class="term">flush</span></dt><dd><p>
Flush all pending frames from the hardware queue, making sure
that the hardware queues are empty. The <em class="parameter"><code>queues</code></em> parameter is a bitmap
of queues to flush, which is useful if different virtual interfaces
use different hardware queues; it may also indicate all queues.
If the parameter <em class="parameter"><code>drop</code></em> is set to <code class="constant">true</code>, pending frames may be dropped.
The callback can sleep.
      </p></dd><dt><span class="term">channel_switch</span></dt><dd><p>
Drivers that need (or want) to offload the channel
switch operation for CSAs received from the AP may implement this
callback. They must then call <code class="function">ieee80211_chswitch_done</code> to indicate
completion of the channel switch.
      </p></dd><dt><span class="term">napi_poll</span></dt><dd><p>
Poll Rx queue for incoming data frames.
      </p></dd><dt><span class="term">set_antenna</span></dt><dd><p>
Set antenna configuration (tx_ant, rx_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h <em class="parameter"><code>NL80211_ATTR_WIPHY_ANTENNA_TX</code></em>).
      </p></dd><dt><span class="term">get_antenna</span></dt><dd><p>
Get current antenna configuration from device (tx_ant, rx_ant).
      </p></dd><dt><span class="term">remain_on_channel</span></dt><dd><p>
Starts an off-channel period on the given channel, must
call back to <code class="function">ieee80211_ready_on_channel</code> when on that channel. Note
that normal channel traffic is not stopped as this is intended for hw
offload. Frames to transmit on the off-channel channel are transmitted
normally except for the <code class="constant">IEEE80211_TX_CTL_TX_OFFCHAN</code> flag. When the
duration (which will always be non-zero) expires, the driver must call
<code class="function">ieee80211_remain_on_channel_expired</code>.
Note that this callback may be called while the device is in IDLE and
must be accepted in this case.
This callback may sleep.
      </p></dd><dt><span class="term">cancel_remain_on_channel</span></dt><dd><p>
Requests that an ongoing off-channel period is
aborted before it expires. This callback may sleep.
      </p></dd><dt><span class="term">set_ringparam</span></dt><dd><p>
Set tx and rx ring sizes.
      </p></dd><dt><span class="term">get_ringparam</span></dt><dd><p>
Get tx and rx ring current and maximum sizes.
      </p></dd><dt><span class="term">tx_frames_pending</span></dt><dd><p>
Check if there is any pending frame in the hardware
queues before entering power save.
      </p></dd><dt><span class="term">set_bitrate_mask</span></dt><dd><p>
Set a mask of rates to be used for rate control selection
when transmitting a frame. Currently only legacy rates are handled.
The callback can sleep.
      </p></dd><dt><span class="term">rssi_callback</span></dt><dd><p>
Notify driver when the average RSSI goes above/below
thresholds that were registered previously. The callback can sleep.
      </p></dd><dt><span class="term">allow_buffered_frames</span></dt><dd><p>
Prepare device to allow the given number of frames
to go out to the given station. The frames will be sent by mac80211
via the usual TX path after this call. The TX information for frames
released will also have the <code class="constant">IEEE80211_TX_CTL_NO_PS_BUFFER</code> flag set
and the last one will also have <code class="constant">IEEE80211_TX_STATUS_EOSP</code> set. In case
frames from multiple TIDs are released and the driver might reorder
them between the TIDs, it must set the <code class="constant">IEEE80211_TX_STATUS_EOSP</code> flag
on the last frame and clear it on all others and also handle the EOSP
bit in the QoS header correctly. Alternatively, it can also call the
<code class="function">ieee80211_sta_eosp</code> function.
The <em class="parameter"><code>tids</code></em> parameter is a bitmap and tells the driver which TIDs the
frames will be on; it will at most have two bits set.
This callback must be atomic.
      </p></dd><dt><span class="term">release_buffered_frames</span></dt><dd><p>
Release buffered frames according to the given
parameters. In the case where the driver buffers some frames for
sleeping stations mac80211 will use this callback to tell the driver
to release some frames, either for PS-poll or uAPSD.
Note that if the <em class="parameter"><code>more_data</code></em> paramter is <code class="constant">false</code> the driver must check
if there are more frames on the given TIDs, and if there are more than
the frames being released then it must still set the more-data bit in
the frame. If the <em class="parameter"><code>more_data</code></em> parameter is <code class="constant">true</code>, then of course the
more-data bit must always be set.
The <em class="parameter"><code>tids</code></em> parameter tells the driver which TIDs to release frames
from, for PS-poll it will always have only a single bit set.
In the case this is used for a PS-poll initiated release, the
<em class="parameter"><code>num_frames</code></em> parameter will always be 1 so code can be shared. In
this case the driver must also set <code class="constant">IEEE80211_TX_STATUS_EOSP</code> flag
on the TX status (and must report TX status) so that the PS-poll
period is properly ended. This is used to avoid sending multiple
responses for a retried PS-poll frame.
In the case this is used for uAPSD, the <em class="parameter"><code>num_frames</code></em> parameter may be
bigger than one, but the driver may send fewer frames (it must send
at least one, however). In this case it is also responsible for
setting the EOSP flag in the QoS header of the frames. Also, when the
service period ends, the driver must set <code class="constant">IEEE80211_TX_STATUS_EOSP</code>
on the last frame in the SP. Alternatively, it may call the function
<code class="function">ieee80211_sta_eosp</code> to inform mac80211 of the end of the SP.
This callback must be atomic.
      </p></dd><dt><span class="term">get_et_sset_count</span></dt><dd><p>
Ethtool API to get string-set count.
      </p></dd><dt><span class="term">get_et_stats</span></dt><dd><p>
Ethtool API to get a set of u64 stats.
      </p></dd><dt><span class="term">get_et_strings</span></dt><dd><p>
Ethtool API to get a set of strings to describe stats
and perhaps other supported types of ethtool data-sets.
      </p></dd><dt><span class="term">get_rssi</span></dt><dd><p>
Get current signal strength in dBm, the function is optional
and can sleep.
      </p></dd><dt><span class="term">mgd_prepare_tx</span></dt><dd><p>
Prepare for transmitting a management frame for association
before associated. In multi-channel scenarios, a virtual interface is
bound to a channel before it is associated, but as it isn't associated
yet it need not necessarily be given airtime, in particular since any
transmission to a P2P GO needs to be synchronized against the GO's
powersave state. mac80211 will call this function before transmitting a
management frame prior to having successfully associated to allow the
driver to give it channel time for the transmission, to get a response
and to be able to synchronize with the GO.
The callback will be called before each transmission and upon return
mac80211 will transmit the frame right away.
The callback is optional and can (should!) sleep.
      </p></dd><dt><span class="term">add_chanctx</span></dt><dd><p>
Notifies device driver about new channel context creation.
      </p></dd><dt><span class="term">remove_chanctx</span></dt><dd><p>
Notifies device driver about channel context destruction.
      </p></dd><dt><span class="term">change_chanctx</span></dt><dd><p>
Notifies device driver about channel context changes that
may happen when combining different virtual interfaces on the same
channel context with different settings
      </p></dd><dt><span class="term">assign_vif_chanctx</span></dt><dd><p>
Notifies device driver about channel context being bound
to vif. Possible use is for hw queue remapping.
      </p></dd><dt><span class="term">unassign_vif_chanctx</span></dt><dd><p>
Notifies device driver about channel context being
unbound from vif.
      </p></dd><dt><span class="term">restart_complete</span></dt><dd><p>
Called after a call to <code class="function">ieee80211_restart_hw</code>, when the
reconfiguration has completed. This can help the driver implement the
reconfiguration step. Also called when reconfiguring because the
driver's resume function returned 1, as this is just like an <span class="quote">“<span class="quote">inline</span>”</span>
hardware restart. This callback may sleep.
      </p></dd><dt><span class="term">ipv6_addr_change</span></dt><dd><p>
IPv6 address assignment on the given interface changed.
Currently, this is only called for managed or P2P client interfaces.
This callback is optional; it must not sleep.
      </p></dd><dt><span class="term">channel_switch_beacon</span></dt><dd><p>
Starts a channel switch to a new channel.
Beacons are modified to include CSA or ECSA IEs before calling this
function. The corresponding count fields in these IEs must be
decremented, and when they reach zero the driver must call
<code class="function">ieee80211_csa_finish</code>. Drivers which use <code class="function">ieee80211_beacon_get</code>
get the csa counter decremented by mac80211, but must check if it is
zero using <code class="function">ieee80211_csa_is_complete</code> after the beacon has been
transmitted and then call <code class="function">ieee80211_csa_finish</code>.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7344464"></a><h2>Description</h2><p>
   </p><p>

   This structure contains various callbacks that the driver may
   handle or, in some cases, must handle, for example to configure
   the hardware to a new channel or to transmit a frame.
</p></div><div class="refsect1" title="possible with a buf_size of 8"><a id="idp7346112"></a><h2>possible with a buf_size of 8</h2><p>
   - TX: 1.....7
   - RX:  2....7 (lost frame #1)
   - TX:        8..1...
   which is invalid since #1 was now re-transmitted well past the
   buffer size of 8. Correct ways to retransmit #1 would be:
   - TX:       1 or 18 or 81
   Even <span class="quote">“<span class="quote">189</span>”</span> would be wrong since 1 could be lost again.
   </p><p>

   Returns a negative error code on failure.
   The callback can sleep.
</p></div></div><div class="refentry" title="ieee80211_alloc_hw"><div class="refentry.separator"><hr></div><a id="API-ieee80211-alloc-hw"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_alloc_hw — 
  Allocate a new hardware device
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct ieee80211_hw * <strong>fsfuncieee80211_alloc_hw </strong>(</code></td><td><var class="pdparam">priv_data_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ops</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>size_t <var class="pdparam">priv_data_len</var></code>;<br><code>const struct ieee80211_ops * <var class="pdparam">ops</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7358528"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>priv_data_len</code></em></span></dt><dd><p>
     length of private data
    </p></dd><dt><span class="term"><em class="parameter"><code>ops</code></em></span></dt><dd><p>
     callbacks for this device
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7363712"></a><h2>Description</h2><p>
   </p><p>

   This must be called once for each hardware device. The returned pointer
   must be used to refer to this device when calling other functions.
   mac80211 allocates a private data area for the driver pointed to by
   <em class="parameter"><code>priv</code></em> in <span class="structname">struct ieee80211_hw</span>, the size of this area is given as
   <em class="parameter"><code>priv_data_len</code></em>.
</p></div><div class="refsect1" title="Return"><a id="idp7367264"></a><h2>Return</h2><p>
   A pointer to the new hardware device, or <code class="constant">NULL</code> on error.
</p></div></div><div class="refentry" title="ieee80211_register_hw"><div class="refentry.separator"><hr></div><a id="API-ieee80211-register-hw"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_register_hw — 
  Register hardware device
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_register_hw </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7378160"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the device to register as returned by <code class="function">ieee80211_alloc_hw</code>
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7382032"></a><h2>Description</h2><p>
   </p><p>

   You must call this function before any other functions in
   mac80211. Note that before a hardware can be registered, you
   need to fill the contained wiphy's information.
</p></div><div class="refsect1" title="Return"><a id="idp7383664"></a><h2>Return</h2><p>
   0 on success. An error code otherwise.
</p></div></div><div class="refentry" title="ieee80211_unregister_hw"><div class="refentry.separator"><hr></div><a id="API-ieee80211-unregister-hw"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_unregister_hw — 
  Unregister a hardware device
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_unregister_hw </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7394096"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware to unregister
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7397264"></a><h2>Description</h2><p>
   </p><p>

   This function instructs mac80211 to free allocated resources
   and unregister netdevices from the networking subsystem.
</p></div></div><div class="refentry" title="ieee80211_free_hw"><div class="refentry.separator"><hr></div><a id="API-ieee80211-free-hw"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_free_hw — 
  free hardware descriptor
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_free_hw </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7408016"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware to free
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7411184"></a><h2>Description</h2><p>
   </p><p>

   This function frees everything that was allocated, including the
   private data for the driver. You must call <code class="function">ieee80211_unregister_hw</code>
   before calling this function.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;PHY configuration"><div class="titlepage"><div><div><h2 class="title"><a id="phy-handling"></a>Chapter&nbsp;2.&nbsp;PHY configuration</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-conf"><span>struct ieee80211_conf</span></a></span><span class="refpurpose"> — 
  configuration of the device
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-conf-flags"><span>enum ieee80211_conf_flags</span></a></span><span class="refpurpose"> — 
  configuration flags
 </span></dt></dl></div><p>TBD</p><p>
          This chapter should describe PHY handling including
          start/stop callbacks and the various structures used.
        </p><div class="refentry" title="struct ieee80211_conf"><a id="API-struct-ieee80211-conf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_conf — 
  configuration of the device
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_conf {
  u32 flags;
  int power_level;
  int dynamic_ps_timeout;
  int max_sleep_period;
  u16 listen_interval;
  u8 ps_dtim_period;
  u8 long_frame_max_tx_count;
  u8 short_frame_max_tx_count;
  struct cfg80211_chan_def chandef;
  bool radar_enabled;
  enum ieee80211_smps_mode smps_mode;
};  </pre></div><div class="refsect1" title="Members"><a id="idp7423376"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">flags</span></dt><dd><p>
configuration flags defined above
      </p></dd><dt><span class="term">power_level</span></dt><dd><p>
requested transmit power (in dBm), backward compatibility
value only that is set to the minimum of all interfaces
      </p></dd><dt><span class="term">dynamic_ps_timeout</span></dt><dd><p>
The dynamic powersave timeout (in ms), see the
powersave documentation below. This variable is valid only when
the CONF_PS flag is set.
      </p></dd><dt><span class="term">max_sleep_period</span></dt><dd><p>
the maximum number of beacon intervals to sleep for
before checking the beacon for a TIM bit (managed mode only); this
value will be only achievable between DTIM frames, the hardware
needs to check for the multicast traffic bit in DTIM beacons.
This variable is valid only when the CONF_PS flag is set.
      </p></dd><dt><span class="term">listen_interval</span></dt><dd><p>
listen interval in units of beacon interval
      </p></dd><dt><span class="term">ps_dtim_period</span></dt><dd><p>
The DTIM period of the AP we're connected to, for use
in power saving. Power saving will not be enabled until a beacon
has been received and the DTIM period is known.
      </p></dd><dt><span class="term">long_frame_max_tx_count</span></dt><dd><p>
Maximum number of transmissions for a <span class="quote">“<span class="quote">long</span>”</span> frame
(a frame not RTS protected), called <span class="quote">“<span class="quote">dot11LongRetryLimit</span>”</span> in 802.11,
but actually means the number of transmissions not the number of retries
      </p></dd><dt><span class="term">short_frame_max_tx_count</span></dt><dd><p>
Maximum number of transmissions for a <span class="quote">“<span class="quote">short</span>”</span>
frame, called <span class="quote">“<span class="quote">dot11ShortRetryLimit</span>”</span> in 802.11, but actually means the
number of transmissions not the number of retries
      </p></dd><dt><span class="term">chandef</span></dt><dd><p>
the channel definition to tune to
      </p></dd><dt><span class="term">radar_enabled</span></dt><dd><p>
whether radar detection is enabled
      </p></dd><dt><span class="term">smps_mode</span></dt><dd><p>
spatial multiplexing powersave mode; note that
<code class="constant">IEEE80211_SMPS_STATIC</code> is used when the device is not
configured for an HT channel.
Note that this is only valid if channel contexts are not used,
otherwise each channel context has the number of chains listed.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7442848"></a><h2>Description</h2><p>
   </p><p>

   This struct indicates how the driver shall configure the hardware.
</p></div></div><div class="refentry" title="enum ieee80211_conf_flags"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-conf-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_conf_flags — 
  configuration flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_conf_flags {
  IEEE80211_CONF_MONITOR,
  IEEE80211_CONF_PS,
  IEEE80211_CONF_IDLE,
  IEEE80211_CONF_OFFCHANNEL
};  </pre></div><div class="refsect1" title="Constants"><a id="idp7452048"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_CONF_MONITOR</span></dt><dd><p>
there's a monitor interface present -- use this
to determine for example whether to calculate timestamps for packets
or not, do not use instead of filter flags!
      </p></dd><dt><span class="term">IEEE80211_CONF_PS</span></dt><dd><p>
Enable 802.11 power save mode (managed mode only).
This is the power save mode defined by IEEE 802.11-2007 section 11.2,
meaning that the hardware still wakes up for beacons, is able to
transmit frames and receive the possible acknowledgment frames.
Not to be confused with hardware specific wakeup/sleep states,
driver is responsible for that. See the section <span class="quote">“<span class="quote">Powersave support</span>”</span>
for more.
      </p></dd><dt><span class="term">IEEE80211_CONF_IDLE</span></dt><dd><p>
The device is running, but idle; if the flag is set
the driver should be prepared to handle configuration requests but
may turn the device off as much as possible. Typically, this flag will
be set when an interface is set UP but not associated or scanning, but
it can also be unset in that case when monitor interfaces are active.
      </p></dd><dt><span class="term">IEEE80211_CONF_OFFCHANNEL</span></dt><dd><p>
The device is currently not on its main
operating channel.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7459952"></a><h2>Description</h2><p>
   </p><p>

   Flags to define PHY configuration options
</p></div></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Virtual interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="iface-handling"></a>Chapter&nbsp;3.&nbsp;Virtual interfaces</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-vif"><span>struct ieee80211_vif</span></a></span><span class="refpurpose"> — 
  per-interface data
 </span></dt></dl></div><p>TBD</p><p>
          This chapter should describe virtual interface basics
          that are relevant to the driver (VLANs, MGMT etc are not.)
          It should explain the use of the add_iface/remove_iface
          callbacks as well as the interface configuration callbacks.
        </p><p>Things related to AP mode should be discussed there.</p><p>
          Things related to supporting multiple interfaces should be
          in the appropriate chapter, a BIG FAT note should be here about
          this though and the recommendation to allow only a single
          interface in STA mode at first!
        </p><div class="refentry" title="struct ieee80211_vif"><a id="API-struct-ieee80211-vif"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_vif — 
  per-interface data
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_vif {
  enum nl80211_iftype type;
  struct ieee80211_bss_conf bss_conf;
  u8 addr[ETH_ALEN];
  bool p2p;
  bool csa_active;
  u8 cab_queue;
  u8 hw_queue[IEEE80211_NUM_ACS];
  struct ieee80211_chanctx_conf __rcu * chanctx_conf;
  u32 driver_flags;
#ifdef CONFIG_MAC80211_DEBUGFS
  struct dentry * debugfs_dir;
#endif
  u8 drv_priv[0];
};  </pre></div><div class="refsect1" title="Members"><a id="idp7472656"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">type</span></dt><dd><p>
type of this virtual interface
      </p></dd><dt><span class="term">bss_conf</span></dt><dd><p>
BSS configuration for this interface, either our own
or the BSS we're associated to
      </p></dd><dt><span class="term">addr[ETH_ALEN]</span></dt><dd><p>
address of this interface
      </p></dd><dt><span class="term">p2p</span></dt><dd><p>
indicates whether this AP or STA interface is a p2p
interface, i.e. a GO or p2p-sta respectively
      </p></dd><dt><span class="term">csa_active</span></dt><dd><p>
marks whether a channel switch is going on
      </p></dd><dt><span class="term">cab_queue</span></dt><dd><p>
content-after-beacon (DTIM beacon really) queue, AP mode only
      </p></dd><dt><span class="term">hw_queue[IEEE80211_NUM_ACS]</span></dt><dd><p>
hardware queue for each AC
      </p></dd><dt><span class="term">chanctx_conf</span></dt><dd><p>
The channel context this interface is assigned to, or <code class="constant">NULL</code>
when it is not assigned. This pointer is RCU-protected due to the TX
path needing to access it; even though the netdev carrier will always
be off when it is <code class="constant">NULL</code> there can still be races and packets could be
processed after it switches back to <code class="constant">NULL</code>.
      </p></dd><dt><span class="term">driver_flags</span></dt><dd><p>
flags/capabilities the driver has for this interface,
these need to be set (or cleared) when the interface is added
or, if supported by the driver, the interface type is changed
at runtime, mac80211 will never touch this field
      </p></dd><dt><span class="term">debugfs_dir</span></dt><dd><p>
debugfs dentry, can be used by drivers to create own per
interface debug files. Note that it will be NULL for the virtual
monitor interface (if that is requested.)
      </p></dd><dt><span class="term">drv_priv[0]</span></dt><dd><p>
data area for driver use, will always be aligned to
sizeof(void *).
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7490944"></a><h2>Description</h2><p>
   </p><p>

   Data in this structure is continually present for driver
   use during the life of a virtual interface.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Receive and transmit processing"><div class="titlepage"><div><div><h2 class="title"><a id="rx-tx"></a>Chapter&nbsp;4.&nbsp;Receive and transmit processing</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#idp7493904">what should be here</a></span></dt><dt><span class="sect1"><a href="#idp7495616">Frame format</a></span></dt><dt><span class="sect1"><a href="#idp7499040">Packet alignment</a></span></dt><dt><span class="sect1"><a href="#idp7502544">Calling into mac80211 from interrupts</a></span></dt><dt><span class="sect1"><a href="#idp7506912">functions/definitions</a></span></dt></dl></div><div class="sect1" title="what should be here"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7493904"></a>what should be here</h2></div></div></div><p>TBD</p><p>
            This should describe the receive and transmit
            paths in mac80211/the drivers as well as
            transmit status handling.
          </p></div><div class="sect1" title="Frame format"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7495616"></a>Frame format</h2></div></div></div><p>
   </p><p>
   As a general rule, when frames are passed between mac80211 and the driver,
   they start with the IEEE 802.11 header and include the same octets that are
   sent over the air except for the FCS which should be calculated by the
   hardware.
   </p><p>
   There are, however, various exceptions to this rule for advanced features:
   </p><p>
   The first exception is for hardware encryption and decryption offload
   where the IV/ICV may or may not be generated in hardware.
   </p><p>
   Secondly, when the hardware handles fragmentation, the frame handed to
   the driver from mac80211 is the MSDU, not the MPDU.
   </p><p>
   Finally, for received frames, the driver is able to indicate that it has
   filled a radiotap header and put that in front of the frame; if it does
   not do so then mac80211 may add this under certain circumstances.
</p></div><div class="sect1" title="Packet alignment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7499040"></a>Packet alignment</h2></div></div></div><p>
   </p><p>
   Drivers always need to pass packets that are aligned to two-byte boundaries
   to the stack.
   </p><p>
   Additionally, should, if possible, align the payload data in a way that
   guarantees that the contained IP header is aligned to a four-byte
   boundary. In the case of regular frames, this simply means aligning the
   payload to a four-byte boundary (because either the IP header is directly
   contained, or IV/RFC1042 headers that have a length divisible by four are
   in front of it).  If the payload data is not properly aligned and the
   architecture doesn't support efficient unaligned operations, mac80211
   will align the data.
   </p><p>
   With A-MSDU frames, however, the payload data address must yield two modulo
   four because there are 14-byte 802.3 headers within the A-MSDU frames that
   push the IP header further back to a multiple of four again. Thankfully, the
   specs were sane enough this time around to require padding each A-MSDU
   subframe to a length that is a multiple of four.
   </p><p>
   Padding like Atheros hardware adds which is between the 802.11 header and
   the payload is not supported, the driver is required to move the 802.11
   header to be directly in front of the payload in that case.
</p></div><div class="sect1" title="Calling into mac80211 from interrupts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7502544"></a>Calling into mac80211 from interrupts</h2></div></div></div><p>
   </p><p>
   Only <code class="function">ieee80211_tx_status_irqsafe</code> and <code class="function">ieee80211_rx_irqsafe</code> can be
   called in hardware interrupt context. The low-level driver must not call any
   other functions in hardware interrupt context. If there is a need for such
   call, the low-level driver should first ACK the interrupt and perform the
   IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even
   tasklet function.
   </p><p>
   NOTE: If the driver opts to use the <code class="function">_irqsafe</code> functions, it may not also
   use the non-IRQ-safe functions!
</p></div><div class="sect1" title="functions/definitions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7506912"></a>functions/definitions</h2></div></div></div><div class="refentry" title="struct ieee80211_rx_status"><a id="API-struct-ieee80211-rx-status"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_rx_status — 
  receive status
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_rx_status {
  u64 mactime;
  u32 device_timestamp;
  u32 ampdu_reference;
  u32 flag;
  u32 vendor_radiotap_bitmap;
  u16 vendor_radiotap_len;
  u16 freq;
  u8 rate_idx;
  u8 vht_nss;
  u8 rx_flags;
  u8 band;
  u8 antenna;
  s8 signal;
  u8 chains;
  s8 chain_signal[IEEE80211_MAX_CHAINS];
  u8 ampdu_delimiter_crc;
  u8 vendor_radiotap_align;
  u8 vendor_radiotap_oui[3];
  u8 vendor_radiotap_subns;
};  </pre></div><div class="refsect1" title="Members"><a id="idp7515824"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">mactime</span></dt><dd><p>
value in microseconds of the 64-bit Time Synchronization Function
(TSF) timer when the first data symbol (MPDU) arrived at the hardware.
      </p></dd><dt><span class="term">device_timestamp</span></dt><dd><p>
arbitrary timestamp for the device, mac80211 doesn't use
it but can store it and pass it back to the driver for synchronisation
      </p></dd><dt><span class="term">ampdu_reference</span></dt><dd><p>
A-MPDU reference number, must be a different value for
each A-MPDU but the same for each subframe within one A-MPDU
      </p></dd><dt><span class="term">flag</span></dt><dd><p>
<code class="constant">RX_FLAG_</code>*
      </p></dd><dt><span class="term">vendor_radiotap_bitmap</span></dt><dd><p>
radiotap vendor namespace presence bitmap
      </p></dd><dt><span class="term">vendor_radiotap_len</span></dt><dd><p>
radiotap vendor namespace length
      </p></dd><dt><span class="term">freq</span></dt><dd><p>
frequency the radio was tuned to when receiving this frame, in MHz
      </p></dd><dt><span class="term">rate_idx</span></dt><dd><p>
index of data rate into band's supported rates or MCS index if
HT or VHT is used (<code class="constant">RX_FLAG_HT</code>/<code class="constant">RX_FLAG_VHT</code>)
      </p></dd><dt><span class="term">vht_nss</span></dt><dd><p>
number of streams (VHT only)
      </p></dd><dt><span class="term">rx_flags</span></dt><dd><p>
internal RX flags for mac80211
      </p></dd><dt><span class="term">band</span></dt><dd><p>
the active band when this frame was received
      </p></dd><dt><span class="term">antenna</span></dt><dd><p>
antenna used
      </p></dd><dt><span class="term">signal</span></dt><dd><p>
signal strength when receiving this frame, either in dBm, in dB or
unspecified depending on the hardware capabilities flags
<em class="parameter"><code>IEEE80211_HW_SIGNAL_</code></em>*
      </p></dd><dt><span class="term">chains</span></dt><dd><p>
bitmask of receive chains for which separate signal strength
values were filled.
      </p></dd><dt><span class="term">chain_signal[IEEE80211_MAX_CHAINS]</span></dt><dd><p>
per-chain signal strength, in dBm (unlike <em class="parameter"><code>signal</code></em>, doesn't
support dB or unspecified units)
      </p></dd><dt><span class="term">ampdu_delimiter_crc</span></dt><dd><p>
A-MPDU delimiter CRC
      </p></dd><dt><span class="term">vendor_radiotap_align</span></dt><dd><p>
radiotap vendor namespace alignment. Note
that the actual data must be at the start of the SKB data
already.
      </p></dd><dt><span class="term">vendor_radiotap_oui[3]</span></dt><dd><p>
radiotap vendor namespace OUI
      </p></dd><dt><span class="term">vendor_radiotap_subns</span></dt><dd><p>
radiotap vendor sub namespace
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7546288"></a><h2>Description</h2><p>
   </p><p>

   The low-level driver should provide this information (the subset
   supported by hardware) to the 802.11 code with each received
   frame, in the skb's control buffer (cb).
</p></div></div><div class="refentry" title="enum mac80211_rx_flags"><div class="refentry.separator"><hr></div><a id="API-enum-mac80211-rx-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum mac80211_rx_flags — 
  receive flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum mac80211_rx_flags {
  RX_FLAG_MMIC_ERROR,
  RX_FLAG_DECRYPTED,
  RX_FLAG_MMIC_STRIPPED,
  RX_FLAG_IV_STRIPPED,
  RX_FLAG_FAILED_FCS_CRC,
  RX_FLAG_FAILED_PLCP_CRC,
  RX_FLAG_MACTIME_START,
  RX_FLAG_SHORTPRE,
  RX_FLAG_HT,
  RX_FLAG_40MHZ,
  RX_FLAG_SHORT_GI,
  RX_FLAG_NO_SIGNAL_VAL,
  RX_FLAG_HT_GF,
  RX_FLAG_AMPDU_DETAILS,
  RX_FLAG_AMPDU_REPORT_ZEROLEN,
  RX_FLAG_AMPDU_IS_ZEROLEN,
  RX_FLAG_AMPDU_LAST_KNOWN,
  RX_FLAG_AMPDU_IS_LAST,
  RX_FLAG_AMPDU_DELIM_CRC_ERROR,
  RX_FLAG_AMPDU_DELIM_CRC_KNOWN,
  RX_FLAG_MACTIME_END,
  RX_FLAG_VHT,
  RX_FLAG_80MHZ,
  RX_FLAG_80P80MHZ,
  RX_FLAG_160MHZ,
  RX_FLAG_STBC_MASK,
  RX_FLAG_10MHZ,
  RX_FLAG_5MHZ
};  </pre></div><div class="refsect1" title="Constants"><a id="idp7556000"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">RX_FLAG_MMIC_ERROR</span></dt><dd><p>
Michael MIC error was reported on this frame.
Use together with <code class="constant">RX_FLAG_MMIC_STRIPPED</code>.
      </p></dd><dt><span class="term">RX_FLAG_DECRYPTED</span></dt><dd><p>
This frame was decrypted in hardware.
      </p></dd><dt><span class="term">RX_FLAG_MMIC_STRIPPED</span></dt><dd><p>
the Michael MIC is stripped off this frame,
verification has been done by the hardware.
      </p></dd><dt><span class="term">RX_FLAG_IV_STRIPPED</span></dt><dd><p>
The IV/ICV are stripped from this frame.
If this flag is set, the stack cannot do any replay detection
hence the driver or hardware will have to do that.
      </p></dd><dt><span class="term">RX_FLAG_FAILED_FCS_CRC</span></dt><dd><p>
Set this flag if the FCS check failed on
the frame.
      </p></dd><dt><span class="term">RX_FLAG_FAILED_PLCP_CRC</span></dt><dd><p>
Set this flag if the PCLP check failed on
the frame.
      </p></dd><dt><span class="term">RX_FLAG_MACTIME_START</span></dt><dd><p>
The timestamp passed in the RX status (<em class="parameter"><code>mactime</code></em>
field) is valid and contains the time the first symbol of the MPDU
was received. This is useful in monitor mode and for proper IBSS
merging.
      </p></dd><dt><span class="term">RX_FLAG_SHORTPRE</span></dt><dd><p>
Short preamble was used for this frame
      </p></dd><dt><span class="term">RX_FLAG_HT</span></dt><dd><p>
HT MCS was used and rate_idx is MCS index
      </p></dd><dt><span class="term">RX_FLAG_40MHZ</span></dt><dd><p>
HT40 (40 MHz) was used
      </p></dd><dt><span class="term">RX_FLAG_SHORT_GI</span></dt><dd><p>
Short guard interval was used
      </p></dd><dt><span class="term">RX_FLAG_NO_SIGNAL_VAL</span></dt><dd><p>
The signal strength value is not present.
Valid only for data frames (mainly A-MPDU)
      </p></dd><dt><span class="term">RX_FLAG_HT_GF</span></dt><dd><p>
This frame was received in a HT-greenfield transmission, if
the driver fills this value it should add <code class="constant">IEEE80211_RADIOTAP_MCS_HAVE_FMT</code>
to hw.radiotap_mcs_details to advertise that fact
      </p></dd><dt><span class="term">RX_FLAG_AMPDU_DETAILS</span></dt><dd><p>
A-MPDU details are known, in particular the reference
number (<em class="parameter"><code>ampdu_reference</code></em>) must be populated and be a distinct number for
each A-MPDU
      </p></dd><dt><span class="term">RX_FLAG_AMPDU_REPORT_ZEROLEN</span></dt><dd><p>
driver reports 0-length subframes
      </p></dd><dt><span class="term">RX_FLAG_AMPDU_IS_ZEROLEN</span></dt><dd><p>
This is a zero-length subframe, for
monitoring purposes only
      </p></dd><dt><span class="term">RX_FLAG_AMPDU_LAST_KNOWN</span></dt><dd><p>
last subframe is known, should be set on all
subframes of a single A-MPDU
      </p></dd><dt><span class="term">RX_FLAG_AMPDU_IS_LAST</span></dt><dd><p>
this subframe is the last subframe of the A-MPDU
      </p></dd><dt><span class="term">RX_FLAG_AMPDU_DELIM_CRC_ERROR</span></dt><dd><p>
A delimiter CRC error has been detected
on this subframe
      </p></dd><dt><span class="term">RX_FLAG_AMPDU_DELIM_CRC_KNOWN</span></dt><dd><p>
The delimiter CRC field is known (the CRC
is stored in the <em class="parameter"><code>ampdu_delimiter_crc</code></em> field)
      </p></dd><dt><span class="term">RX_FLAG_MACTIME_END</span></dt><dd><p>
The timestamp passed in the RX status (<em class="parameter"><code>mactime</code></em>
field) is valid and contains the time the last symbol of the MPDU
(including FCS) was received.
      </p></dd><dt><span class="term">RX_FLAG_VHT</span></dt><dd><p>
VHT MCS was used and rate_index is MCS index
      </p></dd><dt><span class="term">RX_FLAG_80MHZ</span></dt><dd><p>
80 MHz was used
      </p></dd><dt><span class="term">RX_FLAG_80P80MHZ</span></dt><dd><p>
80+80 MHz was used
      </p></dd><dt><span class="term">RX_FLAG_160MHZ</span></dt><dd><p>
160 MHz was used
      </p></dd><dt><span class="term">RX_FLAG_STBC_MASK</span></dt><dd><p>
STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3
      </p></dd><dt><span class="term">RX_FLAG_10MHZ</span></dt><dd><p>
10 MHz (half channel) was used
      </p></dd><dt><span class="term">RX_FLAG_5MHZ</span></dt><dd><p>
5 MHz (quarter channel) was used
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7600160"></a><h2>Description</h2><p>
   </p><p>

   These flags are used with the <em class="parameter"><code>flag</code></em> member of <span class="structname">struct ieee80211_rx_status</span>.
</p></div></div><div class="refentry" title="enum mac80211_tx_info_flags"><div class="refentry.separator"><hr></div><a id="API-enum-mac80211-tx-info-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum mac80211_tx_info_flags — 
  flags to describe transmission information/status
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum mac80211_tx_info_flags {
  IEEE80211_TX_CTL_REQ_TX_STATUS,
  IEEE80211_TX_CTL_ASSIGN_SEQ,
  IEEE80211_TX_CTL_NO_ACK,
  IEEE80211_TX_CTL_CLEAR_PS_FILT,
  IEEE80211_TX_CTL_FIRST_FRAGMENT,
  IEEE80211_TX_CTL_SEND_AFTER_DTIM,
  IEEE80211_TX_CTL_AMPDU,
  IEEE80211_TX_CTL_INJECTED,
  IEEE80211_TX_STAT_TX_FILTERED,
  IEEE80211_TX_STAT_ACK,
  IEEE80211_TX_STAT_AMPDU,
  IEEE80211_TX_STAT_AMPDU_NO_BACK,
  IEEE80211_TX_CTL_RATE_CTRL_PROBE,
  IEEE80211_TX_INTFL_OFFCHAN_TX_OK,
  IEEE80211_TX_INTFL_NEED_TXPROCESSING,
  IEEE80211_TX_INTFL_RETRIED,
  IEEE80211_TX_INTFL_DONT_ENCRYPT,
  IEEE80211_TX_CTL_NO_PS_BUFFER,
  IEEE80211_TX_CTL_MORE_FRAMES,
  IEEE80211_TX_INTFL_RETRANSMISSION,
  IEEE80211_TX_INTFL_MLME_CONN_TX,
  IEEE80211_TX_INTFL_NL80211_FRAME_TX,
  IEEE80211_TX_CTL_LDPC,
  IEEE80211_TX_CTL_STBC,
  IEEE80211_TX_CTL_TX_OFFCHAN,
  IEEE80211_TX_INTFL_TKIP_MIC_FAILURE,
  IEEE80211_TX_CTL_NO_CCK_RATE,
  IEEE80211_TX_STATUS_EOSP,
  IEEE80211_TX_CTL_USE_MINRATE,
  IEEE80211_TX_CTL_DONTFRAG,
  IEEE80211_TX_CTL_PS_RESPONSE
};  </pre></div><div class="refsect1" title="Constants"><a id="idp7612368"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_TX_CTL_REQ_TX_STATUS</span></dt><dd><p>
require TX status callback for this frame.
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_ASSIGN_SEQ</span></dt><dd><p>
The driver has to assign a sequence
number to this frame, taking care of not overwriting the fragment
number and increasing the sequence number only when the
IEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly
assign sequence numbers to QoS-data frames but cannot do so correctly
for non-QoS-data and management frames because beacons need them from
that counter as well and mac80211 cannot guarantee proper sequencing.
If this flag is set, the driver should instruct the hardware to
assign a sequence number to the frame or assign one itself. Cf. IEEE
802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
beacons and always be clear for frames without a sequence number field.
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_NO_ACK</span></dt><dd><p>
tell the low level not to wait for an ack
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_CLEAR_PS_FILT</span></dt><dd><p>
clear powersave filter for destination
station
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_FIRST_FRAGMENT</span></dt><dd><p>
this is a first fragment of the frame
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_SEND_AFTER_DTIM</span></dt><dd><p>
send this frame after DTIM beacon
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_AMPDU</span></dt><dd><p>
this frame should be sent as part of an A-MPDU
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_INJECTED</span></dt><dd><p>
Frame was injected, internal to mac80211.
      </p></dd><dt><span class="term">IEEE80211_TX_STAT_TX_FILTERED</span></dt><dd><p>
The frame was not transmitted
because the destination STA was in powersave mode. Note that to
avoid race conditions, the filter must be set by the hardware or
firmware upon receiving a frame that indicates that the station
went to sleep (must be done on device to filter frames already on
the queue) and may only be unset after mac80211 gives the OK for
that by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),
since only then is it guaranteed that no more frames are in the
hardware queue.
      </p></dd><dt><span class="term">IEEE80211_TX_STAT_ACK</span></dt><dd><p>
Frame was acknowledged
      </p></dd><dt><span class="term">IEEE80211_TX_STAT_AMPDU</span></dt><dd><p>
The frame was aggregated, so status
is for the whole aggregation.
      </p></dd><dt><span class="term">IEEE80211_TX_STAT_AMPDU_NO_BACK</span></dt><dd><p>
no block ack was returned,
so consider using block ack request (BAR).
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_RATE_CTRL_PROBE</span></dt><dd><p>
internal to mac80211, can be
set by rate control algorithms to indicate probe rate, will
be cleared for fragmented frames (except on the last fragment)
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_OFFCHAN_TX_OK</span></dt><dd><p>
Internal to mac80211. Used to indicate
that a frame can be transmitted while the queues are stopped for
off-channel operation.
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_NEED_TXPROCESSING</span></dt><dd><p>
completely internal to mac80211,
used to indicate that a pending frame requires TX processing before
it can be sent out.
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_RETRIED</span></dt><dd><p>
completely internal to mac80211,
used to indicate that a frame was already retried due to PS
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_DONT_ENCRYPT</span></dt><dd><p>
completely internal to mac80211,
used to indicate frame should not be encrypted
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_NO_PS_BUFFER</span></dt><dd><p>
This frame is a response to a poll
frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must
be sent although the station is in powersave mode.
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_MORE_FRAMES</span></dt><dd><p>
More frames will be passed to the
transmit function after the current frame, this can be used
by drivers to kick the DMA queue only if unset or when the
queue gets full.
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_RETRANSMISSION</span></dt><dd><p>
This frame is being retransmitted
after TX status because the destination was asleep, it must not
be modified again (no seqno assignment, crypto, etc.)
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_MLME_CONN_TX</span></dt><dd><p>
This frame was transmitted by the MLME
code for connection establishment, this indicates that its status
should kick the MLME state machine.
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_NL80211_FRAME_TX</span></dt><dd><p>
Frame was requested through nl80211
MLME command (internal to mac80211 to figure out whether to send TX
status to user space)
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_LDPC</span></dt><dd><p>
tells the driver to use LDPC for this frame
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_STBC</span></dt><dd><p>
Enables Space-Time Block Coding (STBC) for this
frame and selects the maximum number of streams that it can use.
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_TX_OFFCHAN</span></dt><dd><p>
Marks this packet to be transmitted on
the off-channel channel when a remain-on-channel offload is done
in hardware -- normal packets still flow and are expected to be
handled properly by the device.
      </p></dd><dt><span class="term">IEEE80211_TX_INTFL_TKIP_MIC_FAILURE</span></dt><dd><p>
Marks this packet to be used for TKIP
testing. It will be sent out with incorrect Michael MIC key to allow
TKIP countermeasures to be tested.
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_NO_CCK_RATE</span></dt><dd><p>
This frame will be sent at non CCK rate.
This flag is actually used for management frame especially for P2P
frames not being sent at CCK rate in 2GHz band.
      </p></dd><dt><span class="term">IEEE80211_TX_STATUS_EOSP</span></dt><dd><p>
This packet marks the end of service period,
when its status is reported the service period ends. For frames in
an SP that mac80211 transmits, it is already set; for driver frames
the driver may set this flag. It is also used to do the same for
PS-Poll responses.
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_USE_MINRATE</span></dt><dd><p>
This frame will be sent at lowest rate.
This flag is used to send nullfunc frame at minimum rate when
the nullfunc is used for connection monitoring purpose.
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_DONTFRAG</span></dt><dd><p>
Don't fragment this packet even if it
would be fragmented by size (this is optional, only used for
monitor injection).
      </p></dd><dt><span class="term">IEEE80211_TX_CTL_PS_RESPONSE</span></dt><dd><p>
This frame is a response to a poll
frame (PS-Poll or uAPSD).
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7659552"></a><h2>Description</h2><p>
   </p><p>

   These flags are used with the <em class="parameter"><code>flags</code></em> member of <span class="structname">ieee80211_tx_info</span>.
</p></div><div class="refsect1" title="Note"><a id="idp7662176"></a><h2>Note</h2><p>
   If you have to add new flags to the enumeration, then don't
   forget to update <code class="constant">IEEE80211_TX_TEMPORARY_FLAGS</code> when necessary.
</p></div></div><div class="refentry" title="enum mac80211_tx_control_flags"><div class="refentry.separator"><hr></div><a id="API-enum-mac80211-tx-control-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum mac80211_tx_control_flags — 
  flags to describe transmit control
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum mac80211_tx_control_flags {
  IEEE80211_TX_CTRL_PORT_CTRL_PROTO
};  </pre></div><div class="refsect1" title="Constants"><a id="idp7671424"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_TX_CTRL_PORT_CTRL_PROTO</span></dt><dd><p>
this frame is a port control
protocol frame (e.g. EAP)
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7674016"></a><h2>Description</h2><p>
   These flags are used in tx_info-&gt;control.flags.
</p></div></div><div class="refentry" title="enum mac80211_rate_control_flags"><div class="refentry.separator"><hr></div><a id="API-enum-mac80211-rate-control-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum mac80211_rate_control_flags — 
  per-rate flags set by the Rate Control algorithm.
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum mac80211_rate_control_flags {
  IEEE80211_TX_RC_USE_RTS_CTS,
  IEEE80211_TX_RC_USE_CTS_PROTECT,
  IEEE80211_TX_RC_USE_SHORT_PREAMBLE,
  IEEE80211_TX_RC_MCS,
  IEEE80211_TX_RC_GREEN_FIELD,
  IEEE80211_TX_RC_40_MHZ_WIDTH,
  IEEE80211_TX_RC_DUP_DATA,
  IEEE80211_TX_RC_SHORT_GI,
  IEEE80211_TX_RC_VHT_MCS,
  IEEE80211_TX_RC_80_MHZ_WIDTH,
  IEEE80211_TX_RC_160_MHZ_WIDTH
};  </pre></div><div class="refsect1" title="Constants"><a id="idp7683168"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_TX_RC_USE_RTS_CTS</span></dt><dd><p>
Use RTS/CTS exchange for this rate.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_USE_CTS_PROTECT</span></dt><dd><p>
CTS-to-self protection is required.
This is set if the current BSS requires ERP protection.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_USE_SHORT_PREAMBLE</span></dt><dd><p>
Use short preamble.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_MCS</span></dt><dd><p>
HT rate.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_GREEN_FIELD</span></dt><dd><p>
Indicates whether this rate should be used in
Greenfield mode.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_40_MHZ_WIDTH</span></dt><dd><p>
Indicates if the Channel Width should be 40 MHz.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_DUP_DATA</span></dt><dd><p>
The frame should be transmitted on both of the
adjacent 20 MHz channels, if the current channel type is
NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_SHORT_GI</span></dt><dd><p>
Short Guard interval should be used for this rate.
      </p></dd><dt><span class="term">IEEE80211_TX_RC_VHT_MCS</span></dt><dd><p>
VHT MCS rate, in this case the idx field is split
into a higher 4 bits (Nss) and lower 4 bits (MCS number)
      </p></dd><dt><span class="term">IEEE80211_TX_RC_80_MHZ_WIDTH</span></dt><dd><p>
Indicates 80 MHz transmission
      </p></dd><dt><span class="term">IEEE80211_TX_RC_160_MHZ_WIDTH</span></dt><dd><p>
Indicates 160 MHz transmission
(80+80 isn't supported yet)
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7699856"></a><h2>Description</h2><p>
   </p><p>

   These flags are set by the Rate control algorithm for each rate during tx,
   in the <em class="parameter"><code>flags</code></em> member of struct ieee80211_tx_rate.
</p></div></div><div class="refentry" title="struct ieee80211_tx_rate"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-tx-rate"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_tx_rate — 
  rate selection/status
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_tx_rate {
  s8 idx;
  u16 count:5;
  u16 flags:11;
};  </pre></div><div class="refsect1" title="Members"><a id="idp7709648"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">idx</span></dt><dd><p>
rate index to attempt to send with
      </p></dd><dt><span class="term">count</span></dt><dd><p>
number of tries in this rate before going to the next rate
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
rate control flags (<span class="structname">enum</span> mac80211_rate_control_flags)
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7715376"></a><h2>Description</h2><p>
   A value of -1 for <em class="parameter"><code>idx</code></em> indicates an invalid rate and, if used
   in an array of retry rates, that no more rates should be tried.
   </p><p>

   When used for transmit status reporting, the driver should
   always report the rate along with the flags it used.
   </p><p>

   <span class="structname">struct ieee80211_tx_info</span> contains an array of these structs
   in the control information, and it will be filled by the rate
   control algorithm according to what should be sent. For example,
   if this array contains, in the format { &lt;idx&gt;, &lt;count&gt; } the
   information
   { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }
   then this means that the frame should be transmitted
   up to twice at rate 3, up to twice at rate 2, and up to four
   times at rate 1 if it doesn't get acknowledged. Say it gets
   acknowledged by the peer after the fifth attempt, the status
   information should then contain
   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...
   since it was transmitted twice at rate 3, twice at rate 2
   and once at rate 1 after which we received an acknowledgement.
</p></div></div><div class="refentry" title="struct ieee80211_tx_info"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-tx-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_tx_info — 
  skb transmit information
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_tx_info {
  u32 flags;
  u8 band;
  u8 hw_queue;
  u16 ack_frame_id;
  union {unnamed_union};
};  </pre></div><div class="refsect1" title="Members"><a id="idp7728032"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">flags</span></dt><dd><p>
transmit info flags, defined above
      </p></dd><dt><span class="term">band</span></dt><dd><p>
the band to transmit on (use for checking for races)
      </p></dd><dt><span class="term">hw_queue</span></dt><dd><p>
HW queue to put the frame on, <code class="function">skb_get_queue_mapping</code> gives the AC
      </p></dd><dt><span class="term">ack_frame_id</span></dt><dd><p>
internal frame ID for TX status, used internally
      </p></dd><dt><span class="term">{unnamed_union}</span></dt><dd><p>
anonymous
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7736800"></a><h2>Description</h2><p>
   </p><p>

   This structure is placed in skb-&gt;cb for three uses:
   (1) mac80211 TX control - mac80211 tells the driver what to do
   (2) driver internal use (if applicable)
   (3) TX status information - driver tells mac80211 what happened
</p></div></div><div class="refentry" title="ieee80211_tx_info_clear_status"><div class="refentry.separator"><hr></div><a id="API-ieee80211-tx-info-clear-status"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_tx_info_clear_status — 
  clear TX status
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_tx_info_clear_status </strong>(</code></td><td><var class="pdparam">info</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_tx_info * <var class="pdparam">info</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7748080"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>info</code></em></span></dt><dd><p>
     The <span class="structname">struct ieee80211_tx_info</span> to be cleared.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7751728"></a><h2>Description</h2><p>
   When the driver passes an skb back to mac80211, it must report
   a number of things in TX status. This function clears everything
   in the TX status but the rate control information (it does clear
   the count since you need to fill that in anyway).
</p></div><div class="refsect1" title="NOTE"><a id="idp7753184"></a><h2>NOTE</h2><p>
   You can only use this function if you do NOT use
   info-&gt;driver_data! Use info-&gt;rate_driver_data
   instead if you need only the less space that allows.
</p></div></div><div class="refentry" title="ieee80211_rx"><div class="refentry.separator"><hr></div><a id="API-ieee80211-rx"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_rx — 
  receive frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_rx </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7764880"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware this frame came in on
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the buffer to receive, owned by mac80211 after this call
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7770080"></a><h2>Description</h2><p>
   </p><p>

   Use this function to hand received frames to mac80211. The receive
   buffer in <em class="parameter"><code>skb</code></em> must start with an IEEE 802.11 header. In case of a
   paged <em class="parameter"><code>skb</code></em> is used, the driver is recommended to put the ieee80211
   header of the frame on the linear part of the <em class="parameter"><code>skb</code></em> to avoid memory
   allocation and/or memcpy by the stack.
   </p><p>

   This function may not be called in IRQ context. Calls to this function
   for a single hardware must be synchronized against each other. Calls to
   this function, <code class="function">ieee80211_rx_ni</code> and <code class="function">ieee80211_rx_irqsafe</code> may not be
   mixed for a single hardware. Must not run concurrently with
   <code class="function">ieee80211_tx_status</code> or <code class="function">ieee80211_tx_status_ni</code>.
   </p><p>

   In process context use instead <code class="function">ieee80211_rx_ni</code>.
</p></div></div><div class="refentry" title="ieee80211_rx_ni"><div class="refentry.separator"><hr></div><a id="API-ieee80211-rx-ni"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_rx_ni — 
  receive frame (in process context)
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_rx_ni </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7788432"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware this frame came in on
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the buffer to receive, owned by mac80211 after this call
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7793632"></a><h2>Description</h2><p>
   </p><p>

   Like <code class="function">ieee80211_rx</code> but can be called in process context
   (internally disables bottom halves).
   </p><p>

   Calls to this function, <code class="function">ieee80211_rx</code> and <code class="function">ieee80211_rx_irqsafe</code> may
   not be mixed for a single hardware. Must not run concurrently with
   <code class="function">ieee80211_tx_status</code> or <code class="function">ieee80211_tx_status_ni</code>.
</p></div></div><div class="refentry" title="ieee80211_rx_irqsafe"><div class="refentry.separator"><hr></div><a id="API-ieee80211-rx-irqsafe"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_rx_irqsafe — 
  receive frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_rx_irqsafe </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7809296"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware this frame came in on
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the buffer to receive, owned by mac80211 after this call
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7814496"></a><h2>Description</h2><p>
   </p><p>

   Like <code class="function">ieee80211_rx</code> but can be called in IRQ context
   (internally defers to a tasklet.)
   </p><p>

   Calls to this function, <code class="function">ieee80211_rx</code> or <code class="function">ieee80211_rx_ni</code> may not
   be mixed for a single hardware.Must not run concurrently with
   <code class="function">ieee80211_tx_status</code> or <code class="function">ieee80211_tx_status_ni</code>.
</p></div></div><div class="refentry" title="ieee80211_tx_status"><div class="refentry.separator"><hr></div><a id="API-ieee80211-tx-status"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_tx_status — 
  transmit status callback
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_tx_status </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7830032"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware the frame was transmitted by
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the frame that was transmitted, owned by mac80211 after this call
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7835248"></a><h2>Description</h2><p>
   </p><p>

   Call this function for all transmitted frames after they have been
   transmitted. It is permissible to not call this function for
   multicast frames but this can affect statistics.
   </p><p>

   This function may not be called in IRQ context. Calls to this function
   for a single hardware must be synchronized against each other. Calls
   to this function, <code class="function">ieee80211_tx_status_ni</code> and <code class="function">ieee80211_tx_status_irqsafe</code>
   may not be mixed for a single hardware. Must not run concurrently with
   <code class="function">ieee80211_rx</code> or <code class="function">ieee80211_rx_ni</code>.
</p></div></div><div class="refentry" title="ieee80211_tx_status_ni"><div class="refentry.separator"><hr></div><a id="API-ieee80211-tx-status-ni"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_tx_status_ni — 
  transmit status callback (in process context)
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_tx_status_ni </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7850544"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware the frame was transmitted by
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the frame that was transmitted, owned by mac80211 after this call
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7855760"></a><h2>Description</h2><p>
   </p><p>

   Like <code class="function">ieee80211_tx_status</code> but can be called in process context.
   </p><p>

   Calls to this function, <code class="function">ieee80211_tx_status</code> and
   <code class="function">ieee80211_tx_status_irqsafe</code> may not be mixed
   for a single hardware.
</p></div></div><div class="refentry" title="ieee80211_tx_status_irqsafe"><div class="refentry.separator"><hr></div><a id="API-ieee80211-tx-status-irqsafe"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_tx_status_irqsafe — 
  IRQ-safe transmit status callback
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_tx_status_irqsafe </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7869920"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware the frame was transmitted by
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the frame that was transmitted, owned by mac80211 after this call
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7875136"></a><h2>Description</h2><p>
   </p><p>

   Like <code class="function">ieee80211_tx_status</code> but can be called in IRQ context
   (internally defers to a tasklet.)
   </p><p>

   Calls to this function, <code class="function">ieee80211_tx_status</code> and
   <code class="function">ieee80211_tx_status_ni</code> may not be mixed for a single hardware.
</p></div></div><div class="refentry" title="ieee80211_rts_get"><div class="refentry.separator"><hr></div><a id="API-ieee80211-rts-get"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_rts_get — 
  RTS frame generation function
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_rts_get </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_txctl</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">rts</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>const void * <var class="pdparam">frame</var></code>;<br><code>size_t <var class="pdparam">frame_len</var></code>;<br><code>const struct ieee80211_tx_info * <var class="pdparam">frame_txctl</var></code>;<br><code>struct ieee80211_rts * <var class="pdparam">rts</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7893216"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame</code></em></span></dt><dd><p>
     pointer to the frame that is going to be protected by the RTS.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_len</code></em></span></dt><dd><p>
     the frame length (in octets).
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_txctl</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_tx_info</span> of the frame.
    </p></dd><dt><span class="term"><em class="parameter"><code>rts</code></em></span></dt><dd><p>
     The buffer where to store the RTS frame.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7908048"></a><h2>Description</h2><p>
   If the RTS frames are generated by the host system (i.e., not in
   hardware/firmware), the low-level driver uses this function to receive
   the next RTS frame from the 802.11 code. The low-level is responsible
   for calling this function before and RTS frame is needed.
</p></div></div><div class="refentry" title="ieee80211_rts_duration"><div class="refentry.separator"><hr></div><a id="API-ieee80211-rts-duration"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_rts_duration — 
  Get the duration field for an RTS frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">__le16 <strong>fsfuncieee80211_rts_duration </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_txctl</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>size_t <var class="pdparam">frame_len</var></code>;<br><code>const struct ieee80211_tx_info * <var class="pdparam">frame_txctl</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7921648"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_len</code></em></span></dt><dd><p>
     the length of the frame that is going to be protected by the RTS.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_txctl</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_tx_info</span> of the frame.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7932448"></a><h2>Description</h2><p>
   If the RTS is generated in firmware, but the host system must provide
   the duration field, the low-level driver uses this function to receive
   the duration field value in little-endian byteorder.
</p></div><div class="refsect1" title="Return"><a id="idp7933856"></a><h2>Return</h2><p>
   The duration.
</p></div></div><div class="refentry" title="ieee80211_ctstoself_get"><div class="refentry.separator"><hr></div><a id="API-ieee80211-ctstoself-get"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_ctstoself_get — 
  CTS-to-self frame generation function
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_ctstoself_get </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_txctl</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">cts</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>const void * <var class="pdparam">frame</var></code>;<br><code>size_t <var class="pdparam">frame_len</var></code>;<br><code>const struct ieee80211_tx_info * <var class="pdparam">frame_txctl</var></code>;<br><code>struct ieee80211_cts * <var class="pdparam">cts</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7949184"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame</code></em></span></dt><dd><p>
     pointer to the frame that is going to be protected by the CTS-to-self.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_len</code></em></span></dt><dd><p>
     the frame length (in octets).
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_txctl</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_tx_info</span> of the frame.
    </p></dd><dt><span class="term"><em class="parameter"><code>cts</code></em></span></dt><dd><p>
     The buffer where to store the CTS-to-self frame.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7964032"></a><h2>Description</h2><p>
   If the CTS-to-self frames are generated by the host system (i.e., not in
   hardware/firmware), the low-level driver uses this function to receive
   the next CTS-to-self frame from the 802.11 code. The low-level is responsible
   for calling this function before and CTS-to-self frame is needed.
</p></div></div><div class="refentry" title="ieee80211_ctstoself_duration"><div class="refentry.separator"><hr></div><a id="API-ieee80211-ctstoself-duration"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_ctstoself_duration — 
  Get the duration field for a CTS-to-self frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">__le16 <strong>fsfuncieee80211_ctstoself_duration </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_txctl</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>size_t <var class="pdparam">frame_len</var></code>;<br><code>const struct ieee80211_tx_info * <var class="pdparam">frame_txctl</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp7977712"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_len</code></em></span></dt><dd><p>
     the length of the frame that is going to be protected by the CTS-to-self.
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_txctl</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_tx_info</span> of the frame.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp7988512"></a><h2>Description</h2><p>
   If the CTS-to-self is generated in firmware, but the host system must provide
   the duration field, the low-level driver uses this function to receive
   the duration field value in little-endian byteorder.
</p></div><div class="refsect1" title="Return"><a id="idp7989920"></a><h2>Return</h2><p>
   The duration.
</p></div></div><div class="refentry" title="ieee80211_generic_frame_duration"><div class="refentry.separator"><hr></div><a id="API-ieee80211-generic-frame-duration"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_generic_frame_duration — 
  Calculate the duration field for a frame
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">__le16 <strong>fsfuncieee80211_generic_frame_duration </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">band</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">frame_len</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">rate</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>enum ieee80211_band <var class="pdparam">band</var></code>;<br><code>size_t <var class="pdparam">frame_len</var></code>;<br><code>struct ieee80211_rate * <var class="pdparam">rate</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8004240"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd><dt><span class="term"><em class="parameter"><code>band</code></em></span></dt><dd><p>
     the band to calculate the frame duration on
    </p></dd><dt><span class="term"><em class="parameter"><code>frame_len</code></em></span></dt><dd><p>
     the length of the frame.
    </p></dd><dt><span class="term"><em class="parameter"><code>rate</code></em></span></dt><dd><p>
     the rate at which the frame is going to be transmitted.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8016640"></a><h2>Description</h2><p>
   Calculate the duration field of some generic frame, given its
   length and transmission rate (in 100kbps).
</p></div><div class="refsect1" title="Return"><a id="idp8017952"></a><h2>Return</h2><p>
   The duration.
</p></div></div><div class="refentry" title="ieee80211_wake_queue"><div class="refentry.separator"><hr></div><a id="API-ieee80211-wake-queue"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_wake_queue — 
  wake specific queue
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_wake_queue </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">queue</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>int <var class="pdparam">queue</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8029344"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer as obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue number (counted from zero).
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8035264"></a><h2>Description</h2><p>
   Drivers should use this function instead of netif_wake_queue.
</p></div></div><div class="refentry" title="ieee80211_stop_queue"><div class="refentry.separator"><hr></div><a id="API-ieee80211-stop-queue"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_stop_queue — 
  stop specific queue
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_stop_queue </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">queue</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>int <var class="pdparam">queue</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8046704"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer as obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue number (counted from zero).
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8052624"></a><h2>Description</h2><p>
   Drivers should use this function instead of netif_stop_queue.
</p></div></div><div class="refentry" title="ieee80211_wake_queues"><div class="refentry.separator"><hr></div><a id="API-ieee80211-wake-queues"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_wake_queues — 
  wake all queues
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_wake_queues </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8063072"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer as obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8066912"></a><h2>Description</h2><p>
   Drivers should use this function instead of netif_wake_queue.
</p></div></div><div class="refentry" title="ieee80211_stop_queues"><div class="refentry.separator"><hr></div><a id="API-ieee80211-stop-queues"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_stop_queues — 
  stop all queues
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_stop_queues </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8077408"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer as obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8081248"></a><h2>Description</h2><p>
   Drivers should use this function instead of netif_stop_queue.
</p></div></div><div class="refentry" title="ieee80211_queue_stopped"><div class="refentry.separator"><hr></div><a id="API-ieee80211-queue-stopped"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_queue_stopped — 
  test status of the queue
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_queue_stopped </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">queue</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>int <var class="pdparam">queue</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8092656"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer as obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>queue</code></em></span></dt><dd><p>
     queue number (counted from zero).
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8098576"></a><h2>Description</h2><p>
   Drivers should use this function instead of netif_stop_queue.
</p></div><div class="refsect1" title="Return"><a id="idp8099840"></a><h2>Return</h2><p>
   <code class="constant">true</code> if the queue is stopped. <code class="constant">false</code> otherwise.
</p></div></div></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Frame filtering"><div class="titlepage"><div><div><h2 class="title"><a id="filters"></a>Chapter&nbsp;5.&nbsp;Frame filtering</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-filter-flags"><span>enum ieee80211_filter_flags</span></a></span><span class="refpurpose"> — 
  hardware filter flags
 </span></dt></dl></div><p>
   </p><p>
   mac80211 requires to see many management frames for proper
   operation, and users may want to see many more frames when
   in monitor mode. However, for best CPU usage and power consumption,
   having as few frames as possible percolate through the stack is
   desirable. Hence, the hardware should filter as much as possible.
   </p><p>
   To achieve this, mac80211 uses filter flags (see below) to tell
   the driver's <code class="function">configure_filter</code> function which frames should be
   passed to mac80211 and which should be filtered out.
   </p><p>
   Before <code class="function">configure_filter</code> is invoked, the <code class="function">prepare_multicast</code>
   callback is invoked with the parameters <em class="parameter"><code>mc_count</code></em> and <em class="parameter"><code>mc_list</code></em>
   for the combined multicast address list of all virtual interfaces.
   It's use is optional, and it returns a u64 that is passed to
   <code class="function">configure_filter</code>. Additionally, <code class="function">configure_filter</code> has the
   arguments <em class="parameter"><code>changed_flags</code></em> telling which flags were changed and
   <em class="parameter"><code>total_flags</code></em> with the new flag states.
   </p><p>
   If your device has no multicast address filters your driver will
   need to check both the <code class="constant">FIF_ALLMULTI</code> flag and the <em class="parameter"><code>mc_count</code></em>
   parameter to see whether multicast frames should be accepted
   or dropped.
   </p><p>
   All unsupported flags in <em class="parameter"><code>total_flags</code></em> must be cleared.
   Hardware does not support a flag if it is incapable of _passing_
   the frame to the stack. Otherwise the driver must ignore
   the flag, but not clear it.
   You must _only_ clear the flag (announce no support for the
   flag to mac80211) if you are not able to pass the packet type
   to the stack (so the hardware always filters it).
   So for example, you should clear <em class="parameter"><code>FIF_CONTROL</code></em>, if your hardware
   always filters control frames. If your hardware always passes
   control frames to the kernel and is incapable of filtering them,
   you do _not_ clear the <em class="parameter"><code>FIF_CONTROL</code></em> flag.
   This rule applies to all other FIF flags as well.
</p><div class="refentry" title="enum ieee80211_filter_flags"><a id="API-enum-ieee80211-filter-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_filter_flags — 
  hardware filter flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_filter_flags {
  FIF_PROMISC_IN_BSS,
  FIF_ALLMULTI,
  FIF_FCSFAIL,
  FIF_PLCPFAIL,
  FIF_BCN_PRBRESP_PROMISC,
  FIF_CONTROL,
  FIF_OTHER_BSS,
  FIF_PSPOLL,
  FIF_PROBE_REQ
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8124128"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">FIF_PROMISC_IN_BSS</span></dt><dd><p>
promiscuous mode within your BSS,
think of the BSS as your network segment and then this corresponds
to the regular ethernet device promiscuous mode.
      </p></dd><dt><span class="term">FIF_ALLMULTI</span></dt><dd><p>
pass all multicast frames, this is used if requested
by the user or if the hardware is not capable of filtering by
multicast address.
      </p></dd><dt><span class="term">FIF_FCSFAIL</span></dt><dd><p>
pass frames with failed FCS (but you need to set the
<code class="constant">RX_FLAG_FAILED_FCS_CRC</code> for them)
      </p></dd><dt><span class="term">FIF_PLCPFAIL</span></dt><dd><p>
pass frames with failed PLCP CRC (but you need to set
the <code class="constant">RX_FLAG_FAILED_PLCP_CRC</code> for them
      </p></dd><dt><span class="term">FIF_BCN_PRBRESP_PROMISC</span></dt><dd><p>
This flag is set during scanning to indicate
to the hardware that it should not filter beacons or probe responses
by BSSID. Filtering them can greatly reduce the amount of processing
mac80211 needs to do and the amount of CPU wakeups, so you should
honour this flag if possible.
      </p></dd><dt><span class="term">FIF_CONTROL</span></dt><dd><p>
pass control frames (except for PS Poll), if PROMISC_IN_BSS
is not set then only those addressed to this station.
      </p></dd><dt><span class="term">FIF_OTHER_BSS</span></dt><dd><p>
pass frames destined to other BSSes
      </p></dd><dt><span class="term">FIF_PSPOLL</span></dt><dd><p>
pass PS Poll frames, if PROMISC_IN_BSS is not set then only
those addressed to this station.
      </p></dd><dt><span class="term">FIF_PROBE_REQ</span></dt><dd><p>
pass probe request frames
      </p></dd></dl></div></div><div class="refsect1" title="HW queue control"><a id="idp8139168"></a><h2>HW queue control</h2><p>
   </p><p>

   These flags determine what the filter in hardware should be
   programmed to let through and what should not be passed to the
   stack. It is always safe to pass more frames than requested,
   but this has negative impact on power consumption.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;The mac80211 workqueue"><div class="titlepage"><div><div><h2 class="title"><a id="workqueue"></a>Chapter&nbsp;6.&nbsp;The mac80211 workqueue</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-work"><span>ieee80211_queue_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-queue-delayed-work"><span>ieee80211_queue_delayed_work</span></a></span><span class="refpurpose"> — 
  add work onto the mac80211 workqueue
 </span></dt></dl></div><p>
   </p><p>
   mac80211 provides its own workqueue for drivers and internal mac80211 use.
   The workqueue is a single threaded workqueue and can only be accessed by
   helpers for sanity checking. Drivers must ensure all work added onto the
   mac80211 workqueue should be cancelled on the driver <code class="function">stop</code> callback.
   </p><p>
   mac80211 will flushed the workqueue upon interface removal and during
   suspend.
   </p><p>
   All work performed on the mac80211 workqueue must not acquire the RTNL lock.
   </p><p>
</p><div class="refentry" title="ieee80211_queue_work"><a id="API-ieee80211-queue-work"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_queue_work — 
  add work onto the mac80211 workqueue
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_queue_work </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">work</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct work_struct * <var class="pdparam">work</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8154992"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware struct for the interface we are adding work for
    </p></dd><dt><span class="term"><em class="parameter"><code>work</code></em></span></dt><dd><p>
     the work we want to add onto the mac80211 workqueue
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8160240"></a><h2>Description</h2><p>
   </p><p>

   Drivers and mac80211 use this to add work onto the mac80211 workqueue.
   This helper ensures drivers are not queueing work when they should not be.
</p></div></div><div class="refentry" title="ieee80211_queue_delayed_work"><div class="refentry.separator"><hr></div><a id="API-ieee80211-queue-delayed-work"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_queue_delayed_work — 
  add work onto the mac80211 workqueue
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_queue_delayed_work </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">dwork</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">delay</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct delayed_work * <var class="pdparam">dwork</var></code>;<br><code>unsigned long <var class="pdparam">delay</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8173024"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware struct for the interface we are adding work for
    </p></dd><dt><span class="term"><em class="parameter"><code>dwork</code></em></span></dt><dd><p>
     delayable work to queue onto the mac80211 workqueue
    </p></dd><dt><span class="term"><em class="parameter"><code>delay</code></em></span></dt><dd><p>
     number of jiffies to wait before queueing
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8180304"></a><h2>Description</h2><p>
   </p><p>

   Drivers and mac80211 use this to queue delayed work onto the mac80211
   workqueue.
</p></div></div></div></div><div class="part" title="Part&nbsp;II.&nbsp;Advanced driver interface"><div class="titlepage"><div><div><h1 class="title"><a id="advanced"></a>Part&nbsp;II.&nbsp;Advanced driver interface</h1></div></div></div><div class="partintro" title="Advanced driver interface"><div></div><p>
         Information contained within this part of the book is
         of interest only for advanced interaction of mac80211
         with drivers to exploit more hardware capabilities and
         improve performance.
        </p><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#led-support">7. LED support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tx-led-name"><span>ieee80211_get_tx_led_name</span></a></span><span class="refpurpose"> — 
  get name of TX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-rx-led-name"><span>ieee80211_get_rx_led_name</span></a></span><span class="refpurpose"> — 
  get name of RX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-assoc-led-name"><span>ieee80211_get_assoc_led_name</span></a></span><span class="refpurpose"> — 
  get name of association LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-radio-led-name"><span>ieee80211_get_radio_led_name</span></a></span><span class="refpurpose"> — 
  get name of radio LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tpt-blink"><span>struct ieee80211_tpt_blink</span></a></span><span class="refpurpose"> — 
  throughput blink description
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-tpt-led-trigger-flags"><span>enum ieee80211_tpt_led_trigger_flags</span></a></span><span class="refpurpose"> — 
  throughput trigger flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-create-tpt-led-trigger"><span>ieee80211_create_tpt_led_trigger</span></a></span><span class="refpurpose"> — 
  create throughput LED trigger
 </span></dt></dl></dd><dt><span class="chapter"><a href="#hardware-crypto-offload">8. Hardware crypto acceleration</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-enum-set-key-cmd"><span>enum set_key_cmd</span></a></span><span class="refpurpose"> — 
  key command
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-key-conf"><span>struct ieee80211_key_conf</span></a></span><span class="refpurpose"> — 
  key information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-key-flags"><span>enum ieee80211_key_flags</span></a></span><span class="refpurpose"> — 
  key flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k"><span>ieee80211_get_tkip_p1k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k-iv"><span>ieee80211_get_tkip_p1k_iv</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key for IV32
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p2k"><span>ieee80211_get_tkip_p2k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 2 key
 </span></dt></dl></dd><dt><span class="chapter"><a href="#powersave">9. Powersave support</a></span></dt><dt><span class="chapter"><a href="#beacon-filter">10. Beacon filter support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-loss"><span>ieee80211_beacon_loss</span></a></span><span class="refpurpose"> — 
  inform hardware does not receive beacons
 </span></dt></dl></dd><dt><span class="chapter"><a href="#qos">11. Multiple queues and QoS support</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-queue-params"><span>struct ieee80211_tx_queue_params</span></a></span><span class="refpurpose"> — 
  transmit queue configuration
 </span></dt></dl></dd><dt><span class="chapter"><a href="#AP">12. Access point mode support</a></span></dt><dd><dl><dt><span class="section"><a href="#ps-client">support for powersaving clients</a></span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-buffered-bc"><span>ieee80211_get_buffered_bc</span></a></span><span class="refpurpose"> — 
  accessing buffered broadcast and multicast frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-get"><span>ieee80211_beacon_get</span></a></span><span class="refpurpose"> — 
  beacon generation function
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-eosp"><span>ieee80211_sta_eosp</span></a></span><span class="refpurpose"> — 
  notify mac80211 about end of SP
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-frame-release-type"><span>enum ieee80211_frame_release_type</span></a></span><span class="refpurpose"> — 
  frame release reason
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition"><span>ieee80211_sta_ps_transition</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition-ni"><span>ieee80211_sta_ps_transition_ni</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta (in process context)
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-set-buffered"><span>ieee80211_sta_set_buffered</span></a></span><span class="refpurpose"> — 
  inform mac80211 about driver-buffered frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-block-awake"><span>ieee80211_sta_block_awake</span></a></span><span class="refpurpose"> — 
  block station from waking up
 </span></dt></dl></dd><dt><span class="chapter"><a href="#multi-iface">13. Supporting multiple virtual interfaces</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces"><span>ieee80211_iterate_active_interfaces</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces-atomic"><span>ieee80211_iterate_active_interfaces_atomic</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt></dl></dd><dt><span class="chapter"><a href="#station-handling">14. Station handling</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-sta"><span>struct ieee80211_sta</span></a></span><span class="refpurpose"> — 
  station table entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-sta-notify-cmd"><span>enum sta_notify_cmd</span></a></span><span class="refpurpose"> — 
  sta notify command
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta"><span>ieee80211_find_sta</span></a></span><span class="refpurpose"> — 
  find a station
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta-by-ifaddr"><span>ieee80211_find_sta_by_ifaddr</span></a></span><span class="refpurpose"> — 
  find a station on hardware
 </span></dt></dl></dd><dt><span class="chapter"><a href="#hardware-scan-offload">15. Hardware scan offload</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-scan-completed"><span>ieee80211_scan_completed</span></a></span><span class="refpurpose"> — 
  completed hardware scan
 </span></dt></dl></dd><dt><span class="chapter"><a href="#aggregation">16. Aggregation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp8840448">TX A-MPDU aggregation</a></span></dt><dt><span class="sect1"><a href="#idp8851200">RX A-MPDU aggregation</a></span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-ampdu-mlme-action"><span>enum ieee80211_ampdu_mlme_action</span></a></span><span class="refpurpose"> — 
  A-MPDU actions
 </span></dt></dl></dd><dt><span class="chapter"><a href="#smps">17. Spatial Multiplexing Powersave (SMPS)</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-request-smps"><span>ieee80211_request_smps</span></a></span><span class="refpurpose"> — 
  request SM PS transition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-smps-mode"><span>enum ieee80211_smps_mode</span></a></span><span class="refpurpose"> — 
  spatial multiplexing power save mode
 </span></dt></dl></dd></dl></div></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;LED support"><div class="titlepage"><div><div><h2 class="title"><a id="led-support"></a>Chapter&nbsp;7.&nbsp;LED support</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tx-led-name"><span>ieee80211_get_tx_led_name</span></a></span><span class="refpurpose"> — 
  get name of TX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-rx-led-name"><span>ieee80211_get_rx_led_name</span></a></span><span class="refpurpose"> — 
  get name of RX LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-assoc-led-name"><span>ieee80211_get_assoc_led_name</span></a></span><span class="refpurpose"> — 
  get name of association LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-radio-led-name"><span>ieee80211_get_radio_led_name</span></a></span><span class="refpurpose"> — 
  get name of radio LED
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tpt-blink"><span>struct ieee80211_tpt_blink</span></a></span><span class="refpurpose"> — 
  throughput blink description
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-tpt-led-trigger-flags"><span>enum ieee80211_tpt_led_trigger_flags</span></a></span><span class="refpurpose"> — 
  throughput trigger flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-create-tpt-led-trigger"><span>ieee80211_create_tpt_led_trigger</span></a></span><span class="refpurpose"> — 
  create throughput LED trigger
 </span></dt></dl></div><p>
         Mac80211 supports various ways of blinking LEDs. Wherever possible,
         device LEDs should be exposed as LED class devices and hooked up to
         the appropriate trigger, which will then be triggered appropriately
         by mac80211.
        </p><div class="refentry" title="ieee80211_get_tx_led_name"><a id="API-ieee80211-get-tx-led-name"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_tx_led_name — 
  get name of TX LED
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">char * <strong>fsfuncieee80211_get_tx_led_name </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8195344"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware to get the LED trigger name for
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8198528"></a><h2>Description</h2><p>
   </p><p>

   mac80211 creates a transmit LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <code class="constant">NULL</code> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</p></div><div class="refsect1" title="Return"><a id="idp8200688"></a><h2>Return</h2><p>
   The name of the LED trigger. <code class="constant">NULL</code> if not configured for LEDs.
</p></div></div><div class="refentry" title="ieee80211_get_rx_led_name"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-rx-led-name"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_rx_led_name — 
  get name of RX LED
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">char * <strong>fsfuncieee80211_get_rx_led_name </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8211616"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware to get the LED trigger name for
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8214800"></a><h2>Description</h2><p>
   </p><p>

   mac80211 creates a receive LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <code class="constant">NULL</code> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</p></div><div class="refsect1" title="Return"><a id="idp8216960"></a><h2>Return</h2><p>
   The name of the LED trigger. <code class="constant">NULL</code> if not configured for LEDs.
</p></div></div><div class="refentry" title="ieee80211_get_assoc_led_name"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-assoc-led-name"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_assoc_led_name — 
  get name of association LED
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">char * <strong>fsfuncieee80211_get_assoc_led_name </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8227856"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware to get the LED trigger name for
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8231040"></a><h2>Description</h2><p>
   </p><p>

   mac80211 creates a association LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <code class="constant">NULL</code> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</p></div><div class="refsect1" title="Return"><a id="idp8233216"></a><h2>Return</h2><p>
   The name of the LED trigger. <code class="constant">NULL</code> if not configured for LEDs.
</p></div></div><div class="refentry" title="ieee80211_get_radio_led_name"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-radio-led-name"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_radio_led_name — 
  get name of radio LED
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">char * <strong>fsfuncieee80211_get_radio_led_name </strong>(</code></td><td><var class="pdparam">hw</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8244160"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware to get the LED trigger name for
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8247344"></a><h2>Description</h2><p>
   </p><p>

   mac80211 creates a radio change LED trigger for each wireless hardware
   that can be used to drive LEDs if your driver registers a LED device.
   This function returns the name (or <code class="constant">NULL</code> if not configured for LEDs)
   of the trigger so you can automatically link the LED device.
</p></div><div class="refsect1" title="Return"><a id="idp8249520"></a><h2>Return</h2><p>
   The name of the LED trigger. <code class="constant">NULL</code> if not configured for LEDs.
</p></div></div><div class="refentry" title="struct ieee80211_tpt_blink"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-tpt-blink"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_tpt_blink — 
  throughput blink description
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_tpt_blink {
  int throughput;
  int blink_time;
};  </pre></div><div class="refsect1" title="Members"><a id="idp8258768"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">throughput</span></dt><dd><p>
throughput in Kbit/sec
      </p></dd><dt><span class="term">blink_time</span></dt><dd><p>
blink time in milliseconds
(full cycle, ie. one off + one on period)
      </p></dd></dl></div></div></div><div class="refentry" title="enum ieee80211_tpt_led_trigger_flags"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-tpt-led-trigger-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_tpt_led_trigger_flags — 
  throughput trigger flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_tpt_led_trigger_flags {
  IEEE80211_TPT_LEDTRIG_FL_RADIO,
  IEEE80211_TPT_LEDTRIG_FL_WORK,
  IEEE80211_TPT_LEDTRIG_FL_CONNECTED
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8270384"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_TPT_LEDTRIG_FL_RADIO</span></dt><dd><p>
enable blinking with radio
      </p></dd><dt><span class="term">IEEE80211_TPT_LEDTRIG_FL_WORK</span></dt><dd><p>
enable blinking when working
      </p></dd><dt><span class="term">IEEE80211_TPT_LEDTRIG_FL_CONNECTED</span></dt><dd><p>
enable blinking when at least one
interface is connected in some way, including being an AP
      </p></dd></dl></div></div></div><div class="refentry" title="ieee80211_create_tpt_led_trigger"><div class="refentry.separator"><hr></div><a id="API-ieee80211-create-tpt-led-trigger"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_create_tpt_led_trigger — 
  create throughput LED trigger
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">char * <strong>fsfuncieee80211_create_tpt_led_trigger </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">flags</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">blink_table</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">blink_table_len</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>unsigned int <var class="pdparam">flags</var></code>;<br><code>const struct ieee80211_tpt_blink * <var class="pdparam">blink_table</var></code>;<br><code>unsigned int <var class="pdparam">blink_table_len</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8287952"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware to create the trigger for
    </p></dd><dt><span class="term"><em class="parameter"><code>flags</code></em></span></dt><dd><p>
     trigger flags, see <span class="structname">enum</span> ieee80211_tpt_led_trigger_flags
    </p></dd><dt><span class="term"><em class="parameter"><code>blink_table</code></em></span></dt><dd><p>
     the blink table -- needs to be ordered by throughput
    </p></dd><dt><span class="term"><em class="parameter"><code>blink_table_len</code></em></span></dt><dd><p>
     size of the blink table
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp8297680"></a><h2>Return</h2><p>
   <code class="constant">NULL</code> (in case of error, or if no LED triggers are
   configured) or the name of the new trigger.
</p></div><div class="refsect1" title="Note"><a id="idp8299392"></a><h2>Note</h2><p>
   This function must be called before <code class="function">ieee80211_register_hw</code>.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Hardware crypto acceleration"><div class="titlepage"><div><div><h2 class="title"><a id="hardware-crypto-offload"></a>Chapter&nbsp;8.&nbsp;Hardware crypto acceleration</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-enum-set-key-cmd"><span>enum set_key_cmd</span></a></span><span class="refpurpose"> — 
  key command
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-key-conf"><span>struct ieee80211_key_conf</span></a></span><span class="refpurpose"> — 
  key information
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-key-flags"><span>enum ieee80211_key_flags</span></a></span><span class="refpurpose"> — 
  key flags
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k"><span>ieee80211_get_tkip_p1k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p1k-iv"><span>ieee80211_get_tkip_p1k_iv</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 1 key for IV32
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-tkip-p2k"><span>ieee80211_get_tkip_p2k</span></a></span><span class="refpurpose"> — 
  get a TKIP phase 2 key
 </span></dt></dl></div><p>
   </p><p>
   mac80211 is capable of taking advantage of many hardware
   acceleration designs for encryption and decryption operations.
   </p><p>
   The <code class="function">set_key</code> callback in the <span class="structname">struct ieee80211_ops</span> for a given
   device is called to enable hardware acceleration of encryption and
   decryption. The callback takes a <em class="parameter"><code>sta</code></em> parameter that will be NULL
   for default keys or keys used for transmission only, or point to
   the station information for the peer for individual keys.
   Multiple transmission keys with the same key index may be used when
   VLANs are configured for an access point.
   </p><p>
   When transmitting, the TX control data will use the <em class="parameter"><code>hw_key_idx</code></em>
   selected by the driver by modifying the <span class="structname">struct ieee80211_key_conf</span>
   pointed to by the <em class="parameter"><code>key</code></em> parameter to the <code class="function">set_key</code> function.
   </p><p>
   The <code class="function">set_key</code> call for the <code class="constant">SET_KEY</code> command should return 0 if
   the key is now in use, -<code class="constant">EOPNOTSUPP</code> or -<code class="constant">ENOSPC</code> if it couldn't be
   added; if you return 0 then hw_key_idx must be assigned to the
   hardware key index, you are free to use the full u8 range.
   </p><p>
   When the cmd is <code class="constant">DISABLE_KEY</code> then it must succeed.
   </p><p>
   Note that it is permissible to not decrypt a frame even if a key
   for it has been uploaded to hardware, the stack will not make any
   decision based on whether a key has been uploaded or not but rather
   based on the receive flags.
   </p><p>
   The <span class="structname">struct ieee80211_key_conf</span> structure pointed to by the <em class="parameter"><code>key</code></em>
   parameter is guaranteed to be valid until another call to <code class="function">set_key</code>
   removes it, but it can only be used as a cookie to differentiate
   keys.
   </p><p>
   In TKIP some HW need to be provided a phase 1 key, for RX decryption
   acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key
   handler.
   The <code class="function">update_tkip_key</code> call updates the driver with the new phase 1 key.
   This happens every time the iv16 wraps around (every 65536 packets). The
   <code class="function">set_key</code> call will happen only once for each key (unless the AP did
   rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
   provided by update_tkip_key only. The trigger that makes mac80211 call this
   handler is software decryption with wrap around of iv16.
   </p><p>
   The <code class="function">set_default_unicast_key</code> call updates the default WEP key index
   configured to the hardware for WEP encryption type. This is required
   for devices that support offload of data packets (e.g. ARP responses).
</p><div class="refentry" title="enum set_key_cmd"><a id="API-enum-set-key-cmd"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum set_key_cmd — 
  key command
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum set_key_cmd {
  SET_KEY,
  DISABLE_KEY
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8326224"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">SET_KEY</span></dt><dd><p>
a key is set
      </p></dd><dt><span class="term">DISABLE_KEY</span></dt><dd><p>
a key must be disabled
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8330112"></a><h2>Description</h2><p>
   </p><p>

   Used with the <code class="function">set_key</code> callback in <span class="structname">struct ieee80211_ops</span>, this
   indicates whether a key is being removed or added.
</p></div></div><div class="refentry" title="struct ieee80211_key_conf"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-key-conf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_key_conf — 
  key information
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_key_conf {
  u32 cipher;
  u8 icv_len;
  u8 iv_len;
  u8 hw_key_idx;
  u8 flags;
  s8 keyidx;
  u8 keylen;
  u8 key[0];
};  </pre></div><div class="refsect1" title="Members"><a id="idp8340464"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">cipher</span></dt><dd><p>
The key's cipher suite selector.
      </p></dd><dt><span class="term">icv_len</span></dt><dd><p>
The ICV length for this key type
      </p></dd><dt><span class="term">iv_len</span></dt><dd><p>
The IV length for this key type
      </p></dd><dt><span class="term">hw_key_idx</span></dt><dd><p>
To be set by the driver, this is the key index the driver
wants to be given when a frame is transmitted and needs to be
encrypted in hardware.
      </p></dd><dt><span class="term">flags</span></dt><dd><p>
key flags, see <span class="structname">enum</span> ieee80211_key_flags.
      </p></dd><dt><span class="term">keyidx</span></dt><dd><p>
the key index (0-3)
      </p></dd><dt><span class="term">keylen</span></dt><dd><p>
key material length
      </p></dd><dt><span class="term">key[0]</span></dt><dd><p>
key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8353168"></a><h2>Description</h2><p>
   </p><p>

   This key information is given by mac80211 to the driver by
   the <code class="function">set_key</code> callback in <span class="structname">struct ieee80211_ops</span>.
</p></div><div class="refsect1" title="data block"><a id="idp8355824"></a><h2>data block</h2><p>
   - Temporal Encryption Key (128 bits)
   - Temporal Authenticator Tx MIC Key (64 bits)
   - Temporal Authenticator Rx MIC Key (64 bits)
</p></div></div><div class="refentry" title="enum ieee80211_key_flags"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-key-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_key_flags — 
  key flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_key_flags {
  IEEE80211_KEY_FLAG_GENERATE_IV,
  IEEE80211_KEY_FLAG_GENERATE_MMIC,
  IEEE80211_KEY_FLAG_PAIRWISE,
  IEEE80211_KEY_FLAG_SW_MGMT_TX,
  IEEE80211_KEY_FLAG_PUT_IV_SPACE,
  IEEE80211_KEY_FLAG_RX_MGMT
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8364912"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_KEY_FLAG_GENERATE_IV</span></dt><dd><p>
This flag should be set by the
driver to indicate that it requires IV generation for this
particular key.
      </p></dd><dt><span class="term">IEEE80211_KEY_FLAG_GENERATE_MMIC</span></dt><dd><p>
This flag should be set by
the driver for a TKIP key if it requires Michael MIC
generation in software.
      </p></dd><dt><span class="term">IEEE80211_KEY_FLAG_PAIRWISE</span></dt><dd><p>
Set by mac80211, this flag indicates
that the key is pairwise rather then a shared key.
      </p></dd><dt><span class="term">IEEE80211_KEY_FLAG_SW_MGMT_TX</span></dt><dd><p>
This flag should be set by the driver for a
CCMP key if it requires CCMP encryption of management frames (MFP) to
be done in software.
      </p></dd><dt><span class="term">IEEE80211_KEY_FLAG_PUT_IV_SPACE</span></dt><dd><p>
This flag should be set by the driver
if space should be prepared for the IV, but the IV
itself should not be generated. Do not set together with
<em class="parameter"><code>IEEE80211_KEY_FLAG_GENERATE_IV</code></em> on the same key.
      </p></dd><dt><span class="term">IEEE80211_KEY_FLAG_RX_MGMT</span></dt><dd><p>
This key will be used to decrypt received
management frames. The flag can help drivers that have a hardware
crypto implementation that doesn't deal with management frames
properly by allowing them to not upload the keys to hardware and
fall back to software crypto. Note that this flag deals only with
RX, if your crypto engine can't deal with TX you can also set the
<code class="constant">IEEE80211_KEY_FLAG_SW_MGMT_TX</code> flag to encrypt such frames in SW.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8376384"></a><h2>Description</h2><p>
   </p><p>

   These flags are used for communication about keys between the driver
   and mac80211, with the <em class="parameter"><code>flags</code></em> parameter of <span class="structname">struct ieee80211_key_conf</span>.
</p></div></div><div class="refentry" title="ieee80211_get_tkip_p1k"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-tkip-p1k"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_tkip_p1k — 
  get a TKIP phase 1 key
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_get_tkip_p1k </strong>(</code></td><td><var class="pdparam">keyconf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">p1k</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_key_conf * <var class="pdparam">keyconf</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;<br><code>u16 * <var class="pdparam">p1k</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8390272"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>keyconf</code></em></span></dt><dd><p>
     the parameter passed with the set key
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the packet to take the IV32 value from that will be encrypted
     with this P1K
    </p></dd><dt><span class="term"><em class="parameter"><code>p1k</code></em></span></dt><dd><p>
     a buffer to which the key will be written, as 5 u16 values
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8397552"></a><h2>Description</h2><p>
   </p><p>

   This function returns the TKIP phase 1 key for the IV32 taken
   from the given packet.
</p></div></div><div class="refentry" title="ieee80211_get_tkip_p1k_iv"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-tkip-p1k-iv"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_tkip_p1k_iv — 
  get a TKIP phase 1 key for IV32
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_get_tkip_p1k_iv </strong>(</code></td><td><var class="pdparam">keyconf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iv32</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">p1k</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_key_conf * <var class="pdparam">keyconf</var></code>;<br><code>u32 <var class="pdparam">iv32</var></code>;<br><code>u16 * <var class="pdparam">p1k</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8410272"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>keyconf</code></em></span></dt><dd><p>
     the parameter passed with the set key
    </p></dd><dt><span class="term"><em class="parameter"><code>iv32</code></em></span></dt><dd><p>
     IV32 to get the P1K for
    </p></dd><dt><span class="term"><em class="parameter"><code>p1k</code></em></span></dt><dd><p>
     a buffer to which the key will be written, as 5 u16 values
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8417520"></a><h2>Description</h2><p>
   </p><p>

   This function returns the TKIP phase 1 key for the given IV32.
</p></div></div><div class="refentry" title="ieee80211_get_tkip_p2k"><div class="refentry.separator"><hr></div><a id="API-ieee80211-get-tkip-p2k"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_tkip_p2k — 
  get a TKIP phase 2 key
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_get_tkip_p2k </strong>(</code></td><td><var class="pdparam">keyconf</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">skb</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">p2k</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_key_conf * <var class="pdparam">keyconf</var></code>;<br><code>struct sk_buff * <var class="pdparam">skb</var></code>;<br><code>u8 * <var class="pdparam">p2k</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8430176"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>keyconf</code></em></span></dt><dd><p>
     the parameter passed with the set key
    </p></dd><dt><span class="term"><em class="parameter"><code>skb</code></em></span></dt><dd><p>
     the packet to take the IV32/IV16 values from that will be
     encrypted with this key
    </p></dd><dt><span class="term"><em class="parameter"><code>p2k</code></em></span></dt><dd><p>
     a buffer to which the key will be written, 16 bytes
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8437456"></a><h2>Description</h2><p>
   </p><p>

   This function computes the TKIP RC4 key for the IV values
   in the packet.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;9.&nbsp;Powersave support"><div class="titlepage"><div><div><h2 class="title"><a id="powersave"></a>Chapter&nbsp;9.&nbsp;Powersave support</h2></div></div></div><p>
   </p><p>
   mac80211 has support for various powersave implementations.
   </p><p>
   First, it can support hardware that handles all powersaving by itself,
   such hardware should simply set the <code class="constant">IEEE80211_HW_SUPPORTS_PS</code> hardware
   flag. In that case, it will be told about the desired powersave mode
   with the <code class="constant">IEEE80211_CONF_PS</code> flag depending on the association status.
   The hardware must take care of sending nullfunc frames when necessary,
   i.e. when entering and leaving powersave mode. The hardware is required
   to look at the AID in beacons and signal to the AP that it woke up when
   it finds traffic directed to it.
   </p><p>
   <code class="constant">IEEE80211_CONF_PS</code> flag enabled means that the powersave mode defined in
   IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused
   with hardware wakeup and sleep states. Driver is responsible for waking
   up the hardware before issuing commands to the hardware and putting it
   back to sleep at appropriate times.
   </p><p>
   When PS is enabled, hardware needs to wakeup for beacons and receive the
   buffered multicast/broadcast frames after the beacon. Also it must be
   possible to send frames and receive the acknowledment frame.
   </p><p>
   Other hardware designs cannot send nullfunc frames by themselves and also
   need software support for parsing the TIM bitmap. This is also supported
   by mac80211 by combining the <code class="constant">IEEE80211_HW_SUPPORTS_PS</code> and
   <code class="constant">IEEE80211_HW_PS_NULLFUNC_STACK</code> flags. The hardware is of course still
   required to pass up beacons. The hardware is still required to handle
   waking up for multicast traffic; if it cannot the driver must handle that
   as best as it can, mac80211 is too slow to do that.
   </p><p>
   Dynamic powersave is an extension to normal powersave in which the
   hardware stays awake for a user-specified period of time after sending a
   frame so that reply frames need not be buffered and therefore delayed to
   the next wakeup. It's compromise of getting good enough latency when
   there's data traffic and still saving significantly power in idle
   periods.
   </p><p>
   Dynamic powersave is simply supported by mac80211 enabling and disabling
   PS based on traffic. Driver needs to only set <code class="constant">IEEE80211_HW_SUPPORTS_PS</code>
   flag and mac80211 will handle everything automatically. Additionally,
   hardware having support for the dynamic PS feature may set the
   <code class="constant">IEEE80211_HW_SUPPORTS_DYNAMIC_PS</code> flag to indicate that it can support
   dynamic PS mode itself. The driver needs to look at the
   <em class="parameter"><code>dynamic_ps_timeout</code></em> hardware configuration value and use it that value
   whenever <code class="constant">IEEE80211_CONF_PS</code> is set. In this case mac80211 will disable
   dynamic PS feature in stack and will just keep <code class="constant">IEEE80211_CONF_PS</code>
   enabled whenever user has enabled powersave.
   </p><p>
   Driver informs U-APSD client support by enabling
   <code class="constant">IEEE80211_HW_SUPPORTS_UAPSD</code> flag. The mode is configured through the
   uapsd paramater in <code class="function">conf_tx</code> operation. Hardware needs to send the QoS
   Nullfunc frames and stay awake until the service period has ended. To
   utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
   from that AC are transmitted with powersave enabled.
   </p><p>
   Note: U-APSD client mode is not yet supported with
   <code class="constant">IEEE80211_HW_PS_NULLFUNC_STACK</code>.
</p></div><div class="chapter" title="Chapter&nbsp;10.&nbsp;Beacon filter support"><div class="titlepage"><div><div><h2 class="title"><a id="beacon-filter"></a>Chapter&nbsp;10.&nbsp;Beacon filter support</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-loss"><span>ieee80211_beacon_loss</span></a></span><span class="refpurpose"> — 
  inform hardware does not receive beacons
 </span></dt></dl></div><p>
   </p><p>
   Some hardware have beacon filter support to reduce host cpu wakeups
   which will reduce system power consumption. It usually works so that
   the firmware creates a checksum of the beacon but omits all constantly
   changing elements (TSF, TIM etc). Whenever the checksum changes the
   beacon is forwarded to the host, otherwise it will be just dropped. That
   way the host will only receive beacons where some relevant information
   (for example ERP protection or WMM settings) have changed.
   </p><p>
   Beacon filter support is advertised with the <code class="constant">IEEE80211_VIF_BEACON_FILTER</code>
   interface capability. The driver needs to enable beacon filter support
   whenever power save is enabled, that is <code class="constant">IEEE80211_CONF_PS</code> is set. When
   power save is enabled, the stack will not check for beacon loss and the
   driver needs to notify about loss of beacons with <code class="function">ieee80211_beacon_loss</code>.
   </p><p>
   The time (or number of beacons missed) until the firmware notifies the
   driver of a beacon loss event (which in turn causes the driver to call
   <code class="function">ieee80211_beacon_loss</code>) should be configurable and will be controlled
   by mac80211 and the roaming algorithm in the future.
   </p><p>
   Since there may be constantly changing information elements that nothing
   in the software stack cares about, we will, in the future, have mac80211
   tell the driver which information elements are interesting in the sense
   that we want to see changes in them. This will include
   - a list of information element IDs
   - a list of OUIs for the vendor information element
   </p><p>
   Ideally, the hardware would filter out any beacons without changes in the
   requested elements, but if it cannot support that it may, at the expense
   of some efficiency, filter out only a subset. For example, if the device
   doesn't support checking for OUIs it should pass up all changes in all
   vendor information elements.
   </p><p>
   Note that change, for the sake of simplification, also includes information
   elements appearing or disappearing from the beacon.
   </p><p>
   Some hardware supports an <span class="quote">“<span class="quote">ignore list</span>”</span> instead, just make sure nothing
   that was requested is on the ignore list, and include commonly changing
   information element IDs in the ignore list, for example 11 (BSS load) and
   the various vendor-assigned IEs with unknown contents (128, 129, 133-136,
   149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility
   it could also include some currently unused IDs.
   </p><p>
   </p><p>
   In addition to these capabilities, hardware should support notifying the
   host of changes in the beacon RSSI. This is relevant to implement roaming
   when no traffic is flowing (when traffic is flowing we see the RSSI of
   the received data packets). This can consist in notifying the host when
   the RSSI changes significantly or when it drops below or rises above
   configurable thresholds. In the future these thresholds will also be
   configured by mac80211 (which gets them from userspace) to implement
   them as the roaming algorithm requires.
   </p><p>
   If the hardware cannot implement this, the driver should ask it to
   periodically pass beacon frames to the host so that software can do the
   signal strength threshold checking.
</p><div class="refentry" title="ieee80211_beacon_loss"><a id="API-ieee80211-beacon-loss"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_beacon_loss — 
  inform hardware does not receive beacons
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_beacon_loss </strong>(</code></td><td><var class="pdparam">vif</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8472096"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8475696"></a><h2>Description</h2><p>
   When beacon filtering is enabled with <code class="constant">IEEE80211_VIF_BEACON_FILTER</code> and
   <code class="constant">IEEE80211_CONF_PS</code> is set, the driver needs to inform whenever the
   hardware is not receiving beacons with this function.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;11.&nbsp;Multiple queues and QoS support"><div class="titlepage"><div><div><h2 class="title"><a id="qos"></a>Chapter&nbsp;11.&nbsp;Multiple queues and QoS support</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-queue-params"><span>struct ieee80211_tx_queue_params</span></a></span><span class="refpurpose"> — 
  transmit queue configuration
 </span></dt></dl></div><p>TBD</p><div class="refentry" title="struct ieee80211_tx_queue_params"><a id="API-struct-ieee80211-tx-queue-params"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_tx_queue_params — 
  transmit queue configuration
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_tx_queue_params {
  u16 txop;
  u16 cw_min;
  u16 cw_max;
  u8 aifs;
  bool acm;
  bool uapsd;
};  </pre></div><div class="refsect1" title="Members"><a id="idp8487136"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">txop</span></dt><dd><p>
maximum burst time in units of 32 usecs, 0 meaning disabled
      </p></dd><dt><span class="term">cw_min</span></dt><dd><p>
minimum contention window [a value of the form
2^n-1 in the range 1..32767]
      </p></dd><dt><span class="term">cw_max</span></dt><dd><p>
maximum contention window [like <em class="parameter"><code>cw_min</code></em>]
      </p></dd><dt><span class="term">aifs</span></dt><dd><p>
arbitration interframe space [0..255]
      </p></dd><dt><span class="term">acm</span></dt><dd><p>
is mandatory admission control required for the access category
      </p></dd><dt><span class="term">uapsd</span></dt><dd><p>
is U-APSD mode enabled for the queue
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8497360"></a><h2>Description</h2><p>
   </p><p>

   The information provided in this structure is required for QoS
   transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;12.&nbsp;Access point mode support"><div class="titlepage"><div><div><h2 class="title"><a id="AP"></a>Chapter&nbsp;12.&nbsp;Access point mode support</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#ps-client">support for powersaving clients</a></span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-get-buffered-bc"><span>ieee80211_get_buffered_bc</span></a></span><span class="refpurpose"> — 
  accessing buffered broadcast and multicast frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-beacon-get"><span>ieee80211_beacon_get</span></a></span><span class="refpurpose"> — 
  beacon generation function
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-eosp"><span>ieee80211_sta_eosp</span></a></span><span class="refpurpose"> — 
  notify mac80211 about end of SP
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-frame-release-type"><span>enum ieee80211_frame_release_type</span></a></span><span class="refpurpose"> — 
  frame release reason
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition"><span>ieee80211_sta_ps_transition</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-ps-transition-ni"><span>ieee80211_sta_ps_transition_ni</span></a></span><span class="refpurpose"> — 
  PS transition for connected sta (in process context)
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-set-buffered"><span>ieee80211_sta_set_buffered</span></a></span><span class="refpurpose"> — 
  inform mac80211 about driver-buffered frames
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-sta-block-awake"><span>ieee80211_sta_block_awake</span></a></span><span class="refpurpose"> — 
  block station from waking up
 </span></dt></dl></div><p>TBD</p><p>Some parts of the if_conf should be discussed here instead</p><p>
          Insert notes about VLAN interfaces with hw crypto here or
          in the hw crypto chapter.
        </p><div class="section" title="support for powersaving clients"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ps-client"></a>support for powersaving clients</h2></div></div></div><p>
   </p><p>
   In order to implement AP and P2P GO modes, mac80211 has support for
   client powersaving, both <span class="quote">“<span class="quote">legacy</span>”</span> PS (PS-Poll/null data) and uAPSD.
   There currently is no support for sAPSD.
   </p><p>
   There is one assumption that mac80211 makes, namely that a client
   will not poll with PS-Poll and trigger with uAPSD at the same time.
   Both are supported, and both can be used by the same client, but
   they can't be used concurrently by the same client. This simplifies
   the driver code.
   </p><p>
   The first thing to keep in mind is that there is a flag for complete
   driver implementation: <code class="constant">IEEE80211_HW_AP_LINK_PS</code>. If this flag is set,
   mac80211 expects the driver to handle most of the state machine for
   powersaving clients and will ignore the PM bit in incoming frames.
   Drivers then use <code class="function">ieee80211_sta_ps_transition</code> to inform mac80211 of
   stations' powersave transitions. In this mode, mac80211 also doesn't
   handle PS-Poll/uAPSD.
   </p><p>
   In the mode without <code class="constant">IEEE80211_HW_AP_LINK_PS</code>, mac80211 will check the
   PM bit in incoming frames for client powersave transitions. When a
   station goes to sleep, we will stop transmitting to it. There is,
   however, a race condition: a station might go to sleep while there is
   data buffered on hardware queues. If the device has support for this
   it will reject frames, and the driver should give the frames back to
   mac80211 with the <code class="constant">IEEE80211_TX_STAT_TX_FILTERED</code> flag set which will
   cause mac80211 to retry the frame when the station wakes up. The
   driver is also notified of powersave transitions by calling its
   <em class="parameter"><code>sta_notify</code></em> callback.
   </p><p>
   When the station is asleep, it has three choices: it can wake up,
   it can PS-Poll, or it can possibly start a uAPSD service period.
   Waking up is implemented by simply transmitting all buffered (and
   filtered) frames to the station. This is the easiest case. When
   the station sends a PS-Poll or a uAPSD trigger frame, mac80211
   will inform the driver of this with the <em class="parameter"><code>allow_buffered_frames</code></em>
   callback; this callback is optional. mac80211 will then transmit
   the frames as usual and set the <code class="constant">IEEE80211_TX_CTL_NO_PS_BUFFER</code>
   on each frame. The last frame in the service period (or the only
   response to a PS-Poll) also has <code class="constant">IEEE80211_TX_STATUS_EOSP</code> set to
   indicate that it ends the service period; as this frame must have
   TX status report it also sets <code class="constant">IEEE80211_TX_CTL_REQ_TX_STATUS</code>.
   When TX status is reported for this frame, the service period is
   marked has having ended and a new one can be started by the peer.
   </p><p>
   Additionally, non-bufferable MMPDUs can also be transmitted by
   mac80211 with the <code class="constant">IEEE80211_TX_CTL_NO_PS_BUFFER</code> set in them.
   </p><p>
   Another race condition can happen on some devices like iwlwifi
   when there are frames queued for the station and it wakes up
   or polls; the frames that are already queued could end up being
   transmitted first instead, causing reordering and/or wrong
   processing of the EOSP. The cause is that allowing frames to be
   transmitted to a certain station is out-of-band communication to
   the device. To allow this problem to be solved, the driver can
   call <code class="function">ieee80211_sta_block_awake</code> if frames are buffered when it
   is notified that the station went to sleep. When all these frames
   have been filtered (see above), it must call the function again
   to indicate that the station is no longer blocked.
   </p><p>
   If the driver buffers frames in the driver for aggregation in any
   way, it must use the <code class="function">ieee80211_sta_set_buffered</code> call when it is
   notified of the station going to sleep to inform mac80211 of any
   TIDs that have frames buffered. Note that when a station wakes up
   this information is reset (hence the requirement to call it when
   informed of the station going to sleep). Then, when a service
   period starts for any reason, <em class="parameter"><code>release_buffered_frames</code></em> is called
   with the number of frames to be released and which TIDs they are
   to come from. In this case, the driver is responsible for setting
   the EOSP (for uAPSD) and MORE_DATA bits in the released frames,
   to help the <em class="parameter"><code>more_data</code></em> paramter is passed to tell the driver if
   there is more data on other TIDs -- the TIDs to release frames
   from are ignored since mac80211 doesn't know how many frames the
   buffers for those TIDs contain.
   </p><p>
   If the driver also implement GO mode, where absence periods may
   shorten service periods (or abort PS-Poll responses), it must
   filter those response frames except in the case of frames that
   are buffered in the driver -- those must remain buffered to avoid
   reordering. Because it is possible that no frames are released
   in this case, the driver must call <code class="function">ieee80211_sta_eosp</code>
   to indicate to mac80211 that the service period ended anyway.
   </p><p>
   Finally, if frames from multiple TIDs are released from mac80211
   but the driver might reorder them, it must clear &amp; set the flags
   appropriately (only the last frame may have <code class="constant">IEEE80211_TX_STATUS_EOSP</code>)
   and also take care of the EOSP and MORE_DATA bits in the frame.
   The driver may also use <code class="function">ieee80211_sta_eosp</code> in this case.
</p></div><div class="refentry" title="ieee80211_get_buffered_bc"><a id="API-ieee80211-get-buffered-bc"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_get_buffered_bc — 
  accessing buffered broadcast and multicast frames
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct sk_buff * <strong>fsfuncieee80211_get_buffered_bc </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">vif</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8531728"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer as obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8538032"></a><h2>Description</h2><p>
   Function for accessing buffered broadcast and multicast frames. If
   hardware/firmware does not implement buffering of broadcast/multicast
   frames when power saving is used, 802.11 code buffers them in the host
   memory. The low-level driver uses this function to fetch next buffered
   frame. In most cases, this is used when generating beacon frame.
</p></div><div class="refsect1" title="Return"><a id="idp8539600"></a><h2>Return</h2><p>
   A pointer to the next buffered skb or NULL if no more buffered
   frames are available.
</p></div><div class="refsect1" title="Note"><a id="idp8540896"></a><h2>Note</h2><p>
   buffered frames are returned only after DTIM beacon frame was
   generated with <code class="function">ieee80211_beacon_get</code> and the low-level driver must thus
   call <code class="function">ieee80211_beacon_get</code> first. <code class="function">ieee80211_get_buffered_bc</code> returns
   NULL if the previous generated beacon was not DTIM, so the low-level driver
   does not need to check for DTIM beacons separately and should be able to
   use common code for all beacons.
</p></div></div><div class="refentry" title="ieee80211_beacon_get"><div class="refentry.separator"><hr></div><a id="API-ieee80211-beacon-get"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_beacon_get — 
  beacon generation function
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct sk_buff * <strong>fsfuncieee80211_beacon_get </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">vif</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8554672"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer obtained from <code class="function">ieee80211_alloc_hw</code>.
    </p></dd><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8560976"></a><h2>Description</h2><p>
   See <code class="function">ieee80211_beacon_get_tim</code>.
</p></div><div class="refsect1" title="Return"><a id="idp8562896"></a><h2>Return</h2><p>
   See <code class="function">ieee80211_beacon_get_tim</code>.
</p></div></div><div class="refentry" title="ieee80211_sta_eosp"><div class="refentry.separator"><hr></div><a id="API-ieee80211-sta-eosp"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_sta_eosp — 
  notify mac80211 about end of SP
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_sta_eosp </strong>(</code></td><td><var class="pdparam">pubsta</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_sta * <var class="pdparam">pubsta</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8574080"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>pubsta</code></em></span></dt><dd><p>
     the station
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8577264"></a><h2>Description</h2><p>
   When a device transmits frames in a way that it can't tell
   mac80211 in the TX status about the EOSP, it must clear the
   <code class="constant">IEEE80211_TX_STATUS_EOSP</code> bit and call this function instead.
   This applies for PS-Poll as well as uAPSD.
   </p><p>

   Note that just like with <code class="function">_tx_status</code> and <code class="function">_rx</code> drivers must
   not mix calls to irqsafe/non-irqsafe versions, this function
   must not be mixed with those either. Use the all irqsafe, or
   all non-irqsafe, don't mix!
</p></div><div class="refsect1" title="NB"><a id="idp8581040"></a><h2>NB</h2><p>
   the _irqsafe version of this function doesn't exist, no
   driver needs it right now. Don't call this function if
   you'd need the _irqsafe version, look at the git history
   and restore the _irqsafe version!
</p></div></div><div class="refentry" title="enum ieee80211_frame_release_type"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-frame-release-type"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_frame_release_type — 
  frame release reason
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_frame_release_type {
  IEEE80211_FRAME_RELEASE_PSPOLL,
  IEEE80211_FRAME_RELEASE_UAPSD
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8590000"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_FRAME_RELEASE_PSPOLL</span></dt><dd><p>
frame released for PS-Poll
      </p></dd><dt><span class="term">IEEE80211_FRAME_RELEASE_UAPSD</span></dt><dd><p>
frame(s) released due to
frame received on trigger-enabled AC
      </p></dd></dl></div></div></div><div class="refentry" title="ieee80211_sta_ps_transition"><div class="refentry.separator"><hr></div><a id="API-ieee80211-sta-ps-transition"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_sta_ps_transition — 
  PS transition for connected sta
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_sta_ps_transition </strong>(</code></td><td><var class="pdparam">sta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">start</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_sta * <var class="pdparam">sta</var></code>;<br><code>bool <var class="pdparam">start</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8604208"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>sta</code></em></span></dt><dd><p>
     currently connected sta
    </p></dd><dt><span class="term"><em class="parameter"><code>start</code></em></span></dt><dd><p>
     start or stop PS
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8609392"></a><h2>Description</h2><p>
   </p><p>

   When operating in AP mode with the <code class="constant">IEEE80211_HW_AP_LINK_PS</code>
   flag set, use this function to inform mac80211 about a connected station
   entering/leaving PS mode.
   </p><p>

   This function may not be called in IRQ context or with softirqs enabled.
   </p><p>

   Calls to this function for a single hardware must be synchronized against
   each other.
</p></div><div class="refsect1" title="Return"><a id="idp8612160"></a><h2>Return</h2><p>
   0 on success. -EINVAL when the requested PS mode is already set.
</p></div></div><div class="refentry" title="ieee80211_sta_ps_transition_ni"><div class="refentry.separator"><hr></div><a id="API-ieee80211-sta-ps-transition-ni"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_sta_ps_transition_ni — 
  PS transition for connected sta (in process context)
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_sta_ps_transition_ni </strong>(</code></td><td><var class="pdparam">sta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">start</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_sta * <var class="pdparam">sta</var></code>;<br><code>bool <var class="pdparam">start</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8623696"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>sta</code></em></span></dt><dd><p>
     currently connected sta
    </p></dd><dt><span class="term"><em class="parameter"><code>start</code></em></span></dt><dd><p>
     start or stop PS
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8628880"></a><h2>Description</h2><p>
   </p><p>

   Like <code class="function">ieee80211_sta_ps_transition</code> but can be called in process context
   (internally disables bottom halves). Concurrent call restriction still
   applies.
</p></div><div class="refsect1" title="Return"><a id="idp8631200"></a><h2>Return</h2><p>
   Like <code class="function">ieee80211_sta_ps_transition</code>.
</p></div></div><div class="refentry" title="ieee80211_sta_set_buffered"><div class="refentry.separator"><hr></div><a id="API-ieee80211-sta-set-buffered"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_sta_set_buffered — 
  inform mac80211 about driver-buffered frames
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_sta_set_buffered </strong>(</code></td><td><var class="pdparam">sta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">buffered</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_sta * <var class="pdparam">sta</var></code>;<br><code>u8 <var class="pdparam">tid</var></code>;<br><code>bool <var class="pdparam">buffered</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8644272"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>sta</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_sta</span> pointer for the sleeping station
    </p></dd><dt><span class="term"><em class="parameter"><code>tid</code></em></span></dt><dd><p>
     the TID that has buffered frames
    </p></dd><dt><span class="term"><em class="parameter"><code>buffered</code></em></span></dt><dd><p>
     indicates whether or not frames are buffered for this TID
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8651904"></a><h2>Description</h2><p>
   If a driver buffers frames for a powersave station instead of passing
   them back to mac80211 for retransmission, the station may still need
   to be told that there are buffered frames via the TIM bit.
   </p><p>

   This function informs mac80211 whether or not there are frames that are
   buffered in the driver for a given TID; mac80211 can then use this data
   to set the TIM bit (NOTE: This may call back into the driver's set_tim
   call! Beware of the locking!)
   </p><p>

   If all frames are released to the station (due to PS-poll or uAPSD)
   then the driver needs to inform mac80211 that there no longer are
   frames buffered. However, when the station wakes up mac80211 assumes
   that all buffered frames will be transmitted and clears this data,
   drivers need to make sure they inform mac80211 about all buffered
   frames on the sleep transition (<code class="function">sta_notify</code> with <code class="constant">STA_NOTIFY_SLEEP</code>).
   </p><p>

   Note that technically mac80211 only needs to know this per AC, not per
   TID, but since driver buffering will inevitably happen per TID (since
   it is related to aggregation) it is easier to make mac80211 map the
   TID to the AC as required instead of keeping track in all drivers that
   use this API.
</p></div></div><div class="refentry" title="ieee80211_sta_block_awake"><div class="refentry.separator"><hr></div><a id="API-ieee80211-sta-block-awake"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_sta_block_awake — 
  block station from waking up
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_sta_block_awake </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">pubsta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">block</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>struct ieee80211_sta * <var class="pdparam">pubsta</var></code>;<br><code>bool <var class="pdparam">block</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8667504"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware
    </p></dd><dt><span class="term"><em class="parameter"><code>pubsta</code></em></span></dt><dd><p>
     the station
    </p></dd><dt><span class="term"><em class="parameter"><code>block</code></em></span></dt><dd><p>
     whether to block or unblock
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8674672"></a><h2>Description</h2><p>
   Some devices require that all frames that are on the queues
   for a specific station that went to sleep are flushed before
   a poll response or frames after the station woke up can be
   delivered to that it. Note that such frames must be rejected
   by the driver as filtered, with the appropriate status flag.
   </p><p>

   This function allows implementing this mode in a race-free
   manner.
   </p><p>

   To do this, a driver must keep track of the number of frames
   still enqueued for a specific station. If this number is not
   zero when the station goes to sleep, the driver must call
   this function to force mac80211 to consider the station to
   be asleep regardless of the station's actual state. Once the
   number of outstanding frames reaches zero, the driver must
   call this function again to unblock the station. That will
   cause mac80211 to be able to send ps-poll responses, and if
   the station queried in the meantime then frames will also
   be sent out as a result of this. Additionally, the driver
   will be notified that the station woke up some time after
   it is unblocked, regardless of whether the station actually
   woke up while blocked or not.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Supporting multiple virtual interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="multi-iface"></a>Chapter&nbsp;13.&nbsp;Supporting multiple virtual interfaces</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces"><span>ieee80211_iterate_active_interfaces</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-iterate-active-interfaces-atomic"><span>ieee80211_iterate_active_interfaces_atomic</span></a></span><span class="refpurpose"> — 
  iterate active interfaces
 </span></dt></dl></div><p>TBD</p><p>
          Note: WDS with identical MAC address should almost always be OK
        </p><p>
          Insert notes about having multiple virtual interfaces with
          different MAC addresses here, note which configurations are
          supported by mac80211, add notes about supporting hw crypto
          with it.
        </p><div class="refentry" title="ieee80211_iterate_active_interfaces"><a id="API-ieee80211-iterate-active-interfaces"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_iterate_active_interfaces — 
  iterate active interfaces
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_iterate_active_interfaces </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iter_flags</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iterator</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">data</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>u32 <var class="pdparam">iter_flags</var></code>;<br><code>void (*<var class="pdparam">iterator</var>)
     <code>(</code>void *data, u8 *mac, 						struct ieee80211_vif *vif<code>)</code></code>;<br><code>void * <var class="pdparam">data</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8693072"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware struct of which the interfaces should be iterated over
    </p></dd><dt><span class="term"><em class="parameter"><code>iter_flags</code></em></span></dt><dd><p>
     iteration flags, see <span class="structname">enum</span> ieee80211_interface_iteration_flags
    </p></dd><dt><span class="term"><em class="parameter"><code>iterator</code></em></span></dt><dd><p>
     the iterator function to call
    </p></dd><dt><span class="term"><em class="parameter"><code>data</code></em></span></dt><dd><p>
     first argument of the iterator function
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8702848"></a><h2>Description</h2><p>
   </p><p>

   This function iterates over the interfaces associated with a given
   hardware that are currently active and calls the callback for them.
   This function allows the iterator function to sleep, when the iterator
   function is atomic <em class="parameter"><code>ieee80211_iterate_active_interfaces_atomic</code></em> can
   be used.
   Does not iterate over a new interface during <code class="function">add_interface</code>.
</p></div></div><div class="refentry" title="ieee80211_iterate_active_interfaces_atomic"><div class="refentry.separator"><hr></div><a id="API-ieee80211-iterate-active-interfaces-atomic"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_iterate_active_interfaces_atomic — 
  iterate active interfaces
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_iterate_active_interfaces_atomic </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iter_flags</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">iterator</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">data</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>u32 <var class="pdparam">iter_flags</var></code>;<br><code>void (*<var class="pdparam">iterator</var>)
     <code>(</code>void *data, 						    u8 *mac, 						    struct ieee80211_vif *vif<code>)</code></code>;<br><code>void * <var class="pdparam">data</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8718736"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware struct of which the interfaces should be iterated over
    </p></dd><dt><span class="term"><em class="parameter"><code>iter_flags</code></em></span></dt><dd><p>
     iteration flags, see <span class="structname">enum</span> ieee80211_interface_iteration_flags
    </p></dd><dt><span class="term"><em class="parameter"><code>iterator</code></em></span></dt><dd><p>
     the iterator function to call, cannot sleep
    </p></dd><dt><span class="term"><em class="parameter"><code>data</code></em></span></dt><dd><p>
     first argument of the iterator function
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8728512"></a><h2>Description</h2><p>
   </p><p>

   This function iterates over the interfaces associated with a given
   hardware that are currently active and calls the callback for them.
   This function requires the iterator callback function to be atomic,
   if that is not desired, use <em class="parameter"><code>ieee80211_iterate_active_interfaces</code></em> instead.
   Does not iterate over a new interface during <code class="function">add_interface</code>.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;14.&nbsp;Station handling"><div class="titlepage"><div><div><h2 class="title"><a id="station-handling"></a>Chapter&nbsp;14.&nbsp;Station handling</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-sta"><span>struct ieee80211_sta</span></a></span><span class="refpurpose"> — 
  station table entry
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-sta-notify-cmd"><span>enum sta_notify_cmd</span></a></span><span class="refpurpose"> — 
  sta notify command
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta"><span>ieee80211_find_sta</span></a></span><span class="refpurpose"> — 
  find a station
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-find-sta-by-ifaddr"><span>ieee80211_find_sta_by_ifaddr</span></a></span><span class="refpurpose"> — 
  find a station on hardware
 </span></dt></dl></div><p>TODO</p><div class="refentry" title="struct ieee80211_sta"><a id="API-struct-ieee80211-sta"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_sta — 
  station table entry
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_sta {
  u32 supp_rates[IEEE80211_NUM_BANDS];
  u8 addr[ETH_ALEN];
  u16 aid;
  struct ieee80211_sta_ht_cap ht_cap;
  struct ieee80211_sta_vht_cap vht_cap;
  bool wme;
  u8 uapsd_queues;
  u8 max_sp;
  u8 rx_nss;
  enum ieee80211_sta_rx_bandwidth bandwidth;
  enum ieee80211_smps_mode smps_mode;
  struct ieee80211_sta_rates __rcu * rates;
  u8 drv_priv[0];
};  </pre></div><div class="refsect1" title="Members"><a id="idp8741264"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">supp_rates[IEEE80211_NUM_BANDS]</span></dt><dd><p>
Bitmap of supported rates (per band)
      </p></dd><dt><span class="term">addr[ETH_ALEN]</span></dt><dd><p>
MAC address
      </p></dd><dt><span class="term">aid</span></dt><dd><p>
AID we assigned to the station if we're an AP
      </p></dd><dt><span class="term">ht_cap</span></dt><dd><p>
HT capabilities of this STA; restricted to our own capabilities
      </p></dd><dt><span class="term">vht_cap</span></dt><dd><p>
VHT capabilities of this STA; restricted to our own capabilities
      </p></dd><dt><span class="term">wme</span></dt><dd><p>
indicates whether the STA supports WME. Only valid during AP-mode.
      </p></dd><dt><span class="term">uapsd_queues</span></dt><dd><p>
bitmap of queues configured for uapsd. Only valid
if wme is supported.
      </p></dd><dt><span class="term">max_sp</span></dt><dd><p>
max Service Period. Only valid if wme is supported.
      </p></dd><dt><span class="term">rx_nss</span></dt><dd><p>
in HT/VHT, the maximum number of spatial streams the
station can receive at the moment, changed by operating mode
notifications and capabilities. The value is only valid after
the station moves to associated state.
      </p></dd><dt><span class="term">bandwidth</span></dt><dd><p>
current bandwidth the station can receive with
      </p></dd><dt><span class="term">smps_mode</span></dt><dd><p>
current SMPS mode (off, static or dynamic)
      </p></dd><dt><span class="term">rates</span></dt><dd><p>
rate control selection table
      </p></dd><dt><span class="term">drv_priv[0]</span></dt><dd><p>
data area for driver use, will always be aligned to
sizeof(void *), size is determined in hw information.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8760608"></a><h2>Description</h2><p>
   </p><p>

   A station table entry represents a station we are possibly
   communicating with. Since stations are RCU-managed in
   mac80211, any ieee80211_sta pointer you get access to must
   either be protected by <code class="function">rcu_read_lock</code> explicitly or implicitly,
   or you must take good care to not use such a pointer after a
   call to your sta_remove callback that removed it.
</p></div></div><div class="refentry" title="enum sta_notify_cmd"><div class="refentry.separator"><hr></div><a id="API-enum-sta-notify-cmd"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum sta_notify_cmd — 
  sta notify command
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum sta_notify_cmd {
  STA_NOTIFY_SLEEP,
  STA_NOTIFY_AWAKE
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8770640"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">STA_NOTIFY_SLEEP</span></dt><dd><p>
a station is now sleeping
      </p></dd><dt><span class="term">STA_NOTIFY_AWAKE</span></dt><dd><p>
a sleeping station woke up
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8774544"></a><h2>Description</h2><p>
   </p><p>

   Used with the <code class="function">sta_notify</code> callback in <span class="structname">struct ieee80211_ops</span>, this
   indicates if an associated station made a power state transition.
</p></div></div><div class="refentry" title="ieee80211_find_sta"><div class="refentry.separator"><hr></div><a id="API-ieee80211-find-sta"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_find_sta — 
  find a station
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct ieee80211_sta * <strong>fsfuncieee80211_find_sta </strong>(</code></td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>const u8 * <var class="pdparam">addr</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8787376"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     virtual interface to look for station on
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     station's address
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp8792576"></a><h2>Return</h2><p>
   The station, if found. <code class="constant">NULL</code> otherwise.
</p></div><div class="refsect1" title="Note"><a id="idp8794256"></a><h2>Note</h2><p>
   This function must be called under RCU lock and the
   resulting pointer is only valid under RCU lock as well.
</p></div></div><div class="refentry" title="ieee80211_find_sta_by_ifaddr"><div class="refentry.separator"><hr></div><a id="API-ieee80211-find-sta-by-ifaddr"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_find_sta_by_ifaddr — 
  find a station on hardware
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">struct ieee80211_sta * <strong>fsfuncieee80211_find_sta_by_ifaddr </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">addr</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">localaddr</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>const u8 * <var class="pdparam">addr</var></code>;<br><code>const u8 * <var class="pdparam">localaddr</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8806768"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     pointer as obtained from <code class="function">ieee80211_alloc_hw</code>
    </p></dd><dt><span class="term"><em class="parameter"><code>addr</code></em></span></dt><dd><p>
     remote station's address
    </p></dd><dt><span class="term"><em class="parameter"><code>localaddr</code></em></span></dt><dd><p>
     local address (vif-&gt;sdata-&gt;vif.addr). Use NULL for 'any'.
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp8814800"></a><h2>Return</h2><p>
   The station, if found. <code class="constant">NULL</code> otherwise.
</p></div><div class="refsect1" title="Note"><a id="idp8816480"></a><h2>Note</h2><p>
   This function must be called under RCU lock and the
   resulting pointer is only valid under RCU lock as well.
</p></div><div class="refsect1" title="NOTE"><a id="idp8817792"></a><h2>NOTE</h2><p>
   You may pass NULL for localaddr, but then you will just get
   the first STA that matches the remote address 'addr'.
   We can have multiple STA associated with multiple
   logical stations (e.g. consider a station connecting to another
   BSSID on the same AP hardware without disconnecting first).
   In this case, the result of this method with localaddr NULL
   is not reliable.
   </p><p>

   DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;15.&nbsp;Hardware scan offload"><div class="titlepage"><div><div><h2 class="title"><a id="hardware-scan-offload"></a>Chapter&nbsp;15.&nbsp;Hardware scan offload</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-scan-completed"><span>ieee80211_scan_completed</span></a></span><span class="refpurpose"> — 
  completed hardware scan
 </span></dt></dl></div><p>TBD</p><div class="refentry" title="ieee80211_scan_completed"><a id="API-ieee80211-scan-completed"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_scan_completed — 
  completed hardware scan
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_scan_completed </strong>(</code></td><td><var class="pdparam">hw</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">aborted</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_hw * <var class="pdparam">hw</var></code>;<br><code>bool <var class="pdparam">aborted</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8831488"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>hw</code></em></span></dt><dd><p>
     the hardware that finished the scan
    </p></dd><dt><span class="term"><em class="parameter"><code>aborted</code></em></span></dt><dd><p>
     set to true if scan was aborted
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8836704"></a><h2>Description</h2><p>
   </p><p>

   When hardware scan offload is used (i.e. the <code class="function">hw_scan</code> callback is
   assigned) this function needs to be called by the driver to notify
   mac80211 that the scan finished. This function can be called from
   any context, including hardirq context.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;16.&nbsp;Aggregation"><div class="titlepage"><div><div><h2 class="title"><a id="aggregation"></a>Chapter&nbsp;16.&nbsp;Aggregation</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#idp8840448">TX A-MPDU aggregation</a></span></dt><dt><span class="sect1"><a href="#idp8851200">RX A-MPDU aggregation</a></span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-ampdu-mlme-action"><span>enum ieee80211_ampdu_mlme_action</span></a></span><span class="refpurpose"> — 
  A-MPDU actions
 </span></dt></dl></div><div class="sect1" title="TX A-MPDU aggregation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8840448"></a>TX A-MPDU aggregation</h2></div></div></div><p>
   </p><p>
   Aggregation on the TX side requires setting the hardware flag
   <code class="constant">IEEE80211_HW_AMPDU_AGGREGATION</code>. The driver will then be handed
   packets with a flag indicating A-MPDU aggregation. The driver
   or device is responsible for actually aggregating the frames,
   as well as deciding how many and which to aggregate.
   </p><p>
   When TX aggregation is started by some subsystem (usually the rate
   control algorithm would be appropriate) by calling the
   <code class="function">ieee80211_start_tx_ba_session</code> function, the driver will be
   notified via its <em class="parameter"><code>ampdu_action</code></em> function, with the
   <code class="constant">IEEE80211_AMPDU_TX_START</code> action.
   </p><p>
   In response to that, the driver is later required to call the
   <code class="function">ieee80211_start_tx_ba_cb_irqsafe</code> function, which will really
   start the aggregation session after the peer has also responded.
   If the peer responds negatively, the session will be stopped
   again right away. Note that it is possible for the aggregation
   session to be stopped before the driver has indicated that it
   is done setting it up, in which case it must not indicate the
   setup completion.
   </p><p>
   Also note that, since we also need to wait for a response from
   the peer, the driver is notified of the completion of the
   handshake by the <code class="constant">IEEE80211_AMPDU_TX_OPERATIONAL</code> action to the
   <em class="parameter"><code>ampdu_action</code></em> callback.
   </p><p>
   Similarly, when the aggregation session is stopped by the peer
   or something calling <code class="function">ieee80211_stop_tx_ba_session</code>, the driver's
   <em class="parameter"><code>ampdu_action</code></em> function will be called with the action
   <code class="constant">IEEE80211_AMPDU_TX_STOP</code>. In this case, the call must not fail,
   and the driver must later call <code class="function">ieee80211_stop_tx_ba_cb_irqsafe</code>.
   Note that the sta can get destroyed before the BA tear down is
   complete.
</p></div><div class="sect1" title="RX A-MPDU aggregation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8851200"></a>RX A-MPDU aggregation</h2></div></div></div><p>
   </p><p>
   Aggregation on the RX side requires only implementing the
   <em class="parameter"><code>ampdu_action</code></em> callback that is invoked to start/stop any
   block-ack sessions for RX aggregation.
   </p><p>
   When RX aggregation is started by the peer, the driver is
   notified via <em class="parameter"><code>ampdu_action</code></em> function, with the
   <code class="constant">IEEE80211_AMPDU_RX_START</code> action, and may reject the request
   in which case a negative response is sent to the peer, if it
   accepts it a positive response is sent.
   </p><p>
   While the session is active, the device/driver are required
   to de-aggregate frames and pass them up one by one to mac80211,
   which will handle the reorder buffer.
   </p><p>
   When the aggregation session is stopped again by the peer or
   ourselves, the driver's <em class="parameter"><code>ampdu_action</code></em> function will be called
   with the action <code class="constant">IEEE80211_AMPDU_RX_STOP</code>. In this case, the
   call must not fail.
</p></div><div class="refentry" title="enum ieee80211_ampdu_mlme_action"><a id="API-enum-ieee80211-ampdu-mlme-action"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_ampdu_mlme_action — 
  A-MPDU actions
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_ampdu_mlme_action {
  IEEE80211_AMPDU_RX_START,
  IEEE80211_AMPDU_RX_STOP,
  IEEE80211_AMPDU_TX_START,
  IEEE80211_AMPDU_TX_STOP_CONT,
  IEEE80211_AMPDU_TX_STOP_FLUSH,
  IEEE80211_AMPDU_TX_STOP_FLUSH_CONT,
  IEEE80211_AMPDU_TX_OPERATIONAL
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8864832"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_AMPDU_RX_START</span></dt><dd><p>
start RX aggregation
      </p></dd><dt><span class="term">IEEE80211_AMPDU_RX_STOP</span></dt><dd><p>
stop RX aggregation
      </p></dd><dt><span class="term">IEEE80211_AMPDU_TX_START</span></dt><dd><p>
start TX aggregation
      </p></dd><dt><span class="term">IEEE80211_AMPDU_TX_STOP_CONT</span></dt><dd><p>
stop TX aggregation but continue transmitting
queued packets, now unaggregated. After all packets are transmitted the
driver has to call <code class="function">ieee80211_stop_tx_ba_cb_irqsafe</code>.
      </p></dd><dt><span class="term">IEEE80211_AMPDU_TX_STOP_FLUSH</span></dt><dd><p>
stop TX aggregation and flush all packets,
called when the station is removed. There's no need or reason to call
<code class="function">ieee80211_stop_tx_ba_cb_irqsafe</code> in this case as mac80211 assumes the
session is gone and removes the station.
      </p></dd><dt><span class="term">IEEE80211_AMPDU_TX_STOP_FLUSH_CONT</span></dt><dd><p>
called when TX aggregation is stopped
but the driver hasn't called <code class="function">ieee80211_stop_tx_ba_cb_irqsafe</code> yet and
now the connection is dropped and the station will be removed. Drivers
should clean up and drop remaining packets when this is called.
      </p></dd><dt><span class="term">IEEE80211_AMPDU_TX_OPERATIONAL</span></dt><dd><p>
TX aggregation has become operational
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8878272"></a><h2>Description</h2><p>
   </p><p>

   These flags are used with the <code class="function">ampdu_action</code> callback in
   <span class="structname">struct ieee80211_ops</span> to indicate which action is needed.
   </p><p>

   Note that drivers MUST be able to deal with a TX aggregation
   session being stopped even before they OK'ed starting it by
   calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
   might receive the addBA frame and send a delBA right away!
</p></div></div></div><div class="chapter" title="Chapter&nbsp;17.&nbsp;Spatial Multiplexing Powersave (SMPS)"><div class="titlepage"><div><div><h2 class="title"><a id="smps"></a>Chapter&nbsp;17.&nbsp;Spatial Multiplexing Powersave (SMPS)</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-request-smps"><span>ieee80211_request_smps</span></a></span><span class="refpurpose"> — 
  request SM PS transition
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-smps-mode"><span>enum ieee80211_smps_mode</span></a></span><span class="refpurpose"> — 
  spatial multiplexing power save mode
 </span></dt></dl></div><p>
   </p><p>
   SMPS (Spatial multiplexing power save) is a mechanism to conserve
   power in an 802.11n implementation. For details on the mechanism
   and rationale, please refer to 802.11 (as amended by 802.11n-2009)
   <span class="quote">“<span class="quote">11.2.3 SM power save</span>”</span>.
   </p><p>
   The mac80211 implementation is capable of sending action frames
   to update the AP about the station's SMPS mode, and will instruct
   the driver to enter the specific mode. It will also announce the
   requested SMPS mode during the association handshake. Hardware
   support for this feature is required, and can be indicated by
   hardware flags.
   </p><p>
   The default mode will be <span class="quote">“<span class="quote">automatic</span>”</span>, which nl80211/cfg80211
   defines to be dynamic SMPS in (regular) powersave, and SMPS
   turned off otherwise.
   </p><p>
   To support this feature, the driver must set the appropriate
   hardware support flags, and handle the SMPS flag to the <code class="function">config</code>
   operation. It will then with this mechanism be instructed to
   enter the requested SMPS mode while associated to an HT AP.
</p><div class="refentry" title="ieee80211_request_smps"><a id="API-ieee80211-request-smps"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_request_smps — 
  request SM PS transition
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_request_smps </strong>(</code></td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">smps_mode</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>enum ieee80211_smps_mode <var class="pdparam">smps_mode</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8897056"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback.
    </p></dd><dt><span class="term"><em class="parameter"><code>smps_mode</code></em></span></dt><dd><p>
     new SM PS mode
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8902672"></a><h2>Description</h2><p>
   This allows the driver to request an SM PS transition in managed
   mode. This is useful when the driver has more information than
   the stack about possible interference, for example by bluetooth.
</p></div></div><div class="refentry" title="enum ieee80211_smps_mode"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-smps-mode"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_smps_mode — 
  spatial multiplexing power save mode
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_smps_mode {
  IEEE80211_SMPS_AUTOMATIC,
  IEEE80211_SMPS_OFF,
  IEEE80211_SMPS_STATIC,
  IEEE80211_SMPS_DYNAMIC,
  IEEE80211_SMPS_NUM_MODES
};  </pre></div><div class="refsect1" title="Constants"><a id="idp8911728"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_SMPS_AUTOMATIC</span></dt><dd><p>
automatic
      </p></dd><dt><span class="term">IEEE80211_SMPS_OFF</span></dt><dd><p>
off
      </p></dd><dt><span class="term">IEEE80211_SMPS_STATIC</span></dt><dd><p>
static
      </p></dd><dt><span class="term">IEEE80211_SMPS_DYNAMIC</span></dt><dd><p>
dynamic
      </p></dd><dt><span class="term">IEEE80211_SMPS_NUM_MODES</span></dt><dd><p>
internal, don't use
      </p></dd></dl></div></div></div></div></div><div class="part" title="Part&nbsp;III.&nbsp;Rate control interface"><div class="titlepage"><div><div><h1 class="title"><a id="rate-control"></a>Part&nbsp;III.&nbsp;Rate control interface</h1></div></div></div><div class="partintro" title="Rate control interface"><div></div><p>TBD</p><p>
         This part of the book describes the rate control algorithm
         interface and how it relates to mac80211 and drivers.
        </p><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#ratecontrol-api">18. Rate Control API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-session"><span>ieee80211_start_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Start a tx Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-cb-irqsafe"><span>ieee80211_start_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-session"><span>ieee80211_stop_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Stop a Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-cb-irqsafe"><span>ieee80211_stop_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to stop aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-rate-control-changed"><span>enum ieee80211_rate_control_changed</span></a></span><span class="refpurpose"> — 
  flags to indicate what changed
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-rate-control"><span>struct ieee80211_tx_rate_control</span></a></span><span class="refpurpose"> — 
  rate control information for/from RC algo
 </span></dt><dt><span class="refentrytitle"><a href="#API-rate-control-send-low"><span>rate_control_send_low</span></a></span><span class="refpurpose"> — 
  helper for drivers for management/no-ack frames
 </span></dt></dl></dd></dl></div></div><div class="chapter" title="Chapter&nbsp;18.&nbsp;Rate Control API"><div class="titlepage"><div><div><h2 class="title"><a id="ratecontrol-api"></a>Chapter&nbsp;18.&nbsp;Rate Control API</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-session"><span>ieee80211_start_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Start a tx Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-start-tx-ba-cb-irqsafe"><span>ieee80211_start_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-session"><span>ieee80211_stop_tx_ba_session</span></a></span><span class="refpurpose"> — 
  Stop a Block Ack session.
 </span></dt><dt><span class="refentrytitle"><a href="#API-ieee80211-stop-tx-ba-cb-irqsafe"><span>ieee80211_stop_tx_ba_cb_irqsafe</span></a></span><span class="refpurpose"> — 
  low level driver ready to stop aggregate.
 </span></dt><dt><span class="refentrytitle"><a href="#API-enum-ieee80211-rate-control-changed"><span>enum ieee80211_rate_control_changed</span></a></span><span class="refpurpose"> — 
  flags to indicate what changed
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-ieee80211-tx-rate-control"><span>struct ieee80211_tx_rate_control</span></a></span><span class="refpurpose"> — 
  rate control information for/from RC algo
 </span></dt><dt><span class="refentrytitle"><a href="#API-rate-control-send-low"><span>rate_control_send_low</span></a></span><span class="refpurpose"> — 
  helper for drivers for management/no-ack frames
 </span></dt></dl></div><p>TBD</p><div class="refentry" title="ieee80211_start_tx_ba_session"><a id="API-ieee80211-start-tx-ba-session"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_start_tx_ba_session — 
  Start a tx Block Ack session.
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_start_tx_ba_session </strong>(</code></td><td><var class="pdparam">sta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">timeout</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_sta * <var class="pdparam">sta</var></code>;<br><code>u16 <var class="pdparam">tid</var></code>;<br><code>u16 <var class="pdparam">timeout</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8935056"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>sta</code></em></span></dt><dd><p>
     the station for which to start a BA session
    </p></dd><dt><span class="term"><em class="parameter"><code>tid</code></em></span></dt><dd><p>
     the TID to BA on.
    </p></dd><dt><span class="term"><em class="parameter"><code>timeout</code></em></span></dt><dd><p>
     session timeout value (in TUs)
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp8942256"></a><h2>Return</h2><p>
   success if addBA request was sent, failure otherwise
   </p><p>

   Although mac80211/low level driver/user space application can estimate
   the need to start aggregation on a certain RA/TID, the session level
   will be managed by the mac80211.
</p></div></div><div class="refentry" title="ieee80211_start_tx_ba_cb_irqsafe"><div class="refentry.separator"><hr></div><a id="API-ieee80211-start-tx-ba-cb-irqsafe"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_start_tx_ba_cb_irqsafe — 
  low level driver ready to aggregate.
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_start_tx_ba_cb_irqsafe </strong>(</code></td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ra</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>const u8 * <var class="pdparam">ra</var></code>;<br><code>u16 <var class="pdparam">tid</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8955088"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback
    </p></dd><dt><span class="term"><em class="parameter"><code>ra</code></em></span></dt><dd><p>
     receiver address of the BA session recipient.
    </p></dd><dt><span class="term"><em class="parameter"><code>tid</code></em></span></dt><dd><p>
     the TID to BA on.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8962688"></a><h2>Description</h2><p>
   This function must be called by low level driver once it has
   finished with preparations for the BA session. It can be called
   from any context.
</p></div></div><div class="refentry" title="ieee80211_stop_tx_ba_session"><div class="refentry.separator"><hr></div><a id="API-ieee80211-stop-tx-ba-session"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_stop_tx_ba_session — 
  Stop a Block Ack session.
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">int <strong>fsfuncieee80211_stop_tx_ba_session </strong>(</code></td><td><var class="pdparam">sta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_sta * <var class="pdparam">sta</var></code>;<br><code>u16 <var class="pdparam">tid</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8974256"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>sta</code></em></span></dt><dd><p>
     the station whose BA session to stop
    </p></dd><dt><span class="term"><em class="parameter"><code>tid</code></em></span></dt><dd><p>
     the TID to stop BA.
    </p></dd></dl></div></div><div class="refsect1" title="Return"><a id="idp8979424"></a><h2>Return</h2><p>
   negative error if the TID is invalid, or no aggregation active
   </p><p>

   Although mac80211/low level driver/user space application can estimate
   the need to stop aggregation on a certain RA/TID, the session level
   will be managed by the mac80211.
</p></div></div><div class="refentry" title="ieee80211_stop_tx_ba_cb_irqsafe"><div class="refentry.separator"><hr></div><a id="API-ieee80211-stop-tx-ba-cb-irqsafe"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>ieee80211_stop_tx_ba_cb_irqsafe — 
  low level driver ready to stop aggregate.
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">void <strong>fsfuncieee80211_stop_tx_ba_cb_irqsafe </strong>(</code></td><td><var class="pdparam">vif</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">ra</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_vif * <var class="pdparam">vif</var></code>;<br><code>const u8 * <var class="pdparam">ra</var></code>;<br><code>u16 <var class="pdparam">tid</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp8992352"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>vif</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_vif</span> pointer from the add_interface callback
    </p></dd><dt><span class="term"><em class="parameter"><code>ra</code></em></span></dt><dd><p>
     receiver address of the BA session recipient.
    </p></dd><dt><span class="term"><em class="parameter"><code>tid</code></em></span></dt><dd><p>
     the desired TID to BA on.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp8999952"></a><h2>Description</h2><p>
   This function must be called by low level driver once it has
   finished with preparations for the BA session tear down. It
   can be called from any context.
</p></div></div><div class="refentry" title="enum ieee80211_rate_control_changed"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-rate-control-changed"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_rate_control_changed — 
  flags to indicate what changed
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_rate_control_changed {
  IEEE80211_RC_BW_CHANGED,
  IEEE80211_RC_SMPS_CHANGED,
  IEEE80211_RC_SUPP_RATES_CHANGED,
  IEEE80211_RC_NSS_CHANGED
};  </pre></div><div class="refsect1" title="Constants"><a id="idp9008896"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">IEEE80211_RC_BW_CHANGED</span></dt><dd><p>
The bandwidth that can be used to transmit
to this station changed. The actual bandwidth is in the station
information -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40
flag changes, for HT and VHT the bandwidth field changes.
      </p></dd><dt><span class="term">IEEE80211_RC_SMPS_CHANGED</span></dt><dd><p>
The SMPS state of the station changed.
      </p></dd><dt><span class="term">IEEE80211_RC_SUPP_RATES_CHANGED</span></dt><dd><p>
The supported rate set of this peer
changed (in IBSS mode) due to discovering more information about
the peer.
      </p></dd><dt><span class="term">IEEE80211_RC_NSS_CHANGED</span></dt><dd><p>
N_SS (number of spatial streams) was changed
by the peer
      </p></dd></dl></div></div></div><div class="refentry" title="struct ieee80211_tx_rate_control"><div class="refentry.separator"><hr></div><a id="API-struct-ieee80211-tx-rate-control"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct ieee80211_tx_rate_control — 
  rate control information for/from RC algo
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct ieee80211_tx_rate_control {
  struct ieee80211_hw * hw;
  struct ieee80211_supported_band * sband;
  struct ieee80211_bss_conf * bss_conf;
  struct sk_buff * skb;
  struct ieee80211_tx_rate reported_rate;
  bool rts;
  bool short_preamble;
  u8 max_rate_idx;
  u32 rate_idx_mask;
  u8 * rate_idx_mcs_mask;
  bool bss;
};  </pre></div><div class="refsect1" title="Members"><a id="idp9023728"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">hw</span></dt><dd><p>
The hardware the algorithm is invoked for.
      </p></dd><dt><span class="term">sband</span></dt><dd><p>
The band this frame is being transmitted on.
      </p></dd><dt><span class="term">bss_conf</span></dt><dd><p>
the current BSS configuration
      </p></dd><dt><span class="term">skb</span></dt><dd><p>
the skb that will be transmitted, the control information in it needs
to be filled in
      </p></dd><dt><span class="term">reported_rate</span></dt><dd><p>
The rate control algorithm can fill this in to indicate
which rate should be reported to userspace as the current rate and
used for rate calculations in the mesh network.
      </p></dd><dt><span class="term">rts</span></dt><dd><p>
whether RTS will be used for this frame because it is longer than the
RTS threshold
      </p></dd><dt><span class="term">short_preamble</span></dt><dd><p>
whether mac80211 will request short-preamble transmission
if the selected rate supports it
      </p></dd><dt><span class="term">max_rate_idx</span></dt><dd><p>
user-requested maximum (legacy) rate
(deprecated; this will be removed once drivers get updated to use
rate_idx_mask)
      </p></dd><dt><span class="term">rate_idx_mask</span></dt><dd><p>
user-requested (legacy) rate mask
      </p></dd><dt><span class="term">rate_idx_mcs_mask</span></dt><dd><p>
user-requested MCS rate mask (NULL if not in use)
      </p></dd><dt><span class="term">bss</span></dt><dd><p>
whether this frame is sent out in AP or IBSS mode
      </p></dd></dl></div></div></div><div class="refentry" title="rate_control_send_low"><div class="refentry.separator"><hr></div><a id="API-rate-control-send-low"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>rate_control_send_low — 
  helper for drivers for management/no-ack frames
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table summary="Function synopsis" class="funcprototype-table" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td><code class="funcdef">bool <strong>fsfuncrate_control_send_low </strong>(</code></td><td><var class="pdparam">sta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">priv_sta</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">txrc</var><code>)</code>;</td><td>&nbsp;</td></tr></tbody></table><div class="paramdef-list"><code>struct ieee80211_sta * <var class="pdparam">sta</var></code>;<br><code>void * <var class="pdparam">priv_sta</var></code>;<br><code>struct ieee80211_tx_rate_control * <var class="pdparam">txrc</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1" title="Arguments"><a id="idp9051488"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>sta</code></em></span></dt><dd><p>
     <span class="structname">struct ieee80211_sta</span> pointer to the target destination. Note
     that this may be null.
    </p></dd><dt><span class="term"><em class="parameter"><code>priv_sta</code></em></span></dt><dd><p>
     private rate control structure. This may be null.
    </p></dd><dt><span class="term"><em class="parameter"><code>txrc</code></em></span></dt><dd><p>
     rate control information we sholud populate for mac80211.
    </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp9059216"></a><h2>Description</h2><p>
   </p><p>

   Rate control algorithms that agree to use the lowest rate to
   send management frames and NO_ACK data with the respective hw
   retries should use this in the beginning of their mac80211 get_rate
   callback. If true is returned the rate control can simply return.
   If false is returned we guarantee that sta and sta and priv_sta is
   not null.
   </p><p>

   Rate control algorithms wishing to do more intelligent selection of
   rate for multicast/broadcast frames may choose to not use this.
</p></div></div></div></div><div class="part" title="Part&nbsp;IV.&nbsp;Internals"><div class="titlepage"><div><div><h1 class="title"><a id="internal"></a>Part&nbsp;IV.&nbsp;Internals</h1></div></div></div><div class="partintro" title="Internals"><div></div><p>TBD</p><p>
         This part of the book describes mac80211 internals.
        </p><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#key-handling">19. Key handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9065360">Key handling basics</a></span></dt><dt><span class="sect1"><a href="#idp9069264">MORE TBD</a></span></dt></dl></dd><dt><span class="chapter"><a href="#rx-processing">20. Receive processing</a></span></dt><dt><span class="chapter"><a href="#tx-processing">21. Transmit processing</a></span></dt><dt><span class="chapter"><a href="#sta-info">22. Station info handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9074928">Programming information</a></span></dt><dt><span class="sect1"><a href="#idp9223600">STA information lifetime rules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#aggregation-internals">23. Aggregation</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#API-struct-sta-ampdu-mlme"><span>struct sta_ampdu_mlme</span></a></span><span class="refpurpose"> — 
  STA aggregation information.
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-tx"><span>struct tid_ampdu_tx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Tx).
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-rx"><span>struct tid_ampdu_rx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Rx).
 </span></dt></dl></dd><dt><span class="chapter"><a href="#synchronisation">24. Synchronisation</a></span></dt></dl></div></div><div class="chapter" title="Chapter&nbsp;19.&nbsp;Key handling"><div class="titlepage"><div><div><h2 class="title"><a id="key-handling"></a>Chapter&nbsp;19.&nbsp;Key handling</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#idp9065360">Key handling basics</a></span></dt><dt><span class="sect1"><a href="#idp9069264">MORE TBD</a></span></dt></dl></div><div class="sect1" title="Key handling basics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9065360"></a>Key handling basics</h2></div></div></div><p>
   </p><p>
   Key handling in mac80211 is done based on per-interface (sub_if_data)
   keys and per-station keys. Since each station belongs to an interface,
   each station key also belongs to that interface.
   </p><p>
   Hardware acceleration is done on a best-effort basis for algorithms
   that are implemented in software,  for each key the hardware is asked
   to enable that key for offloading but if it cannot do that the key is
   simply kept for software encryption (unless it is for an algorithm
   that isn't implemented in software).
   There is currently no way of knowing whether a key is handled in SW
   or HW except by looking into debugfs.
   </p><p>
   All key management is internally protected by a mutex. Within all
   other parts of mac80211, key references are, just as STA structure
   references, protected by RCU. Note, however, that some things are
   unprotected, namely the key-&gt;sta dereferences within the hardware
   acceleration functions. This means that <code class="function">sta_info_destroy</code> must
   remove the key which waits for an RCU grace period.
</p></div><div class="sect1" title="MORE TBD"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9069264"></a>MORE TBD</h2></div></div></div><p>TBD</p></div></div><div class="chapter" title="Chapter&nbsp;20.&nbsp;Receive processing"><div class="titlepage"><div><div><h2 class="title"><a id="rx-processing"></a>Chapter&nbsp;20.&nbsp;Receive processing</h2></div></div></div><p>TBD</p></div><div class="chapter" title="Chapter&nbsp;21.&nbsp;Transmit processing"><div class="titlepage"><div><div><h2 class="title"><a id="tx-processing"></a>Chapter&nbsp;21.&nbsp;Transmit processing</h2></div></div></div><p>TBD</p></div><div class="chapter" title="Chapter&nbsp;22.&nbsp;Station info handling"><div class="titlepage"><div><div><h2 class="title"><a id="sta-info"></a>Chapter&nbsp;22.&nbsp;Station info handling</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="sect1"><a href="#idp9074928">Programming information</a></span></dt><dt><span class="sect1"><a href="#idp9223600">STA information lifetime rules</a></span></dt></dl></div><div class="sect1" title="Programming information"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9074928"></a>Programming information</h2></div></div></div><div class="refentry" title="struct sta_info"><a id="API-struct-sta-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct sta_info — 
  STA information
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct sta_info {
  struct list_head list;
  struct rcu_head rcu_head;
  struct sta_info __rcu * hnext;
  struct ieee80211_local * local;
  struct ieee80211_sub_if_data * sdata;
  struct ieee80211_key __rcu * gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS];
  struct ieee80211_key __rcu * ptk;
  struct rate_control_ref * rate_ctrl;
  void * rate_ctrl_priv;
  spinlock_t lock;
  struct work_struct drv_unblock_wk;
  u16 listen_interval;
  bool dead;
  bool uploaded;
  enum ieee80211_sta_state sta_state;
  unsigned long _flags;
  struct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];
  struct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];
  unsigned long driver_buffered_tids;
  unsigned long rx_packets;
  u64 rx_bytes;
  unsigned long wep_weak_iv_count;
  unsigned long last_rx;
  long last_connected;
  unsigned long num_duplicates;
  unsigned long rx_fragments;
  unsigned long rx_dropped;
  int last_signal;
  struct ewma avg_signal;
  int last_ack_signal;
  u8 chains;
  s8 chain_signal_last[IEEE80211_MAX_CHAINS];
  struct ewma chain_signal_avg[IEEE80211_MAX_CHAINS];
  __le16 last_seq_ctrl[IEEE80211_NUM_TIDS + 1];
  unsigned long tx_filtered_count;
  unsigned long tx_retry_failed;
  unsigned long tx_retry_count;
  unsigned int fail_avg;
  u32 tx_fragments;
  u64 tx_packets[IEEE80211_NUM_ACS];
  u64 tx_bytes[IEEE80211_NUM_ACS];
  struct ieee80211_tx_rate last_tx_rate;
  int last_rx_rate_idx;
  u32 last_rx_rate_flag;
  u8 last_rx_rate_vht_nss;
  u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
  struct sta_ampdu_mlme ampdu_mlme;
  u8 timer_to_tid[IEEE80211_NUM_TIDS];
#ifdef CONFIG_MAC80211_MESH
  __le16 llid;
  __le16 plid;
  __le16 reason;
  u8 plink_retries;
  bool ignore_plink_timer;
  enum nl80211_plink_state plink_state;
  u32 plink_timeout;
  struct timer_list plink_timer;
  s64 t_offset;
  s64 t_offset_setpoint;
  enum nl80211_mesh_power_mode local_pm;
  enum nl80211_mesh_power_mode peer_pm;
  enum nl80211_mesh_power_mode nonpeer_pm;
#endif
#ifdef CONFIG_MAC80211_DEBUGFS
  struct sta_info_debugfsdentries debugfs;
#endif
  enum ieee80211_sta_rx_bandwidth cur_max_bandwidth;
  unsigned int lost_packets;
  unsigned int beacon_loss_count;
  struct ieee80211_sta sta;
};  </pre></div><div class="refsect1" title="Members"><a id="idp9085120"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">list</span></dt><dd><p>
global linked list entry
      </p></dd><dt><span class="term">rcu_head</span></dt><dd><p>
RCU head used for freeing this station struct
      </p></dd><dt><span class="term">hnext</span></dt><dd><p>
hash table linked list pointer
      </p></dd><dt><span class="term">local</span></dt><dd><p>
pointer to the global information
      </p></dd><dt><span class="term">sdata</span></dt><dd><p>
virtual interface this station belongs to
      </p></dd><dt><span class="term">gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS]</span></dt><dd><p>
group keys negotiated with this station, if any
      </p></dd><dt><span class="term">ptk</span></dt><dd><p>
peer key negotiated with this station, if any
      </p></dd><dt><span class="term">rate_ctrl</span></dt><dd><p>
rate control algorithm reference
      </p></dd><dt><span class="term">rate_ctrl_priv</span></dt><dd><p>
rate control private per-STA pointer
      </p></dd><dt><span class="term">lock</span></dt><dd><p>
used for locking all fields that require locking, see comments
in the header file.
      </p></dd><dt><span class="term">drv_unblock_wk</span></dt><dd><p>
used for driver PS unblocking
      </p></dd><dt><span class="term">listen_interval</span></dt><dd><p>
listen interval of this station, when we're acting as AP
      </p></dd><dt><span class="term">dead</span></dt><dd><p>
set to true when sta is unlinked
      </p></dd><dt><span class="term">uploaded</span></dt><dd><p>
set to true when sta is uploaded to the driver
      </p></dd><dt><span class="term">sta_state</span></dt><dd><p>
duplicates information about station state (for debug)
      </p></dd><dt><span class="term">_flags</span></dt><dd><p>
STA flags, see <span class="structname">enum</span> ieee80211_sta_info_flags, do not use directly
      </p></dd><dt><span class="term">ps_tx_buf[IEEE80211_NUM_ACS]</span></dt><dd><p>
buffers (per AC) of frames to transmit to this station
when it leaves power saving state or polls
      </p></dd><dt><span class="term">tx_filtered[IEEE80211_NUM_ACS]</span></dt><dd><p>
buffers (per AC) of frames we already tried to
transmit but were filtered by hardware due to STA having
entered power saving state, these are also delivered to
the station when it leaves powersave or polls for frames
      </p></dd><dt><span class="term">driver_buffered_tids</span></dt><dd><p>
bitmap of TIDs the driver has data buffered on
      </p></dd><dt><span class="term">rx_packets</span></dt><dd><p>
Number of MSDUs received from this STA
      </p></dd><dt><span class="term">rx_bytes</span></dt><dd><p>
Number of bytes received from this STA
      </p></dd><dt><span class="term">wep_weak_iv_count</span></dt><dd><p>
number of weak WEP IVs received from this station
      </p></dd><dt><span class="term">last_rx</span></dt><dd><p>
time (in jiffies) when last frame was received from this STA
      </p></dd><dt><span class="term">last_connected</span></dt><dd><p>
time (in seconds) when a station got connected
      </p></dd><dt><span class="term">num_duplicates</span></dt><dd><p>
number of duplicate frames received from this STA
      </p></dd><dt><span class="term">rx_fragments</span></dt><dd><p>
number of received MPDUs
      </p></dd><dt><span class="term">rx_dropped</span></dt><dd><p>
number of dropped MPDUs from this STA
      </p></dd><dt><span class="term">last_signal</span></dt><dd><p>
signal of last received frame from this STA
      </p></dd><dt><span class="term">avg_signal</span></dt><dd><p>
moving average of signal of received frames from this STA
      </p></dd><dt><span class="term">last_ack_signal</span></dt><dd><p>
signal of last received Ack frame from this STA
      </p></dd><dt><span class="term">chains</span></dt><dd><p>
chains ever used for RX from this station
      </p></dd><dt><span class="term">chain_signal_last[IEEE80211_MAX_CHAINS]</span></dt><dd><p>
last signal (per chain)
      </p></dd><dt><span class="term">chain_signal_avg[IEEE80211_MAX_CHAINS]</span></dt><dd><p>
signal average (per chain)
      </p></dd><dt><span class="term">last_seq_ctrl[IEEE80211_NUM_TIDS + 1]</span></dt><dd><p>
last received seq/frag number from this STA (per RX queue)
      </p></dd><dt><span class="term">tx_filtered_count</span></dt><dd><p>
number of frames the hardware filtered for this STA
      </p></dd><dt><span class="term">tx_retry_failed</span></dt><dd><p>
number of frames that failed retry
      </p></dd><dt><span class="term">tx_retry_count</span></dt><dd><p>
total number of retries for frames to this STA
      </p></dd><dt><span class="term">fail_avg</span></dt><dd><p>
moving percentage of failed MSDUs
      </p></dd><dt><span class="term">tx_fragments</span></dt><dd><p>
number of transmitted MPDUs
      </p></dd><dt><span class="term">tx_packets[IEEE80211_NUM_ACS]</span></dt><dd><p>
number of RX/TX MSDUs
      </p></dd><dt><span class="term">tx_bytes[IEEE80211_NUM_ACS]</span></dt><dd><p>
number of bytes transmitted to this STA
      </p></dd><dt><span class="term">last_tx_rate</span></dt><dd><p>
rate used for last transmit, to report to userspace as
<span class="quote">“<span class="quote">the</span>”</span> transmit rate
      </p></dd><dt><span class="term">last_rx_rate_idx</span></dt><dd><p>
rx status rate index of the last data packet
      </p></dd><dt><span class="term">last_rx_rate_flag</span></dt><dd><p>
rx status flag of the last data packet
      </p></dd><dt><span class="term">last_rx_rate_vht_nss</span></dt><dd><p>
rx status nss of last data packet
      </p></dd><dt><span class="term">tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1]</span></dt><dd><p>
per-TID sequence numbers for sending to this STA
      </p></dd><dt><span class="term">ampdu_mlme</span></dt><dd><p>
A-MPDU state machine state
      </p></dd><dt><span class="term">timer_to_tid[IEEE80211_NUM_TIDS]</span></dt><dd><p>
identity mapping to ID timers
      </p></dd><dt><span class="term">llid</span></dt><dd><p>
Local link ID
      </p></dd><dt><span class="term">plid</span></dt><dd><p>
Peer link ID
      </p></dd><dt><span class="term">reason</span></dt><dd><p>
Cancel reason on PLINK_HOLDING state
      </p></dd><dt><span class="term">plink_retries</span></dt><dd><p>
Retries in establishment
      </p></dd><dt><span class="term">ignore_plink_timer</span></dt><dd><p>
ignore the peer-link timer (used internally)
      </p></dd><dt><span class="term">plink_state</span></dt><dd><p>
peer link state
      </p></dd><dt><span class="term">plink_timeout</span></dt><dd><p>
timeout of peer link
      </p></dd><dt><span class="term">plink_timer</span></dt><dd><p>
peer link watch timer
      </p></dd><dt><span class="term">t_offset</span></dt><dd><p>
timing offset relative to this host
      </p></dd><dt><span class="term">t_offset_setpoint</span></dt><dd><p>
reference timing offset of this sta to be used when
calculating clockdrift
      </p></dd><dt><span class="term">local_pm</span></dt><dd><p>
local link-specific power save mode
      </p></dd><dt><span class="term">peer_pm</span></dt><dd><p>
peer-specific power save mode towards local STA
      </p></dd><dt><span class="term">nonpeer_pm</span></dt><dd><p>
STA power save mode towards non-peer neighbors
      </p></dd><dt><span class="term">debugfs</span></dt><dd><p>
debug filesystem info
      </p></dd><dt><span class="term">cur_max_bandwidth</span></dt><dd><p>
maximum bandwidth to use for TX to the station,
taken from HT/VHT capabilities or VHT operating mode notification
      </p></dd><dt><span class="term">lost_packets</span></dt><dd><p>
number of consecutive lost packets
      </p></dd><dt><span class="term">beacon_loss_count</span></dt><dd><p>
number of times beacon loss has triggered
      </p></dd><dt><span class="term">sta</span></dt><dd><p>
station information we share with the driver
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp9178384"></a><h2>Description</h2><p>
   </p><p>

   This structure collects information about a station that
   mac80211 is communicating with.
</p></div></div><div class="refentry" title="enum ieee80211_sta_info_flags"><div class="refentry.separator"><hr></div><a id="API-enum-ieee80211-sta-info-flags"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>enum ieee80211_sta_info_flags — 
  Stations flags
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">enum ieee80211_sta_info_flags {
  WLAN_STA_AUTH,
  WLAN_STA_ASSOC,
  WLAN_STA_PS_STA,
  WLAN_STA_AUTHORIZED,
  WLAN_STA_SHORT_PREAMBLE,
  WLAN_STA_WME,
  WLAN_STA_WDS,
  WLAN_STA_CLEAR_PS_FILT,
  WLAN_STA_MFP,
  WLAN_STA_BLOCK_BA,
  WLAN_STA_PS_DRIVER,
  WLAN_STA_PSPOLL,
  WLAN_STA_TDLS_PEER,
  WLAN_STA_TDLS_PEER_AUTH,
  WLAN_STA_UAPSD,
  WLAN_STA_SP,
  WLAN_STA_4ADDR_EVENT,
  WLAN_STA_INSERTED,
  WLAN_STA_RATE_CONTROL,
  WLAN_STA_TOFFSET_KNOWN,
  WLAN_STA_MPSP_OWNER,
  WLAN_STA_MPSP_RECIPIENT
};  </pre></div><div class="refsect1" title="Constants"><a id="idp9187920"></a><h2>Constants</h2><div class="variablelist"><dl><dt><span class="term">WLAN_STA_AUTH</span></dt><dd><p>
Station is authenticated.
      </p></dd><dt><span class="term">WLAN_STA_ASSOC</span></dt><dd><p>
Station is associated.
      </p></dd><dt><span class="term">WLAN_STA_PS_STA</span></dt><dd><p>
Station is in power-save mode
      </p></dd><dt><span class="term">WLAN_STA_AUTHORIZED</span></dt><dd><p>
Station is authorized to send/receive traffic.
This bit is always checked so needs to be enabled for all stations
when virtual port control is not in use.
      </p></dd><dt><span class="term">WLAN_STA_SHORT_PREAMBLE</span></dt><dd><p>
Station is capable of receiving short-preamble
frames.
      </p></dd><dt><span class="term">WLAN_STA_WME</span></dt><dd><p>
Station is a QoS-STA.
      </p></dd><dt><span class="term">WLAN_STA_WDS</span></dt><dd><p>
Station is one of our WDS peers.
      </p></dd><dt><span class="term">WLAN_STA_CLEAR_PS_FILT</span></dt><dd><p>
Clear PS filter in hardware (using the
IEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next
frame to this station is transmitted.
      </p></dd><dt><span class="term">WLAN_STA_MFP</span></dt><dd><p>
Management frame protection is used with this STA.
      </p></dd><dt><span class="term">WLAN_STA_BLOCK_BA</span></dt><dd><p>
Used to deny ADDBA requests (both TX and RX)
during suspend/resume and station removal.
      </p></dd><dt><span class="term">WLAN_STA_PS_DRIVER</span></dt><dd><p>
driver requires keeping this station in
power-save mode logically to flush frames that might still
be in the queues
      </p></dd><dt><span class="term">WLAN_STA_PSPOLL</span></dt><dd><p>
Station sent PS-poll while driver was keeping
station in power-save mode, reply when the driver unblocks.
      </p></dd><dt><span class="term">WLAN_STA_TDLS_PEER</span></dt><dd><p>
Station is a TDLS peer.
      </p></dd><dt><span class="term">WLAN_STA_TDLS_PEER_AUTH</span></dt><dd><p>
This TDLS peer is authorized to send direct
packets. This means the link is enabled.
      </p></dd><dt><span class="term">WLAN_STA_UAPSD</span></dt><dd><p>
Station requested unscheduled SP while driver was
keeping station in power-save mode, reply when the driver
unblocks the station.
      </p></dd><dt><span class="term">WLAN_STA_SP</span></dt><dd><p>
Station is in a service period, so don't try to
reply to other uAPSD trigger frames or PS-Poll.
      </p></dd><dt><span class="term">WLAN_STA_4ADDR_EVENT</span></dt><dd><p>
4-addr event was already sent for this frame.
      </p></dd><dt><span class="term">WLAN_STA_INSERTED</span></dt><dd><p>
This station is inserted into the hash table.
      </p></dd><dt><span class="term">WLAN_STA_RATE_CONTROL</span></dt><dd><p>
rate control was initialized for this station.
      </p></dd><dt><span class="term">WLAN_STA_TOFFSET_KNOWN</span></dt><dd><p>
toffset calculated for this station is valid.
      </p></dd><dt><span class="term">WLAN_STA_MPSP_OWNER</span></dt><dd><p>
local STA is owner of a mesh Peer Service Period.
      </p></dd><dt><span class="term">WLAN_STA_MPSP_RECIPIENT</span></dt><dd><p>
local STA is recipient of a MPSP.
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp9219936"></a><h2>Description</h2><p>
   </p><p>

   These flags are used with <span class="structname">struct sta_info</span>'s <em class="parameter"><code>flags</code></em> member, but
   only indirectly with <code class="function">set_sta_flag</code> and friends.
</p></div></div></div><div class="sect1" title="STA information lifetime rules"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9223600"></a>STA information lifetime rules</h2></div></div></div><p>
   </p><p>
   STA info structures (<span class="structname">struct sta_info</span>) are managed in a hash table
   for faster lookup and a list for iteration. They are managed using
   RCU, i.e. access to the list and hash table is protected by RCU.
   </p><p>
   Upon allocating a STA info structure with <code class="function">sta_info_alloc</code>, the caller
   owns that structure. It must then insert it into the hash table using
   either <code class="function">sta_info_insert</code> or <code class="function">sta_info_insert_rcu</code>; only in the latter
   case (which acquires an rcu read section but must not be called from
   within one) will the pointer still be valid after the call. Note that
   the caller may not do much with the STA info before inserting it, in
   particular, it may not start any mesh peer link management or add
   encryption keys.
   </p><p>
   When the insertion fails (<code class="function">sta_info_insert</code>) returns non-zero), the
   structure will have been freed by <code class="function">sta_info_insert</code>!
   </p><p>
   Station entries are added by mac80211 when you establish a link with a
   peer. This means different things for the different type of interfaces
   we support. For a regular station this mean we add the AP sta when we
   receive an association response from the AP. For IBSS this occurs when
   get to know about a peer on the same IBSS. For WDS we add the sta for
   the peer immediately upon device open. When using AP mode we add stations
   for each respective station upon request from userspace through nl80211.
   </p><p>
   In order to remove a STA info structure, various sta_info_destroy_*()
   calls are available.
   </p><p>
   There is no concept of ownership on a STA entry, each structure is
   owned by the global hash table/list until it is removed. All users of
   the structure need to be RCU protected so that the structure won't be
   freed before they are done using it.
</p></div></div><div class="chapter" title="Chapter&nbsp;23.&nbsp;Aggregation"><div class="titlepage"><div><div><h2 class="title"><a id="aggregation-internals"></a>Chapter&nbsp;23.&nbsp;Aggregation</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="refentrytitle"><a href="#API-struct-sta-ampdu-mlme"><span>struct sta_ampdu_mlme</span></a></span><span class="refpurpose"> — 
  STA aggregation information.
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-tx"><span>struct tid_ampdu_tx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Tx).
 </span></dt><dt><span class="refentrytitle"><a href="#API-struct-tid-ampdu-rx"><span>struct tid_ampdu_rx</span></a></span><span class="refpurpose"> — 
  TID aggregation information (Rx).
 </span></dt></dl></div><div class="refentry" title="struct sta_ampdu_mlme"><a id="API-struct-sta-ampdu-mlme"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct sta_ampdu_mlme — 
  STA aggregation information.
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct sta_ampdu_mlme {
  struct mutex mtx;
  struct tid_ampdu_rx __rcu * tid_rx[IEEE80211_NUM_TIDS];
  unsigned long tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
  unsigned long tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
  struct work_struct work;
  struct tid_ampdu_tx __rcu * tid_tx[IEEE80211_NUM_TIDS];
  struct tid_ampdu_tx * tid_start_tx[IEEE80211_NUM_TIDS];
  unsigned long last_addba_req_time[IEEE80211_NUM_TIDS];
  u8 addba_req_num[IEEE80211_NUM_TIDS];
  u8 dialog_token_allocator;
};  </pre></div><div class="refsect1" title="Members"><a id="idp9241088"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">mtx</span></dt><dd><p>
mutex to protect all TX data (except non-NULL assignments
to tid_tx[idx], which are protected by the sta spinlock)
tid_start_tx is also protected by sta-&gt;lock.
      </p></dd><dt><span class="term">tid_rx[IEEE80211_NUM_TIDS]</span></dt><dd><p>
aggregation info for Rx per TID -- RCU protected
      </p></dd><dt><span class="term">tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)]</span></dt><dd><p>
bitmap indicating on which TIDs the
RX timer expired until the work for it runs
      </p></dd><dt><span class="term">tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)]</span></dt><dd><p>
bitmap indicating which BA sessions per TID the
driver requested to close until the work for it runs
      </p></dd><dt><span class="term">work</span></dt><dd><p>
work struct for starting/stopping aggregation
      </p></dd><dt><span class="term">tid_tx[IEEE80211_NUM_TIDS]</span></dt><dd><p>
aggregation info for Tx per TID
      </p></dd><dt><span class="term">tid_start_tx[IEEE80211_NUM_TIDS]</span></dt><dd><p>
sessions where start was requested
      </p></dd><dt><span class="term">last_addba_req_time[IEEE80211_NUM_TIDS]</span></dt><dd><p>
timestamp of the last addBA request.
      </p></dd><dt><span class="term">addba_req_num[IEEE80211_NUM_TIDS]</span></dt><dd><p>
number of times addBA request has been sent.
      </p></dd><dt><span class="term">dialog_token_allocator</span></dt><dd><p>
dialog token enumerator for each new session;
      </p></dd></dl></div></div></div><div class="refentry" title="struct tid_ampdu_tx"><div class="refentry.separator"><hr></div><a id="API-struct-tid-ampdu-tx"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct tid_ampdu_tx — 
  TID aggregation information (Tx).
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct tid_ampdu_tx {
  struct rcu_head rcu_head;
  struct timer_list session_timer;
  struct timer_list addba_resp_timer;
  struct sk_buff_head pending;
  unsigned long state;
  unsigned long last_tx;
  u16 timeout;
  u8 dialog_token;
  u8 stop_initiator;
  bool tx_stop;
  u8 buf_size;
  u16 failed_bar_ssn;
  bool bar_pending;
};  </pre></div><div class="refsect1" title="Members"><a id="idp9264320"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">rcu_head</span></dt><dd><p>
rcu head for freeing structure
      </p></dd><dt><span class="term">session_timer</span></dt><dd><p>
check if we keep Tx-ing on the TID (by timeout value)
      </p></dd><dt><span class="term">addba_resp_timer</span></dt><dd><p>
timer for peer's response to addba request
      </p></dd><dt><span class="term">pending</span></dt><dd><p>
pending frames queue -- use sta's spinlock to protect
      </p></dd><dt><span class="term">state</span></dt><dd><p>
session state (see above)
      </p></dd><dt><span class="term">last_tx</span></dt><dd><p>
jiffies of last tx activity
      </p></dd><dt><span class="term">timeout</span></dt><dd><p>
session timeout value to be filled in ADDBA requests
      </p></dd><dt><span class="term">dialog_token</span></dt><dd><p>
dialog token for aggregation session
      </p></dd><dt><span class="term">stop_initiator</span></dt><dd><p>
initiator of a session stop
      </p></dd><dt><span class="term">tx_stop</span></dt><dd><p>
TX DelBA frame when stopping
      </p></dd><dt><span class="term">buf_size</span></dt><dd><p>
reorder buffer size at receiver
      </p></dd><dt><span class="term">failed_bar_ssn</span></dt><dd><p>
ssn of the last failed BAR tx attempt
      </p></dd><dt><span class="term">bar_pending</span></dt><dd><p>
BAR needs to be re-sent
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp9283328"></a><h2>Description</h2><p>
   This structure's lifetime is managed by RCU, assignments to
   the array holding it must hold the aggregation mutex.
   </p><p>

   The TX path can access it under RCU lock-free if, and
   only if, the state has the flag <code class="constant">HT_AGG_STATE_OPERATIONAL</code>
   set. Otherwise, the TX path must also acquire the spinlock
   and re-check the state, see comments in the tx code
   touching it.
</p></div></div><div class="refentry" title="struct tid_ampdu_rx"><div class="refentry.separator"><hr></div><a id="API-struct-tid-ampdu-rx"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>struct tid_ampdu_rx — 
  TID aggregation information (Rx).
 </p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><pre class="programlisting">struct tid_ampdu_rx {
  struct rcu_head rcu_head;
  spinlock_t reorder_lock;
  struct sk_buff ** reorder_buf;
  unsigned long * reorder_time;
  struct timer_list session_timer;
  struct timer_list reorder_timer;
  unsigned long last_rx;
  u16 head_seq_num;
  u16 stored_mpdu_num;
  u16 ssn;
  u16 buf_size;
  u16 timeout;
  u8 dialog_token;
};  </pre></div><div class="refsect1" title="Members"><a id="idp9293312"></a><h2>Members</h2><div class="variablelist"><dl><dt><span class="term">rcu_head</span></dt><dd><p>
RCU head used for freeing this struct
      </p></dd><dt><span class="term">reorder_lock</span></dt><dd><p>
serializes access to reorder buffer, see below.
      </p></dd><dt><span class="term">reorder_buf</span></dt><dd><p>
buffer to reorder incoming aggregated MPDUs
      </p></dd><dt><span class="term">reorder_time</span></dt><dd><p>
jiffies when skb was added
      </p></dd><dt><span class="term">session_timer</span></dt><dd><p>
check if peer keeps Tx-ing on the TID (by timeout value)
      </p></dd><dt><span class="term">reorder_timer</span></dt><dd><p>
releases expired frames from the reorder buffer.
      </p></dd><dt><span class="term">last_rx</span></dt><dd><p>
jiffies of last rx activity
      </p></dd><dt><span class="term">head_seq_num</span></dt><dd><p>
head sequence number in reordering buffer.
      </p></dd><dt><span class="term">stored_mpdu_num</span></dt><dd><p>
number of MPDUs in reordering buffer
      </p></dd><dt><span class="term">ssn</span></dt><dd><p>
Starting Sequence Number expected to be aggregated.
      </p></dd><dt><span class="term">buf_size</span></dt><dd><p>
buffer size for incoming A-MPDUs
      </p></dd><dt><span class="term">timeout</span></dt><dd><p>
reset timer value (in TUs).
      </p></dd><dt><span class="term">dialog_token</span></dt><dd><p>
dialog token for aggregation session
      </p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp9312352"></a><h2>Description</h2><p>
   This structure's lifetime is managed by RCU, assignments to
   the array holding it must hold the aggregation mutex.
   </p><p>

   The <em class="parameter"><code>reorder_lock</code></em> is used to protect the members of this
   struct, except for <em class="parameter"><code>timeout</code></em>, <em class="parameter"><code>buf_size</code></em> and <em class="parameter"><code>dialog_token</code></em>,
   which are constant across the lifetime of the struct (the
   dialog token being used only for debugging).
</p></div></div></div><div class="chapter" title="Chapter&nbsp;24.&nbsp;Synchronisation"><div class="titlepage"><div><div><h2 class="title"><a id="synchronisation"></a>Chapter&nbsp;24.&nbsp;Synchronisation</h2></div></div></div><p>TBD</p><p>Locking, lots of RCU</p></div></div></div></div></body></html>